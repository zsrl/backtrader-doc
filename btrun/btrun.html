<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.btrun.btrun API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.btrun.btrun</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime
import inspect
import itertools
import random
import string
import sys

import backtrader as bt


DATAFORMATS = dict(
    btcsv=bt.feeds.BacktraderCSVData,
    vchartcsv=bt.feeds.VChartCSVData,
    vcfile=bt.feeds.VChartFile,
    sierracsv=bt.feeds.SierraChartCSVData,
    mt4csv=bt.feeds.MT4CSVData,
    yahoocsv=bt.feeds.YahooFinanceCSVData,
    yahoocsv_unreversed=bt.feeds.YahooFinanceCSVData,
    yahoo=bt.feeds.YahooFinanceData,
)

try:
    DATAFORMATS[&#39;vcdata&#39;] = bt.feeds.VCData
except AttributeError:
    pass  # no comtypes available

try:
    DATAFORMATS[&#39;ibdata&#39;] = bt.feeds.IBData,
except AttributeError:
    pass  # no ibpy available

try:
    DATAFORMATS[&#39;oandadata&#39;] = bt.feeds.OandaData,
except AttributeError:
    pass  # no oandapy available


TIMEFRAMES = dict(
    microseconds=bt.TimeFrame.MicroSeconds,
    seconds=bt.TimeFrame.Seconds,
    minutes=bt.TimeFrame.Minutes,
    days=bt.TimeFrame.Days,
    weeks=bt.TimeFrame.Weeks,
    months=bt.TimeFrame.Months,
    years=bt.TimeFrame.Years,
)


def btrun(pargs=&#39;&#39;):
    args = parse_args(pargs)

    if args.flush:
        import backtrader.utils.flushfile

    stdstats = not args.nostdstats

    cer_kwargs_str = args.cerebro
    cer_kwargs = eval(&#39;dict(&#39; + cer_kwargs_str + &#39;)&#39;)
    if &#39;stdstats&#39; not in cer_kwargs:
        cer_kwargs.update(stdstats=stdstats)

    cerebro = bt.Cerebro(**cer_kwargs)

    if args.resample is not None or args.replay is not None:
        if args.resample is not None:
            tfcp = args.resample.split(&#39;:&#39;)
        elif args.replay is not None:
            tfcp = args.replay.split(&#39;:&#39;)

        # compression may be skipped and it will default to 1
        if len(tfcp) == 1 or tfcp[1] == &#39;&#39;:
            tf, cp = tfcp[0], 1
        else:
            tf, cp = tfcp

        cp = int(cp)  # convert any value to int
        tf = TIMEFRAMES.get(tf, None)

    for data in getdatas(args):
        if args.resample is not None:
            cerebro.resampledata(data, timeframe=tf, compression=cp)
        elif args.replay is not None:
            cerebro.replaydata(data, timeframe=tf, compression=cp)
        else:
            cerebro.adddata(data)

    # get and add signals
    signals = getobjects(args.signals, bt.Indicator, bt.signals, issignal=True)
    for sig, kwargs, sigtype in signals:
        stype = getattr(bt.signal, &#39;SIGNAL_&#39; + sigtype.upper())
        cerebro.add_signal(stype, sig, **kwargs)

    # get and add strategies
    strategies = getobjects(args.strategies, bt.Strategy, bt.strategies)
    for strat, kwargs in strategies:
        cerebro.addstrategy(strat, **kwargs)

    inds = getobjects(args.indicators, bt.Indicator, bt.indicators)
    for ind, kwargs in inds:
        cerebro.addindicator(ind, **kwargs)

    obs = getobjects(args.observers, bt.Observer, bt.observers)
    for ob, kwargs in obs:
        cerebro.addobserver(ob, **kwargs)

    ans = getobjects(args.analyzers, bt.Analyzer, bt.analyzers)
    for an, kwargs in ans:
        cerebro.addanalyzer(an, **kwargs)

    setbroker(args, cerebro)

    for wrkwargs_str in args.writers or []:
        wrkwargs = eval(&#39;dict(&#39; + wrkwargs_str + &#39;)&#39;)
        cerebro.addwriter(bt.WriterFile, **wrkwargs)

    ans = getfunctions(args.hooks, bt.Cerebro)
    for hook, kwargs in ans:
        hook(cerebro, **kwargs)
    runsts = cerebro.run()
    runst = runsts[0]  # single strategy and no optimization

    if args.pranalyzer or args.ppranalyzer:
        if runst.analyzers:
            print(&#39;====================&#39;)
            print(&#39;== Analyzers&#39;)
            print(&#39;====================&#39;)
            for name, analyzer in runst.analyzers.getitems():
                if args.pranalyzer:
                    analyzer.print()
                elif args.ppranalyzer:
                    print(&#39;##########&#39;)
                    print(name)
                    print(&#39;##########&#39;)
                    analyzer.pprint()

    if args.plot:
        pkwargs = dict(style=&#39;bar&#39;)
        if args.plot is not True:
            # evaluates to True but is not &#34;True&#34; - args were passed
            ekwargs = eval(&#39;dict(&#39; + args.plot + &#39;)&#39;)
            pkwargs.update(ekwargs)

        # cerebro.plot(numfigs=args.plotfigs, style=args.plotstyle)
        cerebro.plot(**pkwargs)


def setbroker(args, cerebro):
    broker = cerebro.getbroker()

    if args.cash is not None:
        broker.setcash(args.cash)

    commkwargs = dict()
    if args.commission is not None:
        commkwargs[&#39;commission&#39;] = args.commission
    if args.margin is not None:
        commkwargs[&#39;margin&#39;] = args.margin
    if args.mult is not None:
        commkwargs[&#39;mult&#39;] = args.mult
    if args.interest is not None:
        commkwargs[&#39;interest&#39;] = args.interest
    if args.interest_long is not None:
        commkwargs[&#39;interest_long&#39;] = args.interest_long

    if commkwargs:
        broker.setcommission(**commkwargs)

    if args.slip_perc is not None:
        cerebro.broker.set_slippage_perc(args.slip_perc,
                                         slip_open=args.slip_open,
                                         slip_match=not args.no_slip_match,
                                         slip_out=args.slip_out)
    elif args.slip_fixed is not None:
        cerebro.broker.set_slippage_fixed(args.slip_fixed,
                                          slip_open=args.slip_open,
                                          slip_match=not args.no_slip_match,
                                          slip_out=args.slip_out)


def getdatas(args):
    # Get the data feed class from the global dictionary
    dfcls = DATAFORMATS[args.format]

    # Prepare some args
    dfkwargs = dict()
    if args.format == &#39;yahoo_unreversed&#39;:
        dfkwargs[&#39;reverse&#39;] = True

    fmtstr = &#39;%Y-%m-%d&#39;
    if args.fromdate:
        dtsplit = args.fromdate.split(&#39;T&#39;)
        if len(dtsplit) &gt; 1:
            fmtstr += &#39;T%H:%M:%S&#39;

        fromdate = datetime.datetime.strptime(args.fromdate, fmtstr)
        dfkwargs[&#39;fromdate&#39;] = fromdate

    fmtstr = &#39;%Y-%m-%d&#39;
    if args.todate:
        dtsplit = args.todate.split(&#39;T&#39;)
        if len(dtsplit) &gt; 1:
            fmtstr += &#39;T%H:%M:%S&#39;
        todate = datetime.datetime.strptime(args.todate, fmtstr)
        dfkwargs[&#39;todate&#39;] = todate

    if args.timeframe is not None:
        dfkwargs[&#39;timeframe&#39;] = TIMEFRAMES[args.timeframe]

    if args.compression is not None:
        dfkwargs[&#39;compression&#39;] = args.compression

    datas = list()
    for dname in args.data:
        dfkwargs[&#39;dataname&#39;] = dname
        data = dfcls(**dfkwargs)
        datas.append(data)

    return datas


def getmodclasses(mod, clstype, clsname=None):
    clsmembers = inspect.getmembers(mod, inspect.isclass)

    clslist = list()
    for name, cls in clsmembers:
        if not issubclass(cls, clstype):
            continue

        if clsname:
            if clsname == name:
                clslist.append(cls)
                break
        else:
            clslist.append(cls)

    return clslist


def getmodfunctions(mod, funcname=None):
    members = inspect.getmembers(mod, inspect.isfunction) + \
        inspect.getmembers(mod, inspect.ismethod)

    funclist = list()
    for name, member in members:
        if funcname:
            if name == funcname:
                funclist.append(member)
                break
        else:
            funclist.append(member)

    return funclist


def loadmodule(modpath, modname=&#39;&#39;):
    # generate a random name for the module

    if not modpath.endswith(&#39;.py&#39;):
        modpath += &#39;.py&#39;

    if not modname:
        chars = string.ascii_uppercase + string.digits
        modname = &#39;&#39;.join(random.choice(chars) for _ in range(10))

    version = (sys.version_info[0], sys.version_info[1])

    if version &lt; (3, 3):
        mod, e = loadmodule2(modpath, modname)
    else:
        mod, e = loadmodule3(modpath, modname)

    return mod, e


def loadmodule2(modpath, modname):
    import imp

    try:
        mod = imp.load_source(modname, modpath)
    except Exception as e:
        return (None, e)

    return (mod, None)


def loadmodule3(modpath, modname):
    import importlib.machinery

    try:
        loader = importlib.machinery.SourceFileLoader(modname, modpath)
        mod = loader.load_module()
    except Exception as e:
        return (None, e)

    return (mod, None)


def getobjects(iterable, clsbase, modbase, issignal=False):
    retobjects = list()

    for item in iterable or []:
        if issignal:
            sigtokens = item.split(&#39;+&#39;, 1)
            if len(sigtokens) == 1:  # no + seen
                sigtype = &#39;longshort&#39;
            else:
                sigtype, item = sigtokens

        tokens = item.split(&#39;:&#39;, 1)

        if len(tokens) == 1:
            modpath = tokens[0]
            name = &#39;&#39;
            kwargs = dict()
        else:
            modpath, name = tokens
            kwtokens = name.split(&#39;:&#39;, 1)
            if len(kwtokens) == 1:
                # no &#39;(&#39; found
                kwargs = dict()
            else:
                name = kwtokens[0]
                kwtext = &#39;dict(&#39; + kwtokens[1] + &#39;)&#39;
                kwargs = eval(kwtext)

        if modpath:
            mod, e = loadmodule(modpath)

            if not mod:
                print(&#39;&#39;)
                print(&#39;Failed to load module %s:&#39; % modpath, e)
                sys.exit(1)
        else:
            mod = modbase

        loaded = getmodclasses(mod=mod, clstype=clsbase, clsname=name)

        if not loaded:
            print(&#39;No class %s / module %s&#39; % (str(name), modpath))
            sys.exit(1)

        if issignal:
            retobjects.append((loaded[0], kwargs, sigtype))
        else:
            retobjects.append((loaded[0], kwargs))

    return retobjects

def getfunctions(iterable, modbase):
    retfunctions = list()

    for item in iterable or []:
        tokens = item.split(&#39;:&#39;, 1)

        if len(tokens) == 1:
            modpath = tokens[0]
            name = &#39;&#39;
            kwargs = dict()
        else:
            modpath, name = tokens
            kwtokens = name.split(&#39;:&#39;, 1)
            if len(kwtokens) == 1:
                # no &#39;(&#39; found
                kwargs = dict()
            else:
                name = kwtokens[0]
                kwtext = &#39;dict(&#39; + kwtokens[1] + &#39;)&#39;
                kwargs = eval(kwtext)

        if modpath:
            mod, e = loadmodule(modpath)

            if not mod:
                print(&#39;&#39;)
                print(&#39;Failed to load module %s:&#39; % modpath, e)
                sys.exit(1)
        else:
            mod = modbase

        loaded = getmodfunctions(mod=mod, funcname=name)

        if not loaded:
            print(&#39;No function %s / module %s&#39; % (str(name), modpath))
            sys.exit(1)

        retfunctions.append((loaded[0], kwargs))

    return retfunctions


def parse_args(pargs=&#39;&#39;):
    parser = argparse.ArgumentParser(
        description=&#39;Backtrader Run Script&#39;,
        formatter_class=argparse.RawTextHelpFormatter,
    )

    group = parser.add_argument_group(title=&#39;Data options&#39;)
    # Data options
    group.add_argument(&#39;--data&#39;, &#39;-d&#39;, action=&#39;append&#39;, required=True,
                       help=&#39;Data files to be added to the system&#39;)

    group = parser.add_argument_group(title=&#39;Cerebro options&#39;)
    group.add_argument(
        &#39;--cerebro&#39;, &#39;-cer&#39;,
        metavar=&#39;kwargs&#39;,
        required=False, const=&#39;&#39;, default=&#39;&#39;, nargs=&#39;?&#39;,
        help=(&#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: &#34;preload=True&#34; which set its to True\n&#39;
              &#39;\n&#39;
              &#39;The passed kwargs will be passed directly to the cerebro\n&#39;
              &#39;instance created for the execution\n&#39;
              &#39;\n&#39;
              &#39;The available kwargs to cerebro are:\n&#39;
              &#39;  - preload (default: True)\n&#39;
              &#39;  - runonce (default: True)\n&#39;
              &#39;  - maxcpus (default: None)\n&#39;
              &#39;  - stdstats (default: True)\n&#39;
              &#39;  - live (default: False)\n&#39;
              &#39;  - exactbars (default: False)\n&#39;
              &#39;  - preload (default: True)\n&#39;
              &#39;  - writer (default False)\n&#39;
              &#39;  - oldbuysell (default False)\n&#39;
              &#39;  - tradehistory (default False)\n&#39;)
    )

    group.add_argument(&#39;--nostdstats&#39;, action=&#39;store_true&#39;,
                       help=&#39;Disable the standard statistics observers&#39;)

    datakeys = list(DATAFORMATS)
    group.add_argument(&#39;--format&#39;, &#39;--csvformat&#39;, &#39;-c&#39;, required=False,
                       default=&#39;btcsv&#39;, choices=datakeys,
                       help=&#39;CSV Format&#39;)

    group.add_argument(&#39;--fromdate&#39;, &#39;-f&#39;, required=False, default=None,
                       help=&#39;Starting date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--todate&#39;, &#39;-t&#39;, required=False, default=None,
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--timeframe&#39;, &#39;-tf&#39;, required=False, default=&#39;days&#39;,
                       choices=TIMEFRAMES.keys(),
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--compression&#39;, &#39;-cp&#39;, required=False, default=1,
                       type=int,
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group = parser.add_mutually_exclusive_group(required=False)

    group.add_argument(&#39;--resample&#39;, &#39;-rs&#39;, required=False, default=None,
                       help=&#39;resample with timeframe:compression values&#39;)

    group.add_argument(&#39;--replay&#39;, &#39;-rp&#39;, required=False, default=None,
                       help=&#39;replay with timeframe:compression values&#39;)

    group.add_argument(
        &#39;--hook&#39;, dest=&#39;hooks&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:hookfunction:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:hookfunction:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myhook:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then hookfunction will be sought\n&#39;
              &#39;as the built-in cerebro method. Example:\n&#39;
              &#39;\n&#39;
              &#39;  - :addtz:tz=America/St_Johns\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st function found in the\n&#39;
              &#39;mod will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs\n&#39;
              &#39;\n&#39;
              &#39;The function specified will be called, with cerebro\n&#39;
              &#39;instance passed as the first argument together with\n&#39;
              &#39;kwargs, if any were specified. This allows to customize\n&#39;
              &#39;cerebro, beyond options provided by this script\n\n&#39;)
    )

    # Module where to read the strategy from
    group = parser.add_argument_group(title=&#39;Strategy options&#39;)
    group.add_argument(
        &#39;--strategy&#39;, &#39;-st&#39;, dest=&#39;strategies&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in strategies module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st strategy found in the mod\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Module where to read the strategy from
    group = parser.add_argument_group(title=&#39;Signals&#39;)
    group.add_argument(
        &#39;--signal&#39;, &#39;-sig&#39;, dest=&#39;signals&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:signaltype:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - signaltype:module:signaltype:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: longshort+mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;signaltype may be ommited: longshort will be used\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;signaltype will be uppercased to match the defintions\n&#39;
              &#39;fromt the backtrader.signal module\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in signals module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - LONGSHORT::name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st signal found in the mod\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module:::kwargs&#39;)
    )

    # Observers
    group = parser.add_argument_group(title=&#39;Observers and statistics&#39;)
    group.add_argument(
        &#39;--observer&#39;, &#39;-ob&#39;, dest=&#39;observers&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in observers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st observer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )
    # Analyzers
    group = parser.add_argument_group(title=&#39;Analyzers&#39;)
    group.add_argument(
        &#39;--analyzer&#39;, &#39;-an&#39;, dest=&#39;analyzers&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in analyzers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st analyzer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Analyzer - Print
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(&#39;--pranalyzer&#39;, &#39;-pralyzer&#39;,
                       required=False, action=&#39;store_true&#39;,
                       help=(&#39;Automatically print analyzers&#39;))

    group.add_argument(&#39;--ppranalyzer&#39;, &#39;-ppralyzer&#39;,
                       required=False, action=&#39;store_true&#39;,
                       help=(&#39;Automatically PRETTY print analyzers&#39;))

    # Indicators
    group = parser.add_argument_group(title=&#39;Indicators&#39;)
    group.add_argument(
        &#39;--indicator&#39;, &#39;-ind&#39;, dest=&#39;indicators&#39;,
        metavar=&#39;module:name:kwargs&#39;,
        action=&#39;append&#39;, required=False,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in analyzers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st analyzer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Writer
    group = parser.add_argument_group(title=&#39;Writers&#39;)
    group.add_argument(
        &#39;--writer&#39;, &#39;-wr&#39;,
        dest=&#39;writers&#39;, metavar=&#39;kwargs&#39;, nargs=&#39;?&#39;,
        action=&#39;append&#39;, required=False, const=&#39;&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;It creates a system wide writer which outputs run data\n&#39;
              &#39;\n&#39;
              &#39;Please see the documentation for the available kwargs&#39;)
    )

    # Broker/Commissions
    group = parser.add_argument_group(title=&#39;Cash and Commission Scheme Args&#39;)
    group.add_argument(&#39;--cash&#39;, &#39;-cash&#39;, required=False, type=float,
                       help=&#39;Cash to set to the broker&#39;)
    group.add_argument(&#39;--commission&#39;, &#39;-comm&#39;, required=False, type=float,
                       help=&#39;Commission value to set&#39;)
    group.add_argument(&#39;--margin&#39;, &#39;-marg&#39;, required=False, type=float,
                       help=&#39;Margin type to set&#39;)
    group.add_argument(&#39;--mult&#39;, &#39;-mul&#39;, required=False, type=float,
                       help=&#39;Multiplier to use&#39;)

    group.add_argument(&#39;--interest&#39;, required=False, type=float,
                       default=None,
                       help=&#39;Credit Interest rate to apply (0.0x)&#39;)

    group.add_argument(&#39;--interest_long&#39;, action=&#39;store_true&#39;,
                       required=False, default=None,
                       help=&#39;Apply credit interest to long positions&#39;)

    group.add_argument(&#39;--slip_perc&#39;, required=False, default=None,
                       type=float,
                       help=&#39;Enable slippage with a percentage value&#39;)
    group.add_argument(&#39;--slip_fixed&#39;, required=False, default=None,
                       type=float,
                       help=&#39;Enable slippage with a fixed point value&#39;)

    group.add_argument(&#39;--slip_open&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;enable slippage for when matching opening prices&#39;)

    group.add_argument(&#39;--no-slip_match&#39;, required=False, action=&#39;store_true&#39;,
                       help=(&#39;Disable slip_match, ie: matching capped at \n&#39;
                             &#39;high-low if slippage goes over those limits&#39;))
    group.add_argument(&#39;--slip_out&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;with slip_match enabled, match outside high-low&#39;)

    # Output flushing
    group.add_argument(&#39;--flush&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;flush the output - useful under win32 systems&#39;)

    # Plot options
    parser.add_argument(
        &#39;--plot&#39;, &#39;-p&#39;, nargs=&#39;?&#39;,
        metavar=&#39;kwargs&#39;,
        default=False, const=True, required=False,
        help=(&#39;Plot the read data applying any kwargs passed\n&#39;
              &#39;\n&#39;
              &#39;For example:\n&#39;
              &#39;\n&#39;
              &#39;  --plot style=&#34;candle&#34; (to plot candlesticks)\n&#39;)
    )

    if pargs:
        return parser.parse_args(pargs)

    return parser.parse_args()


if __name__ == &#39;__main__&#39;:
    btrun()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backtrader.btrun.btrun.btrun"><code class="name flex">
<span>def <span class="ident">btrun</span></span>(<span>pargs='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def btrun(pargs=&#39;&#39;):
    args = parse_args(pargs)

    if args.flush:
        import backtrader.utils.flushfile

    stdstats = not args.nostdstats

    cer_kwargs_str = args.cerebro
    cer_kwargs = eval(&#39;dict(&#39; + cer_kwargs_str + &#39;)&#39;)
    if &#39;stdstats&#39; not in cer_kwargs:
        cer_kwargs.update(stdstats=stdstats)

    cerebro = bt.Cerebro(**cer_kwargs)

    if args.resample is not None or args.replay is not None:
        if args.resample is not None:
            tfcp = args.resample.split(&#39;:&#39;)
        elif args.replay is not None:
            tfcp = args.replay.split(&#39;:&#39;)

        # compression may be skipped and it will default to 1
        if len(tfcp) == 1 or tfcp[1] == &#39;&#39;:
            tf, cp = tfcp[0], 1
        else:
            tf, cp = tfcp

        cp = int(cp)  # convert any value to int
        tf = TIMEFRAMES.get(tf, None)

    for data in getdatas(args):
        if args.resample is not None:
            cerebro.resampledata(data, timeframe=tf, compression=cp)
        elif args.replay is not None:
            cerebro.replaydata(data, timeframe=tf, compression=cp)
        else:
            cerebro.adddata(data)

    # get and add signals
    signals = getobjects(args.signals, bt.Indicator, bt.signals, issignal=True)
    for sig, kwargs, sigtype in signals:
        stype = getattr(bt.signal, &#39;SIGNAL_&#39; + sigtype.upper())
        cerebro.add_signal(stype, sig, **kwargs)

    # get and add strategies
    strategies = getobjects(args.strategies, bt.Strategy, bt.strategies)
    for strat, kwargs in strategies:
        cerebro.addstrategy(strat, **kwargs)

    inds = getobjects(args.indicators, bt.Indicator, bt.indicators)
    for ind, kwargs in inds:
        cerebro.addindicator(ind, **kwargs)

    obs = getobjects(args.observers, bt.Observer, bt.observers)
    for ob, kwargs in obs:
        cerebro.addobserver(ob, **kwargs)

    ans = getobjects(args.analyzers, bt.Analyzer, bt.analyzers)
    for an, kwargs in ans:
        cerebro.addanalyzer(an, **kwargs)

    setbroker(args, cerebro)

    for wrkwargs_str in args.writers or []:
        wrkwargs = eval(&#39;dict(&#39; + wrkwargs_str + &#39;)&#39;)
        cerebro.addwriter(bt.WriterFile, **wrkwargs)

    ans = getfunctions(args.hooks, bt.Cerebro)
    for hook, kwargs in ans:
        hook(cerebro, **kwargs)
    runsts = cerebro.run()
    runst = runsts[0]  # single strategy and no optimization

    if args.pranalyzer or args.ppranalyzer:
        if runst.analyzers:
            print(&#39;====================&#39;)
            print(&#39;== Analyzers&#39;)
            print(&#39;====================&#39;)
            for name, analyzer in runst.analyzers.getitems():
                if args.pranalyzer:
                    analyzer.print()
                elif args.ppranalyzer:
                    print(&#39;##########&#39;)
                    print(name)
                    print(&#39;##########&#39;)
                    analyzer.pprint()

    if args.plot:
        pkwargs = dict(style=&#39;bar&#39;)
        if args.plot is not True:
            # evaluates to True but is not &#34;True&#34; - args were passed
            ekwargs = eval(&#39;dict(&#39; + args.plot + &#39;)&#39;)
            pkwargs.update(ekwargs)

        # cerebro.plot(numfigs=args.plotfigs, style=args.plotstyle)
        cerebro.plot(**pkwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.getdatas"><code class="name flex">
<span>def <span class="ident">getdatas</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getdatas(args):
    # Get the data feed class from the global dictionary
    dfcls = DATAFORMATS[args.format]

    # Prepare some args
    dfkwargs = dict()
    if args.format == &#39;yahoo_unreversed&#39;:
        dfkwargs[&#39;reverse&#39;] = True

    fmtstr = &#39;%Y-%m-%d&#39;
    if args.fromdate:
        dtsplit = args.fromdate.split(&#39;T&#39;)
        if len(dtsplit) &gt; 1:
            fmtstr += &#39;T%H:%M:%S&#39;

        fromdate = datetime.datetime.strptime(args.fromdate, fmtstr)
        dfkwargs[&#39;fromdate&#39;] = fromdate

    fmtstr = &#39;%Y-%m-%d&#39;
    if args.todate:
        dtsplit = args.todate.split(&#39;T&#39;)
        if len(dtsplit) &gt; 1:
            fmtstr += &#39;T%H:%M:%S&#39;
        todate = datetime.datetime.strptime(args.todate, fmtstr)
        dfkwargs[&#39;todate&#39;] = todate

    if args.timeframe is not None:
        dfkwargs[&#39;timeframe&#39;] = TIMEFRAMES[args.timeframe]

    if args.compression is not None:
        dfkwargs[&#39;compression&#39;] = args.compression

    datas = list()
    for dname in args.data:
        dfkwargs[&#39;dataname&#39;] = dname
        data = dfcls(**dfkwargs)
        datas.append(data)

    return datas</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.getfunctions"><code class="name flex">
<span>def <span class="ident">getfunctions</span></span>(<span>iterable, modbase)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getfunctions(iterable, modbase):
    retfunctions = list()

    for item in iterable or []:
        tokens = item.split(&#39;:&#39;, 1)

        if len(tokens) == 1:
            modpath = tokens[0]
            name = &#39;&#39;
            kwargs = dict()
        else:
            modpath, name = tokens
            kwtokens = name.split(&#39;:&#39;, 1)
            if len(kwtokens) == 1:
                # no &#39;(&#39; found
                kwargs = dict()
            else:
                name = kwtokens[0]
                kwtext = &#39;dict(&#39; + kwtokens[1] + &#39;)&#39;
                kwargs = eval(kwtext)

        if modpath:
            mod, e = loadmodule(modpath)

            if not mod:
                print(&#39;&#39;)
                print(&#39;Failed to load module %s:&#39; % modpath, e)
                sys.exit(1)
        else:
            mod = modbase

        loaded = getmodfunctions(mod=mod, funcname=name)

        if not loaded:
            print(&#39;No function %s / module %s&#39; % (str(name), modpath))
            sys.exit(1)

        retfunctions.append((loaded[0], kwargs))

    return retfunctions</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.getmodclasses"><code class="name flex">
<span>def <span class="ident">getmodclasses</span></span>(<span>mod, clstype, clsname=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getmodclasses(mod, clstype, clsname=None):
    clsmembers = inspect.getmembers(mod, inspect.isclass)

    clslist = list()
    for name, cls in clsmembers:
        if not issubclass(cls, clstype):
            continue

        if clsname:
            if clsname == name:
                clslist.append(cls)
                break
        else:
            clslist.append(cls)

    return clslist</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.getmodfunctions"><code class="name flex">
<span>def <span class="ident">getmodfunctions</span></span>(<span>mod, funcname=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getmodfunctions(mod, funcname=None):
    members = inspect.getmembers(mod, inspect.isfunction) + \
        inspect.getmembers(mod, inspect.ismethod)

    funclist = list()
    for name, member in members:
        if funcname:
            if name == funcname:
                funclist.append(member)
                break
        else:
            funclist.append(member)

    return funclist</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.getobjects"><code class="name flex">
<span>def <span class="ident">getobjects</span></span>(<span>iterable, clsbase, modbase, issignal=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getobjects(iterable, clsbase, modbase, issignal=False):
    retobjects = list()

    for item in iterable or []:
        if issignal:
            sigtokens = item.split(&#39;+&#39;, 1)
            if len(sigtokens) == 1:  # no + seen
                sigtype = &#39;longshort&#39;
            else:
                sigtype, item = sigtokens

        tokens = item.split(&#39;:&#39;, 1)

        if len(tokens) == 1:
            modpath = tokens[0]
            name = &#39;&#39;
            kwargs = dict()
        else:
            modpath, name = tokens
            kwtokens = name.split(&#39;:&#39;, 1)
            if len(kwtokens) == 1:
                # no &#39;(&#39; found
                kwargs = dict()
            else:
                name = kwtokens[0]
                kwtext = &#39;dict(&#39; + kwtokens[1] + &#39;)&#39;
                kwargs = eval(kwtext)

        if modpath:
            mod, e = loadmodule(modpath)

            if not mod:
                print(&#39;&#39;)
                print(&#39;Failed to load module %s:&#39; % modpath, e)
                sys.exit(1)
        else:
            mod = modbase

        loaded = getmodclasses(mod=mod, clstype=clsbase, clsname=name)

        if not loaded:
            print(&#39;No class %s / module %s&#39; % (str(name), modpath))
            sys.exit(1)

        if issignal:
            retobjects.append((loaded[0], kwargs, sigtype))
        else:
            retobjects.append((loaded[0], kwargs))

    return retobjects</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.loadmodule"><code class="name flex">
<span>def <span class="ident">loadmodule</span></span>(<span>modpath, modname='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmodule(modpath, modname=&#39;&#39;):
    # generate a random name for the module

    if not modpath.endswith(&#39;.py&#39;):
        modpath += &#39;.py&#39;

    if not modname:
        chars = string.ascii_uppercase + string.digits
        modname = &#39;&#39;.join(random.choice(chars) for _ in range(10))

    version = (sys.version_info[0], sys.version_info[1])

    if version &lt; (3, 3):
        mod, e = loadmodule2(modpath, modname)
    else:
        mod, e = loadmodule3(modpath, modname)

    return mod, e</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.loadmodule2"><code class="name flex">
<span>def <span class="ident">loadmodule2</span></span>(<span>modpath, modname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmodule2(modpath, modname):
    import imp

    try:
        mod = imp.load_source(modname, modpath)
    except Exception as e:
        return (None, e)

    return (mod, None)</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.loadmodule3"><code class="name flex">
<span>def <span class="ident">loadmodule3</span></span>(<span>modpath, modname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmodule3(modpath, modname):
    import importlib.machinery

    try:
        loader = importlib.machinery.SourceFileLoader(modname, modpath)
        mod = loader.load_module()
    except Exception as e:
        return (None, e)

    return (mod, None)</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>pargs='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(pargs=&#39;&#39;):
    parser = argparse.ArgumentParser(
        description=&#39;Backtrader Run Script&#39;,
        formatter_class=argparse.RawTextHelpFormatter,
    )

    group = parser.add_argument_group(title=&#39;Data options&#39;)
    # Data options
    group.add_argument(&#39;--data&#39;, &#39;-d&#39;, action=&#39;append&#39;, required=True,
                       help=&#39;Data files to be added to the system&#39;)

    group = parser.add_argument_group(title=&#39;Cerebro options&#39;)
    group.add_argument(
        &#39;--cerebro&#39;, &#39;-cer&#39;,
        metavar=&#39;kwargs&#39;,
        required=False, const=&#39;&#39;, default=&#39;&#39;, nargs=&#39;?&#39;,
        help=(&#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: &#34;preload=True&#34; which set its to True\n&#39;
              &#39;\n&#39;
              &#39;The passed kwargs will be passed directly to the cerebro\n&#39;
              &#39;instance created for the execution\n&#39;
              &#39;\n&#39;
              &#39;The available kwargs to cerebro are:\n&#39;
              &#39;  - preload (default: True)\n&#39;
              &#39;  - runonce (default: True)\n&#39;
              &#39;  - maxcpus (default: None)\n&#39;
              &#39;  - stdstats (default: True)\n&#39;
              &#39;  - live (default: False)\n&#39;
              &#39;  - exactbars (default: False)\n&#39;
              &#39;  - preload (default: True)\n&#39;
              &#39;  - writer (default False)\n&#39;
              &#39;  - oldbuysell (default False)\n&#39;
              &#39;  - tradehistory (default False)\n&#39;)
    )

    group.add_argument(&#39;--nostdstats&#39;, action=&#39;store_true&#39;,
                       help=&#39;Disable the standard statistics observers&#39;)

    datakeys = list(DATAFORMATS)
    group.add_argument(&#39;--format&#39;, &#39;--csvformat&#39;, &#39;-c&#39;, required=False,
                       default=&#39;btcsv&#39;, choices=datakeys,
                       help=&#39;CSV Format&#39;)

    group.add_argument(&#39;--fromdate&#39;, &#39;-f&#39;, required=False, default=None,
                       help=&#39;Starting date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--todate&#39;, &#39;-t&#39;, required=False, default=None,
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--timeframe&#39;, &#39;-tf&#39;, required=False, default=&#39;days&#39;,
                       choices=TIMEFRAMES.keys(),
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group.add_argument(&#39;--compression&#39;, &#39;-cp&#39;, required=False, default=1,
                       type=int,
                       help=&#39;Ending date in YYYY-MM-DD[THH:MM:SS] format&#39;)

    group = parser.add_mutually_exclusive_group(required=False)

    group.add_argument(&#39;--resample&#39;, &#39;-rs&#39;, required=False, default=None,
                       help=&#39;resample with timeframe:compression values&#39;)

    group.add_argument(&#39;--replay&#39;, &#39;-rp&#39;, required=False, default=None,
                       help=&#39;replay with timeframe:compression values&#39;)

    group.add_argument(
        &#39;--hook&#39;, dest=&#39;hooks&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:hookfunction:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:hookfunction:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myhook:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then hookfunction will be sought\n&#39;
              &#39;as the built-in cerebro method. Example:\n&#39;
              &#39;\n&#39;
              &#39;  - :addtz:tz=America/St_Johns\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st function found in the\n&#39;
              &#39;mod will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs\n&#39;
              &#39;\n&#39;
              &#39;The function specified will be called, with cerebro\n&#39;
              &#39;instance passed as the first argument together with\n&#39;
              &#39;kwargs, if any were specified. This allows to customize\n&#39;
              &#39;cerebro, beyond options provided by this script\n\n&#39;)
    )

    # Module where to read the strategy from
    group = parser.add_argument_group(title=&#39;Strategy options&#39;)
    group.add_argument(
        &#39;--strategy&#39;, &#39;-st&#39;, dest=&#39;strategies&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in strategies module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st strategy found in the mod\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Module where to read the strategy from
    group = parser.add_argument_group(title=&#39;Signals&#39;)
    group.add_argument(
        &#39;--signal&#39;, &#39;-sig&#39;, dest=&#39;signals&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:signaltype:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - signaltype:module:signaltype:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: longshort+mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;signaltype may be ommited: longshort will be used\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;signaltype will be uppercased to match the defintions\n&#39;
              &#39;fromt the backtrader.signal module\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in signals module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - LONGSHORT::name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st signal found in the mod\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module:::kwargs&#39;)
    )

    # Observers
    group = parser.add_argument_group(title=&#39;Observers and statistics&#39;)
    group.add_argument(
        &#39;--observer&#39;, &#39;-ob&#39;, dest=&#39;observers&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in observers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st observer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )
    # Analyzers
    group = parser.add_argument_group(title=&#39;Analyzers&#39;)
    group.add_argument(
        &#39;--analyzer&#39;, &#39;-an&#39;, dest=&#39;analyzers&#39;,
        action=&#39;append&#39;, required=False,
        metavar=&#39;module:name:kwargs&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in analyzers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st analyzer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Analyzer - Print
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(&#39;--pranalyzer&#39;, &#39;-pralyzer&#39;,
                       required=False, action=&#39;store_true&#39;,
                       help=(&#39;Automatically print analyzers&#39;))

    group.add_argument(&#39;--ppranalyzer&#39;, &#39;-ppralyzer&#39;,
                       required=False, action=&#39;store_true&#39;,
                       help=(&#39;Automatically PRETTY print analyzers&#39;))

    # Indicators
    group = parser.add_argument_group(title=&#39;Indicators&#39;)
    group.add_argument(
        &#39;--indicator&#39;, &#39;-ind&#39;, dest=&#39;indicators&#39;,
        metavar=&#39;module:name:kwargs&#39;,
        action=&#39;append&#39;, required=False,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - module:classname:kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: mymod:myclass:a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;If module is omitted then class name will be sought in\n&#39;
              &#39;the built-in analyzers module. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - :name:kwargs or :name\n&#39;
              &#39;\n&#39;
              &#39;If name is omitted, then the 1st analyzer found in the\n&#39;
              &#39;will be used. Such as in:\n&#39;
              &#39;\n&#39;
              &#39;  - module or module::kwargs&#39;)
    )

    # Writer
    group = parser.add_argument_group(title=&#39;Writers&#39;)
    group.add_argument(
        &#39;--writer&#39;, &#39;-wr&#39;,
        dest=&#39;writers&#39;, metavar=&#39;kwargs&#39;, nargs=&#39;?&#39;,
        action=&#39;append&#39;, required=False, const=&#39;&#39;,
        help=(&#39;This option can be specified multiple times.\n&#39;
              &#39;\n&#39;
              &#39;The argument can be specified with the following form:\n&#39;
              &#39;\n&#39;
              &#39;  - kwargs\n&#39;
              &#39;\n&#39;
              &#39;    Example: a=1,b=2\n&#39;
              &#39;\n&#39;
              &#39;kwargs is optional\n&#39;
              &#39;\n&#39;
              &#39;It creates a system wide writer which outputs run data\n&#39;
              &#39;\n&#39;
              &#39;Please see the documentation for the available kwargs&#39;)
    )

    # Broker/Commissions
    group = parser.add_argument_group(title=&#39;Cash and Commission Scheme Args&#39;)
    group.add_argument(&#39;--cash&#39;, &#39;-cash&#39;, required=False, type=float,
                       help=&#39;Cash to set to the broker&#39;)
    group.add_argument(&#39;--commission&#39;, &#39;-comm&#39;, required=False, type=float,
                       help=&#39;Commission value to set&#39;)
    group.add_argument(&#39;--margin&#39;, &#39;-marg&#39;, required=False, type=float,
                       help=&#39;Margin type to set&#39;)
    group.add_argument(&#39;--mult&#39;, &#39;-mul&#39;, required=False, type=float,
                       help=&#39;Multiplier to use&#39;)

    group.add_argument(&#39;--interest&#39;, required=False, type=float,
                       default=None,
                       help=&#39;Credit Interest rate to apply (0.0x)&#39;)

    group.add_argument(&#39;--interest_long&#39;, action=&#39;store_true&#39;,
                       required=False, default=None,
                       help=&#39;Apply credit interest to long positions&#39;)

    group.add_argument(&#39;--slip_perc&#39;, required=False, default=None,
                       type=float,
                       help=&#39;Enable slippage with a percentage value&#39;)
    group.add_argument(&#39;--slip_fixed&#39;, required=False, default=None,
                       type=float,
                       help=&#39;Enable slippage with a fixed point value&#39;)

    group.add_argument(&#39;--slip_open&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;enable slippage for when matching opening prices&#39;)

    group.add_argument(&#39;--no-slip_match&#39;, required=False, action=&#39;store_true&#39;,
                       help=(&#39;Disable slip_match, ie: matching capped at \n&#39;
                             &#39;high-low if slippage goes over those limits&#39;))
    group.add_argument(&#39;--slip_out&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;with slip_match enabled, match outside high-low&#39;)

    # Output flushing
    group.add_argument(&#39;--flush&#39;, required=False, action=&#39;store_true&#39;,
                       help=&#39;flush the output - useful under win32 systems&#39;)

    # Plot options
    parser.add_argument(
        &#39;--plot&#39;, &#39;-p&#39;, nargs=&#39;?&#39;,
        metavar=&#39;kwargs&#39;,
        default=False, const=True, required=False,
        help=(&#39;Plot the read data applying any kwargs passed\n&#39;
              &#39;\n&#39;
              &#39;For example:\n&#39;
              &#39;\n&#39;
              &#39;  --plot style=&#34;candle&#34; (to plot candlesticks)\n&#39;)
    )

    if pargs:
        return parser.parse_args(pargs)

    return parser.parse_args()</code></pre>
</details>
</dd>
<dt id="backtrader.btrun.btrun.setbroker"><code class="name flex">
<span>def <span class="ident">setbroker</span></span>(<span>args, cerebro)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setbroker(args, cerebro):
    broker = cerebro.getbroker()

    if args.cash is not None:
        broker.setcash(args.cash)

    commkwargs = dict()
    if args.commission is not None:
        commkwargs[&#39;commission&#39;] = args.commission
    if args.margin is not None:
        commkwargs[&#39;margin&#39;] = args.margin
    if args.mult is not None:
        commkwargs[&#39;mult&#39;] = args.mult
    if args.interest is not None:
        commkwargs[&#39;interest&#39;] = args.interest
    if args.interest_long is not None:
        commkwargs[&#39;interest_long&#39;] = args.interest_long

    if commkwargs:
        broker.setcommission(**commkwargs)

    if args.slip_perc is not None:
        cerebro.broker.set_slippage_perc(args.slip_perc,
                                         slip_open=args.slip_open,
                                         slip_match=not args.no_slip_match,
                                         slip_out=args.slip_out)
    elif args.slip_fixed is not None:
        cerebro.broker.set_slippage_fixed(args.slip_fixed,
                                          slip_open=args.slip_open,
                                          slip_match=not args.no_slip_match,
                                          slip_out=args.slip_out)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader.btrun" href="index.html">backtrader.btrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="backtrader.btrun.btrun.btrun" href="#backtrader.btrun.btrun.btrun">btrun</a></code></li>
<li><code><a title="backtrader.btrun.btrun.getdatas" href="#backtrader.btrun.btrun.getdatas">getdatas</a></code></li>
<li><code><a title="backtrader.btrun.btrun.getfunctions" href="#backtrader.btrun.btrun.getfunctions">getfunctions</a></code></li>
<li><code><a title="backtrader.btrun.btrun.getmodclasses" href="#backtrader.btrun.btrun.getmodclasses">getmodclasses</a></code></li>
<li><code><a title="backtrader.btrun.btrun.getmodfunctions" href="#backtrader.btrun.btrun.getmodfunctions">getmodfunctions</a></code></li>
<li><code><a title="backtrader.btrun.btrun.getobjects" href="#backtrader.btrun.btrun.getobjects">getobjects</a></code></li>
<li><code><a title="backtrader.btrun.btrun.loadmodule" href="#backtrader.btrun.btrun.loadmodule">loadmodule</a></code></li>
<li><code><a title="backtrader.btrun.btrun.loadmodule2" href="#backtrader.btrun.btrun.loadmodule2">loadmodule2</a></code></li>
<li><code><a title="backtrader.btrun.btrun.loadmodule3" href="#backtrader.btrun.btrun.loadmodule3">loadmodule3</a></code></li>
<li><code><a title="backtrader.btrun.btrun.parse_args" href="#backtrader.btrun.btrun.parse_args">parse_args</a></code></li>
<li><code><a title="backtrader.btrun.btrun.setbroker" href="#backtrader.btrun.btrun.setbroker">setbroker</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>