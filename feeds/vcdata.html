<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.feeds.vcdata API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.feeds.vcdata</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)


from datetime import datetime, timedelta, tzinfo

import backtrader as bt
from backtrader import TimeFrame, date2num, num2date
from backtrader.feed import DataBase
from backtrader.metabase import MetaParams
from backtrader.utils.py3 import (integer_types, queue, string_types,
                                  with_metaclass)

from backtrader.stores import vcstore


class MetaVCData(DataBase.__class__):
    def __init__(cls, name, bases, dct):
        &#39;&#39;&#39;Class has already been created ... register&#39;&#39;&#39;
        # Initialize the class
        super(MetaVCData, cls).__init__(name, bases, dct)

        # Register with the store
        vcstore.VCStore.DataCls = cls


class VCData(with_metaclass(MetaVCData, DataBase)):
    &#39;&#39;&#39;VisualChart Data Feed.

    Params:

      - ``qcheck`` (default: ``0.5``)
        Default timeout for waking up to let a resampler/replayer that the
        current bar can be check for due delivery

        The value is only used if a resampling/replaying filter has been
        inserted in the data

      - ``historical`` (default: ``False``)
        If no ``todate`` parameter is supplied (defined in the base class),
        this will force a historical only download if set to ``True``

        If ``todate`` is supplied the same effect is achieved

      - ``milliseconds`` (default: ``True``)
        The bars constructed by *Visual Chart* have this aspect:
        HH:MM:59.999000

        If this parameter is ``True`` a millisecond will be added to this time
        to make it look like: HH::MM + 1:00.000000

      - ``tradename`` (default: ``None``)
        Continous futures cannot be traded but are ideal for data tracking. If
        this parameter is supplied it will be the name of the current future
        which will be the trading asset. Example:

        - 001ES -&gt; ES-Mini continuous supplied as ``dataname``

        - ESU16 -&gt; ES-Mini 2016-09. If this is supplied in ``tradename`` it
          will be the trading asset.

      - ``usetimezones`` (default: ``True``)
        For most markets the time offset information provided by *Visual Chart*
        allows for datetime to be converted to market time (*backtrader* choice
        for representation)

        Some markets are special (``096``) and need special internal coverage
        and timezone support to display in the user expected market time.

        If this parameter is set to ``True`` importing ``pytz`` will be
        attempted to use timezones (default)

        Disabling it will remove timezone usage (may help if the load is
        excesive)
    &#39;&#39;&#39;
    params = (
        (&#39;qcheck&#39;, 0.5),  # timeout in seconds (float) to check for events
        (&#39;historical&#39;, False),  # usual industry value
        (&#39;millisecond&#39;, True),  # fix missing millisecond in time
        (&#39;tradename&#39;, None),  # name of the real asset to trade on
        (&#39;usetimezones&#39;, True),  # use pytz timezones if found
    )

    # Holds the calculated offset to the timestamps of the VC Server
    _TOFFSET = timedelta()

    # States for the Finite State Machine in _load
    _ST_START, _ST_FEEDING, _ST_NOTFOUND = range(3)

    # Base NULL Date for VB/Excel date compatibility
    NULLDATE = datetime(1899, 12, 30, 0, 0, 0)

    # To correct HH:MM:59.999 times
    MILLISECOND = timedelta(microseconds=1000)

    # Large ping timeout
    PING_TIMEOUT = 25.0

    # Timezones for the different exchanges
    _TZS = {
        &#39;Europe/London&#39;: (&#39;011&#39;, &#39;024&#39;, &#39;027&#39;, &#39;036&#39;, &#39;049&#39;, &#39;092&#39;, &#39;114&#39;,
                          # These are the global markets
                          &#39;033&#39;, &#39;034&#39;, &#39;035&#39;, &#39;043&#39;, &#39;054&#39;, &#39;096&#39;, &#39;300&#39;,),

        &#39;Europe/Berlin&#39;: (&#39;005&#39;, &#39;006&#39;, &#39;008&#39;, &#39;012&#39;, &#39;013&#39;, &#39;014&#39;, &#39;015&#39;,
                          &#39;017&#39;, &#39;019&#39;, &#39;025&#39;, &#39;029&#39;, &#39;030&#39;, &#39;037&#39;, &#39;038&#39;,
                          &#39;052&#39;, &#39;053&#39;, &#39;060&#39;, &#39;061&#39;, &#39;072&#39;, &#39;073&#39;, &#39;074&#39;,
                          &#39;075&#39;, &#39;080&#39;, &#39;093&#39;, &#39;094&#39;, &#39;097&#39;, &#39;111&#39;, &#39;112&#39;,
                          &#39;113&#39;,),

        &#39;Asia/Tokyo&#39;: (&#39;031&#39;,),
        &#39;Australia/Melbourne&#39;: (&#39;032&#39;,),
        &#39;America/Argentina/Buenos_Aires&#39;: (&#39;044&#39;,),
        &#39;America/Sao_Paulo&#39;: (&#39;045&#39;,),
        &#39;America/Mexico_City&#39;: (&#39;046&#39;,),
        &#39;America/Santiago&#39;: (&#39;047&#39;,),

        &#39;US/Eastern&#39;: (&#39;003&#39;, &#39;004&#39;, &#39;009&#39;, &#39;010&#39;, &#39;028&#39;, &#39;040&#39;, &#39;041&#39;, &#39;055&#39;,
                       &#39;090&#39;, &#39;095&#39;, &#39;099&#39;,),
        &#39;US/Central&#39;: (&#39;001&#39;, &#39;002&#39;, &#39;020&#39;, &#39;021&#39;, &#39;022&#39;, &#39;023&#39;, &#39;056&#39;,),
    }

    # The global assets may have a different output timezoe
    _TZOUT = {
        &#39;096.FTSE&#39;: &#39;Europe/London&#39;,
        &#39;096.FTEU3&#39;: &#39;Europe/London&#39;,
        &#39;096.MIB30&#39;: &#39;Europe/Berlin&#39;,
        &#39;096.SSMI&#39;: &#39;Europe/Berlin&#39;,
        &#39;096.HSI&#39;: &#39;Asia/Hong_Kong&#39;,
        &#39;096.BVSP&#39;: &#39;America/Sao_Paulo&#39;,
        &#39;096.MERVAL&#39;: &#39;America/Argentina/Buenos_Aires&#39;,
        &#39;096.DJI&#39;: &#39;US/Eastern&#39;,
        &#39;096.IXIC&#39;: &#39;US/Eastern&#39;,
        &#39;096.NDX&#39;: &#39;US/Eastern&#39;,
    }

    # These global markets deliver data in local time dst adjuste unlike those
    # from above and need a readjustment
    _EXTRA_TIMEOFFSET = (&#39;096&#39;,)

    _TIMEFRAME_BACKFILL = {
        TimeFrame.Ticks: timedelta(days=1),
        TimeFrame.MicroSeconds: timedelta(days=1),
        TimeFrame.Seconds: timedelta(days=1),
        TimeFrame.Minutes: timedelta(days=2),
        TimeFrame.Days: timedelta(days=365),
        TimeFrame.Weeks: timedelta(days=365*2),
        TimeFrame.Months: timedelta(days=365*5),
        TimeFrame.Years: timedelta(days=365*20),
    }

    def _timeoffset(self):
        &#39;&#39;&#39;Returns the calculated time offset local equipment -&gt; data server&#39;&#39;&#39;
        return self._TOFFSET

    def _gettzinput(self):
        &#39;&#39;&#39;Returns the timezone to consider for the input data&#39;&#39;&#39;
        return self._gettz(tzin=True)

    def _gettz(self, tzin=False):
        &#39;&#39;&#39;Returns the default output timezone for the data

        This defaults to be the timezone in which the market is traded
        &#39;&#39;&#39;
        # If no object has been provided by the user and a timezone can be
        # found via contractdtails, then try to get it from pytz, which may or
        # may not be available.

        # The timezone specifications returned by TWS seem to be abbreviations
        # understood by pytz, but the full list which TWS may return is not
        # documented and one of the abbreviations may fail
        ptz = self.p.tz
        tzstr = isinstance(ptz, string_types)
        if ptz is not None and not tzstr:
            return bt.utils.date.Localizer(ptz)

        if self._state == self._ST_NOTFOUND:
            return None  # nothing else can be done

        if not self.p.usetimezones:
            return None

        try:
            import pytz  # keep the import very local
        except ImportError:
            return None  # nothing can be done

        # dataname 010ABCXXXXX -&gt; ABC (3, 4 and 5) is market code
        if tzstr:
            tzs = ptz
        else:
            tzs = None

            if not tzin:
                if self.p.dataname in self._TZOUT:
                    tzs = self._TZOUT[self.p.dataname]

            if tzs is None:
                for mktz, mktcodes in self._TZS.items():
                    if self._mktcode in mktcodes:
                        tzs = mktz
                        break

            if tzs is None:
                return None

            if isinstance(tzs, tzinfo):
                return bt.utils.date.Localizer(tzs)

        if tzs:
            try:
                tz = pytz.timezone(tzs)
            except pytz.UnknownTimeZoneError:
                return None  # nothing can be done
        else:
            return None

        # contractdetails there, import ok, timezone found, return it
        return tz

    def islive(self):
        &#39;&#39;&#39;Returns ``True`` to notify ``Cerebro`` that preloading and runonce
        should be deactivated&#39;&#39;&#39;
        return True

    def __init__(self, **kwargs):
        self.store = vcstore.VCStore(**kwargs)

        # Correct a copy past directly from VisualChart
        dataname = self.p.dataname
        if dataname[3].isspace():
            dataname = dataname[0:2] + dataname[4:]
            self.p.dataname = dataname

        self._dataname = &#39;010&#39; + self.p.dataname
        self._mktcode = self.p.dataname[0:3]

        self._tradename = tradename = self.p.tradename or self._dataname
        # Correct a copy past directly from VisualChart
        if tradename[3].isspace():
            tradename = tradename[0:2] + tradename[4:]
            self._tradename = tradename

    def setenvironment(self, env):
        &#39;&#39;&#39;Receives an environment (cerebro) and passes it over to the store it
        belongs to&#39;&#39;&#39;
        super(VCData, self).setenvironment(env)
        env.addstore(self.store)

    def start(self):
        &#39;&#39;&#39;Starts the VC connecction and gets the real contract and
        contractdetails if it exists&#39;&#39;&#39;
        super(VCData, self).start()

        self._state = self._ST_START  # mini finite state machine

        self._newticks = True  # control processing of initial ticks

        self._pingtmout = self.PING_TIMEOUT  # Initial timeout for ping

        self.idx = 1  # counter for the dataserie (vb is based at 1)
        self.q = None  # where bars are received

        # market time offsets
        self._mktoffset = None
        self._mktoff1 = None
        self._mktoffdiff = None

        if not self.store.connected():
            # Not connected -&gt; go away
            self.put_notification(self.DISCONNECTED)
            self._state = self._ST_NOTFOUND
            return

        self.put_notification(self.CONNECTED)
        # get real contract details with real conId (contractId)
        self.qrt = queue.Queue()  # to await a ping
        self.store._rtdata(self, self._dataname)
        symfound = self.qrt.get()
        if not symfound:
            # Kill any further action and signal it
            self.put_notification(self.NOTSUBSCRIBED)
            self.put_notification(self.DISCONNECTED)
            self._state = self._ST_NOTFOUND
            return

        if self.replaying:
            # In this case don&#39;t request the final
            # timeframe from vc, but the original that has to be replayed
            self._tf, self._comp = self.p.timeframe, self.p.compression
        else:
            # Else (even if resampling) pass the final timeframe which may
            # been modified by a resampling filter
            self._tf, self._comp = self._timeframe, self._compression,

        self._ticking = self.store._ticking(self._tf)
        self._syminfo = syminfo = self.store._symboldata(self._dataname)

        # For most markets:
        # mktoffset == mktoff1 and substracting this value from reported times
        # is enough to report the &#34;market time&#34;. Visual Chart changes this from
        # a value X to 0 if the appropriate setting in the GUI is changed to
        # change display of time from local &lt;-&gt; market
        #
        # But some markets (at least 096XXX) that theoretically live in
        # Europe/London seem to be displaced 1 hour to the west and an extra
        # hour is needed.
        # These markets do also need &#34;usetimezoned&#34; True to actually display
        # the market time, because this is done internally using the
        # definitions in TZOUTS

        # Record and calculate market offsets
        self._mktoffset = timedelta(seconds=syminfo.TimeOffset)
        # Add millisecond to pusth HH:MM:59.999 -&gt; 00.000 unless ticks
        if self.p.millisecond and not self._ticking:
            self._mktoffset -= self.MILLISECOND

        self._mktoff1 = self._mktoffset
        if self._mktcode in self._EXTRA_TIMEOFFSET:
            # These codes live theoretically in
            # (UTC+00:00) Dublin, Edinburgh, Lisbon, London which is
            # &#39;Europe/London&#39;
            # But all experiments show the times to be displaced 1 hour to
            # the west and hence the extra 3600 seconds
            self._mktoffset -= timedelta(seconds=3600)

        self._mktoffdiff = self._mktoffset - self._mktoff1

        if self._state == self._ST_START:
            self.put_notification(self.DELAYED)

            # Now request the data and get a comms queue for it
            self.q = self.store._directdata(
                self,
                self._dataname,
                self._tf, self._comp,
                self.p.fromdate, self.p.todate,
                self.p.historical)

            self._state = self._ST_FEEDING

    def stop(self):
        &#39;&#39;&#39;Stops and tells the store to stop&#39;&#39;&#39;
        super(VCData, self).stop()
        if self.q:
            self.store._canceldirectdata(self.q)

    def _setserie(self, serie):
        # Accepts a serie (COM Object) to use in ping events
        self._serie = serie

    def haslivedata(self):
        return self._laststatus == self.LIVE and self.q

    def _load(self):
        if self._state == self._ST_NOTFOUND:
            return False  # nothing can be done

        while True:
            try:
                # tmout &lt;&gt; 0 only if resampling/replaying, else no waking up
                tmout = self._qcheck * bool(self.resampling)
                msg = self.q.get(timeout=tmout)
            except queue.Empty:
                return None

            if msg is None:
                return False  # end of stream

            if msg == self.store._RT_SHUTDOWN:
                self.put_notification(self.DISCONNECTED)
                return False  # VC has exited

            if msg == self.store._RT_DISCONNECTED:
                self.put_notification(self.CONNBROKEN)
                continue

            if msg == self.store._RT_CONNECTED:
                self.put_notification(self.CONNECTED)
                self.put_notification(self.DELAYED)
                continue

            if msg == self.store._RT_LIVE:
                if self._laststatus != self.LIVE:
                    self.put_notification(self.LIVE)
                continue

            if msg == self.store._RT_DELAYED:
                if self._laststatus != self.DELAYED:
                    self.put_notification(self.DELAYED)
                continue

            if isinstance(msg, integer_types):
                self.put_notification(self.UNKNOWN, msg)
                continue

            # it must be a bar
            bar = msg

            # Put the tick into the bar
            self.lines.open[0] = bar.Open
            self.lines.high[0] = bar.High
            self.lines.low[0] = bar.Low
            self.lines.close[0] = bar.Close
            self.lines.volume[0] = bar.Volume
            self.lines.openinterest[0] = bar.OpenInterest

            # Convert time to &#34;market&#34; time (096 exception)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffset
            self.lines.datetime[0] = date2num(dt)

            return True

    #
    # DS Events
    #
    def _getpingtmout(self):
        &#39;&#39;&#39;Returns the actual ping timeout for PumpEvents to wake up and call
        ping, which will check if the not yet delivered bar can be
        delivered. The bar may be stalled because vc awaits a new tick and
        during low negotiation hour this can take several seconds after the
        actual expected delivery time&#39;&#39;&#39;
        if self._ticking:
            return -1  # no timeout

        return self._pingtmout

    def OnNewDataSerieBar(self, DataSerie, forcepush=False):
        # Processes the COM Event (also called directly when 1st creating the
        # data serie
        ssize = DataSerie.Size

        if ssize - self.idx &gt; 1:
            # More than 1 bar on-board -&gt; delay in place
            if self._laststatus != self.DELAYED:
                self.q.put(self.store._RT_DELAYED)

        # return everything if original tf is ticks or force pushing
        ssize += forcepush or self._ticking
        for idx in range(self.idx, ssize):
            bar = DataSerie.GetBarValues(idx)
            self.q.put(bar)

        if not forcepush and not self._ticking and ssize:
            # A bar has been left in place
            dtnow = datetime.now() - self._TOFFSET  # adjust local time

            bar = DataSerie.GetBarValues(ssize)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
            if dtnow &lt; dt:
                # A bar is there, not deliverable yet - LIVE
                if self._laststatus != self.LIVE:
                    self.q.put(self.store._RT_LIVE)

                # Adjust ping timeout to the bar boundary (plus mini leeway)
                self._pingtmout = (dt - dtnow).total_seconds() + 0.5

            else:
                self._pingtmout = self.PING_TIMEOUT  # no bar left, long pause
                self.q.put(bar)  # push bar and update index
                ssize += 1  # pushed last one out

        # Write down the last processed bar
        self.idx = max(1, ssize)

    def ping(self):
        ssize = self._serie.Size

        if self.idx &gt; ssize:
            return  # no bar available

        if self._laststatus == self.CONNBROKEN:
            self._pingtmout = self.PING_TIMEOUT
            return  # do not push during disconnection

        dtnow = datetime.now() - self._TOFFSET
        # CHECK: there should be a maximum of 1 bar when pinging
        # In any case the algorithm doesn&#39;t hurt
        for idx in range(self.idx, ssize + 1):  # reach ssize
            bar = self._serie.GetBarValues(self.idx)
            # dt = (self.NULLDATE + timedelta(days=bar.Date) + self._mktoff1)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
            if dtnow &lt; dt:
                self._pingtmout = (dt - dtnow).total_seconds() + 0.5
                break  # cannot deliver anything

            # Adjust ping timeout to the bar boundary (plus mini leeway)
            self._pingtmout = self.PING_TIMEOUT  # no bar, nothing to check
            self.q.put(bar)  # push bar and update index
            self.idx += 1

    #
    # RTEvents
    #
    # Can be used on a per data basis to check the connection status
    if False:
        def OnInternalEvent(self, p1, p2, p3):
            if p1 != 1:  # Apparently &#34;Connection Event&#34;
                return

            if p2 == self.lastconn:
                return  # do not notify twice

            self.lastconn = p2  # keep new notification code

            # p2 should be 0 (disconn), 1 (conn)
            self.store._vcrt_connection(self.store._RT_BASEMSG - p2)

    def OnNewTicks(self, ArrayTicks):
        # Process the COM Event for New Ticks. This is only used temporarily
        # for 2 purposes
        #
        # 1. If tick.Field == Field_Description is returned, it can be checked
        # if the requested symbol has been found or not (tick.Date == 0 -&gt; not
        # found). tick.Text has &#39;Not Found&#39;, but this is more likely to change
        # Once Field_Description has been seen, the 2nd stage takes place
        #
        # 2. When a tick.Field == Field_Time is seen and tick.TickIndex == 0,
        # the 1st tick of a second is seen and the tick.Date value can be used
        # to calculate a time offset to the feed server. This is later used to
        # check if a bar is due delivery or not
        #
        # After this the reception of ticks is cancelled

        aticks = ArrayTicks[0]
        # self.debug_ticks(aticks)
        ticks = dict()
        for tick in aticks:
            ticks[tick.Field] = tick

        if self.store.vcrtmod.Field_Description in ticks:
            if self._newticks:
                self._newticks = False
                hasdate = bool(ticks.get(self.store.vcrtmod.Field_Date, False))
                self.qrt.put(hasdate)
                return

        else:
            try:
                tick = ticks[self.store.vcrtmod.Field_Time]
            except KeyError:
                return

            if tick.TickIndex == 0 and self._mktoff1 is not None:
                # Adjust the tick time using the mktoffset (with the 096 excep)
                dttick = (self.NULLDATE + timedelta(days=tick.Date) +
                          self._mktoff1)

                self._TOFFSET = datetime.now() - dttick
                if self._mktcode in self._EXTRA_TIMEOFFSET:
                    # These codes live theoretically in (UTC+00:00) Dublin,
                    # Edinburgh, Lisbon, London which is &#39;Europe/London&#39;
                    # But all experiments show the times to be displaced 1
                    # hour to the west and hence the extra 3600 seconds
                    self._TOFFSET -= timedelta(seconds=3600)

                # Cancel ticks
                self._vcrt.CancelSymbolFeed(self._dataname, False)

    def debug_ticks(self, ticks):
        print(&#39;*&#39; * 50, &#39;DEBUG OnNewTicks&#39;)
        for tick in ticks:
            print(&#39;-&#39; * 40)
            print(&#39;tick.SymbolCode&#39;, tick.SymbolCode.encode(&#39;ascii&#39;, &#39;ignore&#39;))
            fname = self.store.vcrtfields.get(tick.Field, tick.Field)
            print(&#39;  tick.Field   : {} ({})&#39;.format(fname, tick.Field))
            print(&#39;  tick.FieldEx :&#39;, tick.FieldEx)
            tdate = tick.Date
            if tdate:
                tdate = self.NULLDATE + timedelta(days=tick.Date)
            print(&#39;  tick.Date    :&#39;, tdate)

            print(&#39;  tick.Index   :&#39;, tick.TickIndex)
            print(&#39;  tick.Value   :&#39;, tick.Value)
            print(&#39;  tick.Text    :&#39;, tick.Text.encode(&#39;ascii&#39;, &#39;ignore&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.feeds.vcdata.MetaVCData"><code class="flex name class">
<span>class <span class="ident">MetaVCData</span></span>
<span>(</span><span>name, bases, dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Dirty job manager for a LineSeries</p>
<ul>
<li>
<p>During <strong>new</strong> (class creation), it reads "lines", "plotinfo",
"plotlines" class variable definitions and turns them into
Classes of type Lines or AutoClassInfo (plotinfo/plotlines)</p>
</li>
<li>
<p>During "new" (instance creation) the lines/plotinfo/plotlines
classes are substituted in the instance with instances of the
aforementioned classes and aliases are added for the "lines" held
in the "lines" instance</p>
<p>Additionally and for remaining kwargs, these are matched against
args in plotinfo and if existent are set there and removed from kwargs</p>
<p>Remember that this Metaclass has a MetaParams (from metabase)
as root class and therefore "params" defined for the class have been
removed from kwargs at an earlier state</p>
</li>
</ul>
<p>Class has already been created &hellip; register</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaVCData(DataBase.__class__):
    def __init__(cls, name, bases, dct):
        &#39;&#39;&#39;Class has already been created ... register&#39;&#39;&#39;
        # Initialize the class
        super(MetaVCData, cls).__init__(name, bases, dct)

        # Register with the store
        vcstore.VCStore.DataCls = cls</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.feed.MetaAbstractDataBase" href="../feed.html#backtrader.feed.MetaAbstractDataBase">MetaAbstractDataBase</a></li>
<li><a title="backtrader.lineseries.MetaLineSeries" href="../lineseries.html#backtrader.lineseries.MetaLineSeries">MetaLineSeries</a></li>
<li><a title="backtrader.lineroot.MetaLineRoot" href="../lineroot.html#backtrader.lineroot.MetaLineRoot">MetaLineRoot</a></li>
<li><a title="backtrader.metabase.MetaParams" href="../metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="../metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.feed.MetaAbstractDataBase" href="../feed.html#backtrader.feed.MetaAbstractDataBase">MetaAbstractDataBase</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.feed.MetaAbstractDataBase.donew" href="../lineseries.html#backtrader.lineseries.MetaLineSeries.donew">donew</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.feeds.vcdata.VCData"><code class="flex name class">
<span>class <span class="ident">VCData</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>VisualChart Data Feed.</p>
<h2 id="params">Params</h2>
<ul>
<li><code>qcheck</code> (default: <code>0.5</code>)
Default timeout for waking up to let a resampler/replayer that the
current bar can be check for due delivery</li>
</ul>
<p>The value is only used if a resampling/replaying filter has been
inserted in the data</p>
<ul>
<li><code>historical</code> (default: <code>False</code>)
If no <code>todate</code> parameter is supplied (defined in the base class),
this will force a historical only download if set to <code>True</code></li>
</ul>
<p>If <code>todate</code> is supplied the same effect is achieved</p>
<ul>
<li><code>milliseconds</code> (default: <code>True</code>)
The bars constructed by <em>Visual Chart</em> have this aspect:
HH:MM:59.999000</li>
</ul>
<p>If this parameter is <code>True</code> a millisecond will be added to this time
to make it look like: HH::MM + 1:00.000000</p>
<ul>
<li>
<p><code>tradename</code> (default: <code>None</code>)
Continous futures cannot be traded but are ideal for data tracking. If
this parameter is supplied it will be the name of the current future
which will be the trading asset. Example:</p>
</li>
<li>
<p>001ES -&gt; ES-Mini continuous supplied as <code>dataname</code></p>
</li>
<li>
<p>ESU16 -&gt; ES-Mini 2016-09. If this is supplied in <code>tradename</code> it
will be the trading asset.</p>
</li>
<li>
<p><code>usetimezones</code> (default: <code>True</code>)
For most markets the time offset information provided by <em>Visual Chart</em>
allows for datetime to be converted to market time (<em>backtrader</em> choice
for representation)</p>
</li>
</ul>
<p>Some markets are special (<code>096</code>) and need special internal coverage
and timezone support to display in the user expected market time.</p>
<p>If this parameter is set to <code>True</code> importing <code>pytz</code> will be
attempted to use timezones (default)</p>
<p>Disabling it will remove timezone usage (may help if the load is
excesive)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VCData(with_metaclass(MetaVCData, DataBase)):
    &#39;&#39;&#39;VisualChart Data Feed.

    Params:

      - ``qcheck`` (default: ``0.5``)
        Default timeout for waking up to let a resampler/replayer that the
        current bar can be check for due delivery

        The value is only used if a resampling/replaying filter has been
        inserted in the data

      - ``historical`` (default: ``False``)
        If no ``todate`` parameter is supplied (defined in the base class),
        this will force a historical only download if set to ``True``

        If ``todate`` is supplied the same effect is achieved

      - ``milliseconds`` (default: ``True``)
        The bars constructed by *Visual Chart* have this aspect:
        HH:MM:59.999000

        If this parameter is ``True`` a millisecond will be added to this time
        to make it look like: HH::MM + 1:00.000000

      - ``tradename`` (default: ``None``)
        Continous futures cannot be traded but are ideal for data tracking. If
        this parameter is supplied it will be the name of the current future
        which will be the trading asset. Example:

        - 001ES -&gt; ES-Mini continuous supplied as ``dataname``

        - ESU16 -&gt; ES-Mini 2016-09. If this is supplied in ``tradename`` it
          will be the trading asset.

      - ``usetimezones`` (default: ``True``)
        For most markets the time offset information provided by *Visual Chart*
        allows for datetime to be converted to market time (*backtrader* choice
        for representation)

        Some markets are special (``096``) and need special internal coverage
        and timezone support to display in the user expected market time.

        If this parameter is set to ``True`` importing ``pytz`` will be
        attempted to use timezones (default)

        Disabling it will remove timezone usage (may help if the load is
        excesive)
    &#39;&#39;&#39;
    params = (
        (&#39;qcheck&#39;, 0.5),  # timeout in seconds (float) to check for events
        (&#39;historical&#39;, False),  # usual industry value
        (&#39;millisecond&#39;, True),  # fix missing millisecond in time
        (&#39;tradename&#39;, None),  # name of the real asset to trade on
        (&#39;usetimezones&#39;, True),  # use pytz timezones if found
    )

    # Holds the calculated offset to the timestamps of the VC Server
    _TOFFSET = timedelta()

    # States for the Finite State Machine in _load
    _ST_START, _ST_FEEDING, _ST_NOTFOUND = range(3)

    # Base NULL Date for VB/Excel date compatibility
    NULLDATE = datetime(1899, 12, 30, 0, 0, 0)

    # To correct HH:MM:59.999 times
    MILLISECOND = timedelta(microseconds=1000)

    # Large ping timeout
    PING_TIMEOUT = 25.0

    # Timezones for the different exchanges
    _TZS = {
        &#39;Europe/London&#39;: (&#39;011&#39;, &#39;024&#39;, &#39;027&#39;, &#39;036&#39;, &#39;049&#39;, &#39;092&#39;, &#39;114&#39;,
                          # These are the global markets
                          &#39;033&#39;, &#39;034&#39;, &#39;035&#39;, &#39;043&#39;, &#39;054&#39;, &#39;096&#39;, &#39;300&#39;,),

        &#39;Europe/Berlin&#39;: (&#39;005&#39;, &#39;006&#39;, &#39;008&#39;, &#39;012&#39;, &#39;013&#39;, &#39;014&#39;, &#39;015&#39;,
                          &#39;017&#39;, &#39;019&#39;, &#39;025&#39;, &#39;029&#39;, &#39;030&#39;, &#39;037&#39;, &#39;038&#39;,
                          &#39;052&#39;, &#39;053&#39;, &#39;060&#39;, &#39;061&#39;, &#39;072&#39;, &#39;073&#39;, &#39;074&#39;,
                          &#39;075&#39;, &#39;080&#39;, &#39;093&#39;, &#39;094&#39;, &#39;097&#39;, &#39;111&#39;, &#39;112&#39;,
                          &#39;113&#39;,),

        &#39;Asia/Tokyo&#39;: (&#39;031&#39;,),
        &#39;Australia/Melbourne&#39;: (&#39;032&#39;,),
        &#39;America/Argentina/Buenos_Aires&#39;: (&#39;044&#39;,),
        &#39;America/Sao_Paulo&#39;: (&#39;045&#39;,),
        &#39;America/Mexico_City&#39;: (&#39;046&#39;,),
        &#39;America/Santiago&#39;: (&#39;047&#39;,),

        &#39;US/Eastern&#39;: (&#39;003&#39;, &#39;004&#39;, &#39;009&#39;, &#39;010&#39;, &#39;028&#39;, &#39;040&#39;, &#39;041&#39;, &#39;055&#39;,
                       &#39;090&#39;, &#39;095&#39;, &#39;099&#39;,),
        &#39;US/Central&#39;: (&#39;001&#39;, &#39;002&#39;, &#39;020&#39;, &#39;021&#39;, &#39;022&#39;, &#39;023&#39;, &#39;056&#39;,),
    }

    # The global assets may have a different output timezoe
    _TZOUT = {
        &#39;096.FTSE&#39;: &#39;Europe/London&#39;,
        &#39;096.FTEU3&#39;: &#39;Europe/London&#39;,
        &#39;096.MIB30&#39;: &#39;Europe/Berlin&#39;,
        &#39;096.SSMI&#39;: &#39;Europe/Berlin&#39;,
        &#39;096.HSI&#39;: &#39;Asia/Hong_Kong&#39;,
        &#39;096.BVSP&#39;: &#39;America/Sao_Paulo&#39;,
        &#39;096.MERVAL&#39;: &#39;America/Argentina/Buenos_Aires&#39;,
        &#39;096.DJI&#39;: &#39;US/Eastern&#39;,
        &#39;096.IXIC&#39;: &#39;US/Eastern&#39;,
        &#39;096.NDX&#39;: &#39;US/Eastern&#39;,
    }

    # These global markets deliver data in local time dst adjuste unlike those
    # from above and need a readjustment
    _EXTRA_TIMEOFFSET = (&#39;096&#39;,)

    _TIMEFRAME_BACKFILL = {
        TimeFrame.Ticks: timedelta(days=1),
        TimeFrame.MicroSeconds: timedelta(days=1),
        TimeFrame.Seconds: timedelta(days=1),
        TimeFrame.Minutes: timedelta(days=2),
        TimeFrame.Days: timedelta(days=365),
        TimeFrame.Weeks: timedelta(days=365*2),
        TimeFrame.Months: timedelta(days=365*5),
        TimeFrame.Years: timedelta(days=365*20),
    }

    def _timeoffset(self):
        &#39;&#39;&#39;Returns the calculated time offset local equipment -&gt; data server&#39;&#39;&#39;
        return self._TOFFSET

    def _gettzinput(self):
        &#39;&#39;&#39;Returns the timezone to consider for the input data&#39;&#39;&#39;
        return self._gettz(tzin=True)

    def _gettz(self, tzin=False):
        &#39;&#39;&#39;Returns the default output timezone for the data

        This defaults to be the timezone in which the market is traded
        &#39;&#39;&#39;
        # If no object has been provided by the user and a timezone can be
        # found via contractdtails, then try to get it from pytz, which may or
        # may not be available.

        # The timezone specifications returned by TWS seem to be abbreviations
        # understood by pytz, but the full list which TWS may return is not
        # documented and one of the abbreviations may fail
        ptz = self.p.tz
        tzstr = isinstance(ptz, string_types)
        if ptz is not None and not tzstr:
            return bt.utils.date.Localizer(ptz)

        if self._state == self._ST_NOTFOUND:
            return None  # nothing else can be done

        if not self.p.usetimezones:
            return None

        try:
            import pytz  # keep the import very local
        except ImportError:
            return None  # nothing can be done

        # dataname 010ABCXXXXX -&gt; ABC (3, 4 and 5) is market code
        if tzstr:
            tzs = ptz
        else:
            tzs = None

            if not tzin:
                if self.p.dataname in self._TZOUT:
                    tzs = self._TZOUT[self.p.dataname]

            if tzs is None:
                for mktz, mktcodes in self._TZS.items():
                    if self._mktcode in mktcodes:
                        tzs = mktz
                        break

            if tzs is None:
                return None

            if isinstance(tzs, tzinfo):
                return bt.utils.date.Localizer(tzs)

        if tzs:
            try:
                tz = pytz.timezone(tzs)
            except pytz.UnknownTimeZoneError:
                return None  # nothing can be done
        else:
            return None

        # contractdetails there, import ok, timezone found, return it
        return tz

    def islive(self):
        &#39;&#39;&#39;Returns ``True`` to notify ``Cerebro`` that preloading and runonce
        should be deactivated&#39;&#39;&#39;
        return True

    def __init__(self, **kwargs):
        self.store = vcstore.VCStore(**kwargs)

        # Correct a copy past directly from VisualChart
        dataname = self.p.dataname
        if dataname[3].isspace():
            dataname = dataname[0:2] + dataname[4:]
            self.p.dataname = dataname

        self._dataname = &#39;010&#39; + self.p.dataname
        self._mktcode = self.p.dataname[0:3]

        self._tradename = tradename = self.p.tradename or self._dataname
        # Correct a copy past directly from VisualChart
        if tradename[3].isspace():
            tradename = tradename[0:2] + tradename[4:]
            self._tradename = tradename

    def setenvironment(self, env):
        &#39;&#39;&#39;Receives an environment (cerebro) and passes it over to the store it
        belongs to&#39;&#39;&#39;
        super(VCData, self).setenvironment(env)
        env.addstore(self.store)

    def start(self):
        &#39;&#39;&#39;Starts the VC connecction and gets the real contract and
        contractdetails if it exists&#39;&#39;&#39;
        super(VCData, self).start()

        self._state = self._ST_START  # mini finite state machine

        self._newticks = True  # control processing of initial ticks

        self._pingtmout = self.PING_TIMEOUT  # Initial timeout for ping

        self.idx = 1  # counter for the dataserie (vb is based at 1)
        self.q = None  # where bars are received

        # market time offsets
        self._mktoffset = None
        self._mktoff1 = None
        self._mktoffdiff = None

        if not self.store.connected():
            # Not connected -&gt; go away
            self.put_notification(self.DISCONNECTED)
            self._state = self._ST_NOTFOUND
            return

        self.put_notification(self.CONNECTED)
        # get real contract details with real conId (contractId)
        self.qrt = queue.Queue()  # to await a ping
        self.store._rtdata(self, self._dataname)
        symfound = self.qrt.get()
        if not symfound:
            # Kill any further action and signal it
            self.put_notification(self.NOTSUBSCRIBED)
            self.put_notification(self.DISCONNECTED)
            self._state = self._ST_NOTFOUND
            return

        if self.replaying:
            # In this case don&#39;t request the final
            # timeframe from vc, but the original that has to be replayed
            self._tf, self._comp = self.p.timeframe, self.p.compression
        else:
            # Else (even if resampling) pass the final timeframe which may
            # been modified by a resampling filter
            self._tf, self._comp = self._timeframe, self._compression,

        self._ticking = self.store._ticking(self._tf)
        self._syminfo = syminfo = self.store._symboldata(self._dataname)

        # For most markets:
        # mktoffset == mktoff1 and substracting this value from reported times
        # is enough to report the &#34;market time&#34;. Visual Chart changes this from
        # a value X to 0 if the appropriate setting in the GUI is changed to
        # change display of time from local &lt;-&gt; market
        #
        # But some markets (at least 096XXX) that theoretically live in
        # Europe/London seem to be displaced 1 hour to the west and an extra
        # hour is needed.
        # These markets do also need &#34;usetimezoned&#34; True to actually display
        # the market time, because this is done internally using the
        # definitions in TZOUTS

        # Record and calculate market offsets
        self._mktoffset = timedelta(seconds=syminfo.TimeOffset)
        # Add millisecond to pusth HH:MM:59.999 -&gt; 00.000 unless ticks
        if self.p.millisecond and not self._ticking:
            self._mktoffset -= self.MILLISECOND

        self._mktoff1 = self._mktoffset
        if self._mktcode in self._EXTRA_TIMEOFFSET:
            # These codes live theoretically in
            # (UTC+00:00) Dublin, Edinburgh, Lisbon, London which is
            # &#39;Europe/London&#39;
            # But all experiments show the times to be displaced 1 hour to
            # the west and hence the extra 3600 seconds
            self._mktoffset -= timedelta(seconds=3600)

        self._mktoffdiff = self._mktoffset - self._mktoff1

        if self._state == self._ST_START:
            self.put_notification(self.DELAYED)

            # Now request the data and get a comms queue for it
            self.q = self.store._directdata(
                self,
                self._dataname,
                self._tf, self._comp,
                self.p.fromdate, self.p.todate,
                self.p.historical)

            self._state = self._ST_FEEDING

    def stop(self):
        &#39;&#39;&#39;Stops and tells the store to stop&#39;&#39;&#39;
        super(VCData, self).stop()
        if self.q:
            self.store._canceldirectdata(self.q)

    def _setserie(self, serie):
        # Accepts a serie (COM Object) to use in ping events
        self._serie = serie

    def haslivedata(self):
        return self._laststatus == self.LIVE and self.q

    def _load(self):
        if self._state == self._ST_NOTFOUND:
            return False  # nothing can be done

        while True:
            try:
                # tmout &lt;&gt; 0 only if resampling/replaying, else no waking up
                tmout = self._qcheck * bool(self.resampling)
                msg = self.q.get(timeout=tmout)
            except queue.Empty:
                return None

            if msg is None:
                return False  # end of stream

            if msg == self.store._RT_SHUTDOWN:
                self.put_notification(self.DISCONNECTED)
                return False  # VC has exited

            if msg == self.store._RT_DISCONNECTED:
                self.put_notification(self.CONNBROKEN)
                continue

            if msg == self.store._RT_CONNECTED:
                self.put_notification(self.CONNECTED)
                self.put_notification(self.DELAYED)
                continue

            if msg == self.store._RT_LIVE:
                if self._laststatus != self.LIVE:
                    self.put_notification(self.LIVE)
                continue

            if msg == self.store._RT_DELAYED:
                if self._laststatus != self.DELAYED:
                    self.put_notification(self.DELAYED)
                continue

            if isinstance(msg, integer_types):
                self.put_notification(self.UNKNOWN, msg)
                continue

            # it must be a bar
            bar = msg

            # Put the tick into the bar
            self.lines.open[0] = bar.Open
            self.lines.high[0] = bar.High
            self.lines.low[0] = bar.Low
            self.lines.close[0] = bar.Close
            self.lines.volume[0] = bar.Volume
            self.lines.openinterest[0] = bar.OpenInterest

            # Convert time to &#34;market&#34; time (096 exception)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffset
            self.lines.datetime[0] = date2num(dt)

            return True

    #
    # DS Events
    #
    def _getpingtmout(self):
        &#39;&#39;&#39;Returns the actual ping timeout for PumpEvents to wake up and call
        ping, which will check if the not yet delivered bar can be
        delivered. The bar may be stalled because vc awaits a new tick and
        during low negotiation hour this can take several seconds after the
        actual expected delivery time&#39;&#39;&#39;
        if self._ticking:
            return -1  # no timeout

        return self._pingtmout

    def OnNewDataSerieBar(self, DataSerie, forcepush=False):
        # Processes the COM Event (also called directly when 1st creating the
        # data serie
        ssize = DataSerie.Size

        if ssize - self.idx &gt; 1:
            # More than 1 bar on-board -&gt; delay in place
            if self._laststatus != self.DELAYED:
                self.q.put(self.store._RT_DELAYED)

        # return everything if original tf is ticks or force pushing
        ssize += forcepush or self._ticking
        for idx in range(self.idx, ssize):
            bar = DataSerie.GetBarValues(idx)
            self.q.put(bar)

        if not forcepush and not self._ticking and ssize:
            # A bar has been left in place
            dtnow = datetime.now() - self._TOFFSET  # adjust local time

            bar = DataSerie.GetBarValues(ssize)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
            if dtnow &lt; dt:
                # A bar is there, not deliverable yet - LIVE
                if self._laststatus != self.LIVE:
                    self.q.put(self.store._RT_LIVE)

                # Adjust ping timeout to the bar boundary (plus mini leeway)
                self._pingtmout = (dt - dtnow).total_seconds() + 0.5

            else:
                self._pingtmout = self.PING_TIMEOUT  # no bar left, long pause
                self.q.put(bar)  # push bar and update index
                ssize += 1  # pushed last one out

        # Write down the last processed bar
        self.idx = max(1, ssize)

    def ping(self):
        ssize = self._serie.Size

        if self.idx &gt; ssize:
            return  # no bar available

        if self._laststatus == self.CONNBROKEN:
            self._pingtmout = self.PING_TIMEOUT
            return  # do not push during disconnection

        dtnow = datetime.now() - self._TOFFSET
        # CHECK: there should be a maximum of 1 bar when pinging
        # In any case the algorithm doesn&#39;t hurt
        for idx in range(self.idx, ssize + 1):  # reach ssize
            bar = self._serie.GetBarValues(self.idx)
            # dt = (self.NULLDATE + timedelta(days=bar.Date) + self._mktoff1)
            dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
            if dtnow &lt; dt:
                self._pingtmout = (dt - dtnow).total_seconds() + 0.5
                break  # cannot deliver anything

            # Adjust ping timeout to the bar boundary (plus mini leeway)
            self._pingtmout = self.PING_TIMEOUT  # no bar, nothing to check
            self.q.put(bar)  # push bar and update index
            self.idx += 1

    #
    # RTEvents
    #
    # Can be used on a per data basis to check the connection status
    if False:
        def OnInternalEvent(self, p1, p2, p3):
            if p1 != 1:  # Apparently &#34;Connection Event&#34;
                return

            if p2 == self.lastconn:
                return  # do not notify twice

            self.lastconn = p2  # keep new notification code

            # p2 should be 0 (disconn), 1 (conn)
            self.store._vcrt_connection(self.store._RT_BASEMSG - p2)

    def OnNewTicks(self, ArrayTicks):
        # Process the COM Event for New Ticks. This is only used temporarily
        # for 2 purposes
        #
        # 1. If tick.Field == Field_Description is returned, it can be checked
        # if the requested symbol has been found or not (tick.Date == 0 -&gt; not
        # found). tick.Text has &#39;Not Found&#39;, but this is more likely to change
        # Once Field_Description has been seen, the 2nd stage takes place
        #
        # 2. When a tick.Field == Field_Time is seen and tick.TickIndex == 0,
        # the 1st tick of a second is seen and the tick.Date value can be used
        # to calculate a time offset to the feed server. This is later used to
        # check if a bar is due delivery or not
        #
        # After this the reception of ticks is cancelled

        aticks = ArrayTicks[0]
        # self.debug_ticks(aticks)
        ticks = dict()
        for tick in aticks:
            ticks[tick.Field] = tick

        if self.store.vcrtmod.Field_Description in ticks:
            if self._newticks:
                self._newticks = False
                hasdate = bool(ticks.get(self.store.vcrtmod.Field_Date, False))
                self.qrt.put(hasdate)
                return

        else:
            try:
                tick = ticks[self.store.vcrtmod.Field_Time]
            except KeyError:
                return

            if tick.TickIndex == 0 and self._mktoff1 is not None:
                # Adjust the tick time using the mktoffset (with the 096 excep)
                dttick = (self.NULLDATE + timedelta(days=tick.Date) +
                          self._mktoff1)

                self._TOFFSET = datetime.now() - dttick
                if self._mktcode in self._EXTRA_TIMEOFFSET:
                    # These codes live theoretically in (UTC+00:00) Dublin,
                    # Edinburgh, Lisbon, London which is &#39;Europe/London&#39;
                    # But all experiments show the times to be displaced 1
                    # hour to the west and hence the extra 3600 seconds
                    self._TOFFSET -= timedelta(seconds=3600)

                # Cancel ticks
                self._vcrt.CancelSymbolFeed(self._dataname, False)

    def debug_ticks(self, ticks):
        print(&#39;*&#39; * 50, &#39;DEBUG OnNewTicks&#39;)
        for tick in ticks:
            print(&#39;-&#39; * 40)
            print(&#39;tick.SymbolCode&#39;, tick.SymbolCode.encode(&#39;ascii&#39;, &#39;ignore&#39;))
            fname = self.store.vcrtfields.get(tick.Field, tick.Field)
            print(&#39;  tick.Field   : {} ({})&#39;.format(fname, tick.Field))
            print(&#39;  tick.FieldEx :&#39;, tick.FieldEx)
            tdate = tick.Date
            if tdate:
                tdate = self.NULLDATE + timedelta(days=tick.Date)
            print(&#39;  tick.Date    :&#39;, tdate)

            print(&#39;  tick.Index   :&#39;, tick.TickIndex)
            print(&#39;  tick.Value   :&#39;, tick.Value)
            print(&#39;  tick.Text    :&#39;, tick.Text.encode(&#39;ascii&#39;, &#39;ignore&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.feed.DataBase" href="../feed.html#backtrader.feed.DataBase">DataBase</a></li>
<li><a title="backtrader.feed.AbstractDataBase" href="../feed.html#backtrader.feed.AbstractDataBase">AbstractDataBase</a></li>
<li><a title="backtrader.dataseries.OHLCDateTime" href="../dataseries.html#backtrader.dataseries.OHLCDateTime">OHLCDateTime</a></li>
<li><a title="backtrader.dataseries.OHLC" href="../dataseries.html#backtrader.dataseries.OHLC">OHLC</a></li>
<li><a title="backtrader.dataseries.DataSeries" href="../dataseries.html#backtrader.dataseries.DataSeries">DataSeries</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="../lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="../lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="../lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.feeds.vcdata.VCData.MILLISECOND"><code class="name">var <span class="ident">MILLISECOND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.NULLDATE"><code class="name">var <span class="ident">NULLDATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.PING_TIMEOUT"><code class="name">var <span class="ident">PING_TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.feeds.vcdata.VCData.OnNewDataSerieBar"><code class="name flex">
<span>def <span class="ident">OnNewDataSerieBar</span></span>(<span>self, DataSerie, forcepush=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnNewDataSerieBar(self, DataSerie, forcepush=False):
    # Processes the COM Event (also called directly when 1st creating the
    # data serie
    ssize = DataSerie.Size

    if ssize - self.idx &gt; 1:
        # More than 1 bar on-board -&gt; delay in place
        if self._laststatus != self.DELAYED:
            self.q.put(self.store._RT_DELAYED)

    # return everything if original tf is ticks or force pushing
    ssize += forcepush or self._ticking
    for idx in range(self.idx, ssize):
        bar = DataSerie.GetBarValues(idx)
        self.q.put(bar)

    if not forcepush and not self._ticking and ssize:
        # A bar has been left in place
        dtnow = datetime.now() - self._TOFFSET  # adjust local time

        bar = DataSerie.GetBarValues(ssize)
        dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
        if dtnow &lt; dt:
            # A bar is there, not deliverable yet - LIVE
            if self._laststatus != self.LIVE:
                self.q.put(self.store._RT_LIVE)

            # Adjust ping timeout to the bar boundary (plus mini leeway)
            self._pingtmout = (dt - dtnow).total_seconds() + 0.5

        else:
            self._pingtmout = self.PING_TIMEOUT  # no bar left, long pause
            self.q.put(bar)  # push bar and update index
            ssize += 1  # pushed last one out

    # Write down the last processed bar
    self.idx = max(1, ssize)</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.OnNewTicks"><code class="name flex">
<span>def <span class="ident">OnNewTicks</span></span>(<span>self, ArrayTicks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnNewTicks(self, ArrayTicks):
    # Process the COM Event for New Ticks. This is only used temporarily
    # for 2 purposes
    #
    # 1. If tick.Field == Field_Description is returned, it can be checked
    # if the requested symbol has been found or not (tick.Date == 0 -&gt; not
    # found). tick.Text has &#39;Not Found&#39;, but this is more likely to change
    # Once Field_Description has been seen, the 2nd stage takes place
    #
    # 2. When a tick.Field == Field_Time is seen and tick.TickIndex == 0,
    # the 1st tick of a second is seen and the tick.Date value can be used
    # to calculate a time offset to the feed server. This is later used to
    # check if a bar is due delivery or not
    #
    # After this the reception of ticks is cancelled

    aticks = ArrayTicks[0]
    # self.debug_ticks(aticks)
    ticks = dict()
    for tick in aticks:
        ticks[tick.Field] = tick

    if self.store.vcrtmod.Field_Description in ticks:
        if self._newticks:
            self._newticks = False
            hasdate = bool(ticks.get(self.store.vcrtmod.Field_Date, False))
            self.qrt.put(hasdate)
            return

    else:
        try:
            tick = ticks[self.store.vcrtmod.Field_Time]
        except KeyError:
            return

        if tick.TickIndex == 0 and self._mktoff1 is not None:
            # Adjust the tick time using the mktoffset (with the 096 excep)
            dttick = (self.NULLDATE + timedelta(days=tick.Date) +
                      self._mktoff1)

            self._TOFFSET = datetime.now() - dttick
            if self._mktcode in self._EXTRA_TIMEOFFSET:
                # These codes live theoretically in (UTC+00:00) Dublin,
                # Edinburgh, Lisbon, London which is &#39;Europe/London&#39;
                # But all experiments show the times to be displaced 1
                # hour to the west and hence the extra 3600 seconds
                self._TOFFSET -= timedelta(seconds=3600)

            # Cancel ticks
            self._vcrt.CancelSymbolFeed(self._dataname, False)</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.debug_ticks"><code class="name flex">
<span>def <span class="ident">debug_ticks</span></span>(<span>self, ticks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_ticks(self, ticks):
    print(&#39;*&#39; * 50, &#39;DEBUG OnNewTicks&#39;)
    for tick in ticks:
        print(&#39;-&#39; * 40)
        print(&#39;tick.SymbolCode&#39;, tick.SymbolCode.encode(&#39;ascii&#39;, &#39;ignore&#39;))
        fname = self.store.vcrtfields.get(tick.Field, tick.Field)
        print(&#39;  tick.Field   : {} ({})&#39;.format(fname, tick.Field))
        print(&#39;  tick.FieldEx :&#39;, tick.FieldEx)
        tdate = tick.Date
        if tdate:
            tdate = self.NULLDATE + timedelta(days=tick.Date)
        print(&#39;  tick.Date    :&#39;, tdate)

        print(&#39;  tick.Index   :&#39;, tick.TickIndex)
        print(&#39;  tick.Value   :&#39;, tick.Value)
        print(&#39;  tick.Text    :&#39;, tick.Text.encode(&#39;ascii&#39;, &#39;ignore&#39;))</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.haslivedata"><code class="name flex">
<span>def <span class="ident">haslivedata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def haslivedata(self):
    return self._laststatus == self.LIVE and self.q</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.islive"><code class="name flex">
<span>def <span class="ident">islive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> to notify <code>Cerebro</code> that preloading and runonce
should be deactivated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def islive(self):
    &#39;&#39;&#39;Returns ``True`` to notify ``Cerebro`` that preloading and runonce
    should be deactivated&#39;&#39;&#39;
    return True</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self):
    ssize = self._serie.Size

    if self.idx &gt; ssize:
        return  # no bar available

    if self._laststatus == self.CONNBROKEN:
        self._pingtmout = self.PING_TIMEOUT
        return  # do not push during disconnection

    dtnow = datetime.now() - self._TOFFSET
    # CHECK: there should be a maximum of 1 bar when pinging
    # In any case the algorithm doesn&#39;t hurt
    for idx in range(self.idx, ssize + 1):  # reach ssize
        bar = self._serie.GetBarValues(self.idx)
        # dt = (self.NULLDATE + timedelta(days=bar.Date) + self._mktoff1)
        dt = self.NULLDATE + timedelta(days=bar.Date) - self._mktoffdiff
        if dtnow &lt; dt:
            self._pingtmout = (dt - dtnow).total_seconds() + 0.5
            break  # cannot deliver anything

        # Adjust ping timeout to the bar boundary (plus mini leeway)
        self._pingtmout = self.PING_TIMEOUT  # no bar, nothing to check
        self.q.put(bar)  # push bar and update index
        self.idx += 1</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.setenvironment"><code class="name flex">
<span>def <span class="ident">setenvironment</span></span>(<span>self, env)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives an environment (cerebro) and passes it over to the store it
belongs to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setenvironment(self, env):
    &#39;&#39;&#39;Receives an environment (cerebro) and passes it over to the store it
    belongs to&#39;&#39;&#39;
    super(VCData, self).setenvironment(env)
    env.addstore(self.store)</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the VC connecction and gets the real contract and
contractdetails if it exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#39;&#39;&#39;Starts the VC connecction and gets the real contract and
    contractdetails if it exists&#39;&#39;&#39;
    super(VCData, self).start()

    self._state = self._ST_START  # mini finite state machine

    self._newticks = True  # control processing of initial ticks

    self._pingtmout = self.PING_TIMEOUT  # Initial timeout for ping

    self.idx = 1  # counter for the dataserie (vb is based at 1)
    self.q = None  # where bars are received

    # market time offsets
    self._mktoffset = None
    self._mktoff1 = None
    self._mktoffdiff = None

    if not self.store.connected():
        # Not connected -&gt; go away
        self.put_notification(self.DISCONNECTED)
        self._state = self._ST_NOTFOUND
        return

    self.put_notification(self.CONNECTED)
    # get real contract details with real conId (contractId)
    self.qrt = queue.Queue()  # to await a ping
    self.store._rtdata(self, self._dataname)
    symfound = self.qrt.get()
    if not symfound:
        # Kill any further action and signal it
        self.put_notification(self.NOTSUBSCRIBED)
        self.put_notification(self.DISCONNECTED)
        self._state = self._ST_NOTFOUND
        return

    if self.replaying:
        # In this case don&#39;t request the final
        # timeframe from vc, but the original that has to be replayed
        self._tf, self._comp = self.p.timeframe, self.p.compression
    else:
        # Else (even if resampling) pass the final timeframe which may
        # been modified by a resampling filter
        self._tf, self._comp = self._timeframe, self._compression,

    self._ticking = self.store._ticking(self._tf)
    self._syminfo = syminfo = self.store._symboldata(self._dataname)

    # For most markets:
    # mktoffset == mktoff1 and substracting this value from reported times
    # is enough to report the &#34;market time&#34;. Visual Chart changes this from
    # a value X to 0 if the appropriate setting in the GUI is changed to
    # change display of time from local &lt;-&gt; market
    #
    # But some markets (at least 096XXX) that theoretically live in
    # Europe/London seem to be displaced 1 hour to the west and an extra
    # hour is needed.
    # These markets do also need &#34;usetimezoned&#34; True to actually display
    # the market time, because this is done internally using the
    # definitions in TZOUTS

    # Record and calculate market offsets
    self._mktoffset = timedelta(seconds=syminfo.TimeOffset)
    # Add millisecond to pusth HH:MM:59.999 -&gt; 00.000 unless ticks
    if self.p.millisecond and not self._ticking:
        self._mktoffset -= self.MILLISECOND

    self._mktoff1 = self._mktoffset
    if self._mktcode in self._EXTRA_TIMEOFFSET:
        # These codes live theoretically in
        # (UTC+00:00) Dublin, Edinburgh, Lisbon, London which is
        # &#39;Europe/London&#39;
        # But all experiments show the times to be displaced 1 hour to
        # the west and hence the extra 3600 seconds
        self._mktoffset -= timedelta(seconds=3600)

    self._mktoffdiff = self._mktoffset - self._mktoff1

    if self._state == self._ST_START:
        self.put_notification(self.DELAYED)

        # Now request the data and get a comms queue for it
        self.q = self.store._directdata(
            self,
            self._dataname,
            self._tf, self._comp,
            self.p.fromdate, self.p.todate,
            self.p.historical)

        self._state = self._ST_FEEDING</code></pre>
</details>
</dd>
<dt id="backtrader.feeds.vcdata.VCData.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops and tells the store to stop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#39;&#39;&#39;Stops and tells the store to stop&#39;&#39;&#39;
    super(VCData, self).stop()
    if self.q:
        self.store._canceldirectdata(self.q)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.feed.DataBase" href="../feed.html#backtrader.feed.DataBase">DataBase</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.feed.DataBase.addminperiod" href="../lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.feed.DataBase.compensate" href="../feed.html#backtrader.feed.AbstractDataBase.compensate">compensate</a></code></li>
<li><code><a title="backtrader.feed.DataBase.get_notifications" href="../feed.html#backtrader.feed.AbstractDataBase.get_notifications">get_notifications</a></code></li>
<li><code><a title="backtrader.feed.DataBase.incminperiod" href="../lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.feed.DataBase.lines" href="../lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.feed.DataBase.minbuffer" href="../lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.feed.DataBase.next" href="../lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.feed.DataBase.nextstart" href="../lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.feed.DataBase.once" href="../lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.feed.DataBase.oncestart" href="../lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.feed.DataBase.prenext" href="../lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.feed.DataBase.preonce" href="../lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.feed.DataBase.put_notification" href="../feed.html#backtrader.feed.AbstractDataBase.put_notification">put_notification</a></code></li>
<li><code><a title="backtrader.feed.DataBase.qbuffer" href="../lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.feed.DataBase.setminperiod" href="../lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.feed.DataBase.updateminperiod" href="../lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader.feeds" href="index.html">backtrader.feeds</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.feeds.vcdata.MetaVCData" href="#backtrader.feeds.vcdata.MetaVCData">MetaVCData</a></code></h4>
</li>
<li>
<h4><code><a title="backtrader.feeds.vcdata.VCData" href="#backtrader.feeds.vcdata.VCData">VCData</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.feeds.vcdata.VCData.MILLISECOND" href="#backtrader.feeds.vcdata.VCData.MILLISECOND">MILLISECOND</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.NULLDATE" href="#backtrader.feeds.vcdata.VCData.NULLDATE">NULLDATE</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.OnNewDataSerieBar" href="#backtrader.feeds.vcdata.VCData.OnNewDataSerieBar">OnNewDataSerieBar</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.OnNewTicks" href="#backtrader.feeds.vcdata.VCData.OnNewTicks">OnNewTicks</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.PING_TIMEOUT" href="#backtrader.feeds.vcdata.VCData.PING_TIMEOUT">PING_TIMEOUT</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.alias" href="#backtrader.feeds.vcdata.VCData.alias">alias</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.aliased" href="#backtrader.feeds.vcdata.VCData.aliased">aliased</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.debug_ticks" href="#backtrader.feeds.vcdata.VCData.debug_ticks">debug_ticks</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.frompackages" href="#backtrader.feeds.vcdata.VCData.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.haslivedata" href="#backtrader.feeds.vcdata.VCData.haslivedata">haslivedata</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.islive" href="#backtrader.feeds.vcdata.VCData.islive">islive</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.linealias" href="#backtrader.feeds.vcdata.VCData.linealias">linealias</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.packages" href="#backtrader.feeds.vcdata.VCData.packages">packages</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.params" href="#backtrader.feeds.vcdata.VCData.params">params</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.ping" href="#backtrader.feeds.vcdata.VCData.ping">ping</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.plotinfo" href="#backtrader.feeds.vcdata.VCData.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.plotlines" href="#backtrader.feeds.vcdata.VCData.plotlines">plotlines</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.setenvironment" href="#backtrader.feeds.vcdata.VCData.setenvironment">setenvironment</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.start" href="#backtrader.feeds.vcdata.VCData.start">start</a></code></li>
<li><code><a title="backtrader.feeds.vcdata.VCData.stop" href="#backtrader.feeds.vcdata.VCData.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>