<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.trade API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.trade</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import itertools

from .utils import AutoOrderedDict
from .utils.date import num2date
from .utils.py3 import range


class TradeHistory(AutoOrderedDict):
    &#39;&#39;&#39;Represents the status and update event for each update a Trade has

    This object is a dictionary which allows &#39;.&#39; notation

    Attributes:
      - ``status`` (``dict`` with &#39;.&#39; notation): Holds the resulting status of
        an update event and has the following sub-attributes

        - ``status`` (``int``): Trade status
        - ``dt`` (``float``): float coded datetime
        - ``barlen`` (``int``): number of bars the trade has been active
        - ``size`` (``int``): current size of the Trade
        - ``price`` (``float``): current price of the Trade
        - ``value`` (``float``): current monetary value of the Trade
        - ``pnl`` (``float``): current profit and loss of the Trade
        - ``pnlcomm`` (``float``): current profit and loss minus commission

      - ``event`` (``dict`` with &#39;.&#39; notation): Holds the event update
        - parameters

        - ``order`` (``object``): the order which initiated the``update``
        - ``size`` (``int``): size of the update
        - ``price`` (``float``):price of the update
        - ``commission`` (``float``): price of the update
    &#39;&#39;&#39;

    def __init__(self,
                 status, dt, barlen, size, price, value, pnl, pnlcomm, tz, event=None):
        &#39;&#39;&#39;Initializes the object to the current status of the Trade&#39;&#39;&#39;
        super(TradeHistory, self).__init__()
        self.status.status = status
        self.status.dt = dt
        self.status.barlen = barlen
        self.status.size = size
        self.status.price = price
        self.status.value = value
        self.status.pnl = pnl
        self.status.pnlcomm = pnlcomm
        self.status.tz = tz
        if event is not None:
            self.event = event

    def __reduce__(self):
        return (self.__class__, (self.status.status, self.status.dt, self.status.barlen, self.status.size,
                                 self.status.price, self.status.value, self.status.pnl, self.status.pnlcomm,
                                 self.status.tz, self.event, ))

    def doupdate(self, order, size, price, commission):
        &#39;&#39;&#39;Used to fill the ``update`` part of the history entry&#39;&#39;&#39;
        self.event.order = order
        self.event.size = size
        self.event.price = price
        self.event.commission = commission

        # Do not allow updates (avoids typing errors)
        self._close()

    def datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime for the time the update event happened&#39;&#39;&#39;
        return num2date(self.status.dt, tz or self.status.tz, naive)


class Trade(object):
    &#39;&#39;&#39;Keeps track of the life of an trade: size, price,
    commission (and value?)

    An trade starts at 0 can be increased and reduced and can
    be considered closed if it goes back to 0.

    The trade can be long (positive size) or short (negative size)

    An trade is not meant to be reversed (no support in the logic for it)

    Member Attributes:

      - ``ref``: unique trade identifier
      - ``status`` (``int``): one of Created, Open, Closed
      - ``tradeid``: grouping tradeid passed to orders during creation
        The default in orders is 0
      - ``size`` (``int``): current size of the trade
      - ``price`` (``float``): current price of the trade
      - ``value`` (``float``): current value of the trade
      - ``commission`` (``float``): current accumulated commission
      - ``pnl`` (``float``): current profit and loss of the trade (gross pnl)
      - ``pnlcomm`` (``float``): current profit and loss of the trade minus
        commission (net pnl)
      - ``isclosed`` (``bool``): records if the last update closed (set size to
        null the trade
      - ``isopen`` (``bool``): records if any update has opened the trade
      - ``justopened`` (``bool``): if the trade was just opened
      - ``baropen`` (``int``): bar in which this trade was opened

      - ``dtopen`` (``float``): float coded datetime in which the trade was
        opened

        - Use method ``open_datetime`` to get a Python datetime.datetime
          or use the platform provided ``num2date`` method

      - ``barclose`` (``int``): bar in which this trade was closed

      - ``dtclose`` (``float``): float coded datetime in which the trade was
        closed

        - Use method ``close_datetime`` to get a Python datetime.datetime
          or use the platform provided ``num2date`` method

      - ``barlen`` (``int``): number of bars this trade was open
      - ``historyon`` (``bool``): whether history has to be recorded
      - ``history`` (``list``): holds a list updated with each &#34;update&#34; event
        containing the resulting status and parameters used in the update

        The first entry in the history is the Opening Event
        The last entry in the history is the Closing Event

    &#39;&#39;&#39;
    refbasis = itertools.count(1)

    status_names = [&#39;Created&#39;, &#39;Open&#39;, &#39;Closed&#39;]
    Created, Open, Closed = range(3)

    def __str__(self):
        toprint = (
            &#39;ref&#39;, &#39;data&#39;, &#39;tradeid&#39;,
            &#39;size&#39;, &#39;price&#39;, &#39;value&#39;, &#39;commission&#39;, &#39;pnl&#39;, &#39;pnlcomm&#39;,
            &#39;justopened&#39;, &#39;isopen&#39;, &#39;isclosed&#39;,
            &#39;baropen&#39;, &#39;dtopen&#39;, &#39;barclose&#39;, &#39;dtclose&#39;, &#39;barlen&#39;,
            &#39;historyon&#39;, &#39;history&#39;,
            &#39;status&#39;)

        return &#39;\n&#39;.join(
            (&#39;:&#39;.join((x, str(getattr(self, x)))) for x in toprint)
        )

    def __init__(self, data=None, tradeid=0, historyon=False,
                 size=0, price=0.0, value=0.0, commission=0.0):

        self.ref = next(self.refbasis)
        self.data = data
        self.tradeid = tradeid
        self.size = size
        self.price = price
        self.value = value
        self.commission = commission

        self.pnl = 0.0
        self.pnlcomm = 0.0

        self.justopened = False
        self.isopen = False
        self.isclosed = False

        self.baropen = 0
        self.dtopen = 0.0
        self.barclose = 0
        self.dtclose = 0.0
        self.barlen = 0

        self.historyon = historyon
        self.history = list()

        self.status = self.Created

    def __len__(self):
        &#39;&#39;&#39;Absolute size of the trade&#39;&#39;&#39;
        return abs(self.size)

    def __bool__(self):
        &#39;&#39;&#39;Trade size is not 0&#39;&#39;&#39;
        return self.size != 0

    __nonzero__ = __bool__

    def getdataname(self):
        &#39;&#39;&#39;Shortcut to retrieve the name of the data this trade references&#39;&#39;&#39;
        return self.data._name

    def open_datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
        the trade was opened
        &#39;&#39;&#39;
        return self.data.num2date(self.dtopen, tz=tz, naive=naive)

    def close_datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
        the trade was closed
        &#39;&#39;&#39;
        return self.data.num2date(self.dtclose, tz=tz, naive=naive)

    def update(self, order, size, price, value, commission, pnl,
               comminfo):
        &#39;&#39;&#39;
        Updates the current trade. The logic does not check if the
        trade is reversed, which is not conceptually supported by the
        object.

        If an update sets the size attribute to 0, &#34;closed&#34; will be
        set to true

        Updates may be received twice for each order, once for the existing
        size which has been closed (sell undoing a buy) and a second time for
        the the opening part (sell reversing a buy)

        Args:
            order: the order object which has (completely or partially)
                generated this update
            size (int): amount to update the order
                if size has the same sign as the current trade a
                position increase will happen
                if size has the opposite sign as current op size a
                reduction/close will happen

            price (float): always be positive to ensure consistency
            value (float): (unused) cost incurred in new size/price op
                           Not used because the value is calculated for the
                           trade
            commission (float): incurred commission in the new size/price op
            pnl (float): (unused) generated by the executed part
                         Not used because the trade has an independent pnl
        &#39;&#39;&#39;
        if not size:
            return  # empty update, skip all other calculations

        # Commission can only increase
        self.commission += commission

        # Update size and keep a reference for logic an calculations
        oldsize = self.size
        self.size += size  # size will carry the opposite sign if reducing

        # Check if it has been currently opened
        self.justopened = bool(not oldsize and size)

        if self.justopened:
            self.baropen = len(self.data)
            self.dtopen = 0.0 if order.p.simulated else self.data.datetime[0]
            self.long = self.size &gt; 0

        # Any size means the trade was opened
        self.isopen = bool(self.size)

        # Update current trade length
        self.barlen = len(self.data) - self.baropen

        # record if the position was closed (set to null)
        self.isclosed = bool(oldsize and not self.size)

        # record last bar for the trade
        if self.isclosed:
            self.isopen = False
            self.barclose = len(self.data)
            self.dtclose = self.data.datetime[0]

            self.status = self.Closed
        elif self.isopen:
            self.status = self.Open

        if abs(self.size) &gt; abs(oldsize):
            # position increased (be it positive or negative)
            # update the average price
            self.price = (oldsize * self.price + size * price) / self.size
            pnl = 0.0

        else:  # abs(self.size) &lt; abs(oldsize)
            # position reduced/closed
            pnl = comminfo.profitandloss(-size, self.price, price)

        self.pnl += pnl
        self.pnlcomm = self.pnl - self.commission

        self.value = comminfo.getvaluesize(self.size, self.price)

        # Update the history if needed
        if self.historyon:
            dt0 = self.data.datetime[0] if not order.p.simulated else 0.0
            histentry = TradeHistory(
                self.status, dt0, self.barlen,
                self.size, self.price, self.value,
                self.pnl, self.pnlcomm, self.data._tz)
            histentry.doupdate(order, size, price, commission)
            self.history.append(histentry)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.trade.Trade"><code class="flex name class">
<span>class <span class="ident">Trade</span></span>
<span>(</span><span>data=None, tradeid=0, historyon=False, size=0, price=0.0, value=0.0, commission=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps track of the life of an trade: size, price,
commission (and value?)</p>
<p>An trade starts at 0 can be increased and reduced and can
be considered closed if it goes back to 0.</p>
<p>The trade can be long (positive size) or short (negative size)</p>
<p>An trade is not meant to be reversed (no support in the logic for it)</p>
<p>Member Attributes:</p>
<pre><code>- &lt;code&gt;ref&lt;/code&gt;: unique trade identifier
- &lt;code&gt;status&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;): one of Created, Open, Closed
- &lt;code&gt;tradeid&lt;/code&gt;: grouping tradeid passed to orders during creation
  The default in orders is 0
- &lt;code&gt;size&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;): current size of the trade
- &lt;code&gt;price&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): current price of the trade
- &lt;code&gt;value&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): current value of the trade
- &lt;code&gt;commission&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): current accumulated commission
- &lt;code&gt;pnl&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): current profit and loss of the trade (gross pnl)
- &lt;code&gt;pnlcomm&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): current profit and loss of the trade minus
  commission (net pnl)
- &lt;code&gt;isclosed&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;): records if the last update closed (set size to
  null the trade
- &lt;code&gt;isopen&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;): records if any update has opened the trade
- &lt;code&gt;justopened&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;): if the trade was just opened
- &lt;code&gt;baropen&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;): bar in which this trade was opened

- &lt;code&gt;dtopen&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): float coded datetime in which the trade was
  opened

  - Use method &lt;code&gt;open\_datetime&lt;/code&gt; to get a Python datetime.datetime
    or use the platform provided &lt;code&gt;num2date&lt;/code&gt; method

- &lt;code&gt;barclose&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;): bar in which this trade was closed

- &lt;code&gt;dtclose&lt;/code&gt; (&lt;code&gt;float&lt;/code&gt;): float coded datetime in which the trade was
  closed

  - Use method &lt;code&gt;close\_datetime&lt;/code&gt; to get a Python datetime.datetime
    or use the platform provided &lt;code&gt;num2date&lt;/code&gt; method

- &lt;code&gt;barlen&lt;/code&gt; (&lt;code&gt;int&lt;/code&gt;): number of bars this trade was open
- &lt;code&gt;historyon&lt;/code&gt; (&lt;code&gt;bool&lt;/code&gt;): whether history has to be recorded
- &lt;code&gt;history&lt;/code&gt; (&lt;code&gt;list&lt;/code&gt;): holds a list updated with each "update" event
  containing the resulting status and parameters used in the update

  The first entry in the history is the Opening Event
  The last entry in the history is the Closing Event
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trade(object):
    &#39;&#39;&#39;Keeps track of the life of an trade: size, price,
    commission (and value?)

    An trade starts at 0 can be increased and reduced and can
    be considered closed if it goes back to 0.

    The trade can be long (positive size) or short (negative size)

    An trade is not meant to be reversed (no support in the logic for it)

    Member Attributes:

      - ``ref``: unique trade identifier
      - ``status`` (``int``): one of Created, Open, Closed
      - ``tradeid``: grouping tradeid passed to orders during creation
        The default in orders is 0
      - ``size`` (``int``): current size of the trade
      - ``price`` (``float``): current price of the trade
      - ``value`` (``float``): current value of the trade
      - ``commission`` (``float``): current accumulated commission
      - ``pnl`` (``float``): current profit and loss of the trade (gross pnl)
      - ``pnlcomm`` (``float``): current profit and loss of the trade minus
        commission (net pnl)
      - ``isclosed`` (``bool``): records if the last update closed (set size to
        null the trade
      - ``isopen`` (``bool``): records if any update has opened the trade
      - ``justopened`` (``bool``): if the trade was just opened
      - ``baropen`` (``int``): bar in which this trade was opened

      - ``dtopen`` (``float``): float coded datetime in which the trade was
        opened

        - Use method ``open_datetime`` to get a Python datetime.datetime
          or use the platform provided ``num2date`` method

      - ``barclose`` (``int``): bar in which this trade was closed

      - ``dtclose`` (``float``): float coded datetime in which the trade was
        closed

        - Use method ``close_datetime`` to get a Python datetime.datetime
          or use the platform provided ``num2date`` method

      - ``barlen`` (``int``): number of bars this trade was open
      - ``historyon`` (``bool``): whether history has to be recorded
      - ``history`` (``list``): holds a list updated with each &#34;update&#34; event
        containing the resulting status and parameters used in the update

        The first entry in the history is the Opening Event
        The last entry in the history is the Closing Event

    &#39;&#39;&#39;
    refbasis = itertools.count(1)

    status_names = [&#39;Created&#39;, &#39;Open&#39;, &#39;Closed&#39;]
    Created, Open, Closed = range(3)

    def __str__(self):
        toprint = (
            &#39;ref&#39;, &#39;data&#39;, &#39;tradeid&#39;,
            &#39;size&#39;, &#39;price&#39;, &#39;value&#39;, &#39;commission&#39;, &#39;pnl&#39;, &#39;pnlcomm&#39;,
            &#39;justopened&#39;, &#39;isopen&#39;, &#39;isclosed&#39;,
            &#39;baropen&#39;, &#39;dtopen&#39;, &#39;barclose&#39;, &#39;dtclose&#39;, &#39;barlen&#39;,
            &#39;historyon&#39;, &#39;history&#39;,
            &#39;status&#39;)

        return &#39;\n&#39;.join(
            (&#39;:&#39;.join((x, str(getattr(self, x)))) for x in toprint)
        )

    def __init__(self, data=None, tradeid=0, historyon=False,
                 size=0, price=0.0, value=0.0, commission=0.0):

        self.ref = next(self.refbasis)
        self.data = data
        self.tradeid = tradeid
        self.size = size
        self.price = price
        self.value = value
        self.commission = commission

        self.pnl = 0.0
        self.pnlcomm = 0.0

        self.justopened = False
        self.isopen = False
        self.isclosed = False

        self.baropen = 0
        self.dtopen = 0.0
        self.barclose = 0
        self.dtclose = 0.0
        self.barlen = 0

        self.historyon = historyon
        self.history = list()

        self.status = self.Created

    def __len__(self):
        &#39;&#39;&#39;Absolute size of the trade&#39;&#39;&#39;
        return abs(self.size)

    def __bool__(self):
        &#39;&#39;&#39;Trade size is not 0&#39;&#39;&#39;
        return self.size != 0

    __nonzero__ = __bool__

    def getdataname(self):
        &#39;&#39;&#39;Shortcut to retrieve the name of the data this trade references&#39;&#39;&#39;
        return self.data._name

    def open_datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
        the trade was opened
        &#39;&#39;&#39;
        return self.data.num2date(self.dtopen, tz=tz, naive=naive)

    def close_datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
        the trade was closed
        &#39;&#39;&#39;
        return self.data.num2date(self.dtclose, tz=tz, naive=naive)

    def update(self, order, size, price, value, commission, pnl,
               comminfo):
        &#39;&#39;&#39;
        Updates the current trade. The logic does not check if the
        trade is reversed, which is not conceptually supported by the
        object.

        If an update sets the size attribute to 0, &#34;closed&#34; will be
        set to true

        Updates may be received twice for each order, once for the existing
        size which has been closed (sell undoing a buy) and a second time for
        the the opening part (sell reversing a buy)

        Args:
            order: the order object which has (completely or partially)
                generated this update
            size (int): amount to update the order
                if size has the same sign as the current trade a
                position increase will happen
                if size has the opposite sign as current op size a
                reduction/close will happen

            price (float): always be positive to ensure consistency
            value (float): (unused) cost incurred in new size/price op
                           Not used because the value is calculated for the
                           trade
            commission (float): incurred commission in the new size/price op
            pnl (float): (unused) generated by the executed part
                         Not used because the trade has an independent pnl
        &#39;&#39;&#39;
        if not size:
            return  # empty update, skip all other calculations

        # Commission can only increase
        self.commission += commission

        # Update size and keep a reference for logic an calculations
        oldsize = self.size
        self.size += size  # size will carry the opposite sign if reducing

        # Check if it has been currently opened
        self.justopened = bool(not oldsize and size)

        if self.justopened:
            self.baropen = len(self.data)
            self.dtopen = 0.0 if order.p.simulated else self.data.datetime[0]
            self.long = self.size &gt; 0

        # Any size means the trade was opened
        self.isopen = bool(self.size)

        # Update current trade length
        self.barlen = len(self.data) - self.baropen

        # record if the position was closed (set to null)
        self.isclosed = bool(oldsize and not self.size)

        # record last bar for the trade
        if self.isclosed:
            self.isopen = False
            self.barclose = len(self.data)
            self.dtclose = self.data.datetime[0]

            self.status = self.Closed
        elif self.isopen:
            self.status = self.Open

        if abs(self.size) &gt; abs(oldsize):
            # position increased (be it positive or negative)
            # update the average price
            self.price = (oldsize * self.price + size * price) / self.size
            pnl = 0.0

        else:  # abs(self.size) &lt; abs(oldsize)
            # position reduced/closed
            pnl = comminfo.profitandloss(-size, self.price, price)

        self.pnl += pnl
        self.pnlcomm = self.pnl - self.commission

        self.value = comminfo.getvaluesize(self.size, self.price)

        # Update the history if needed
        if self.historyon:
            dt0 = self.data.datetime[0] if not order.p.simulated else 0.0
            histentry = TradeHistory(
                self.status, dt0, self.barlen,
                self.size, self.price, self.value,
                self.pnl, self.pnlcomm, self.data._tz)
            histentry.doupdate(order, size, price, commission)
            self.history.append(histentry)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.trade.Trade.Closed"><code class="name">var <span class="ident">Closed</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.trade.Trade.Created"><code class="name">var <span class="ident">Created</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.trade.Trade.Open"><code class="name">var <span class="ident">Open</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.trade.Trade.refbasis"><code class="name">var <span class="ident">refbasis</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.trade.Trade.status_names"><code class="name">var <span class="ident">status_names</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.trade.Trade.close_datetime"><code class="name flex">
<span>def <span class="ident">close_datetime</span></span>(<span>self, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a datetime.datetime object with the datetime in which
the trade was closed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_datetime(self, tz=None, naive=True):
    &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
    the trade was closed
    &#39;&#39;&#39;
    return self.data.num2date(self.dtclose, tz=tz, naive=naive)</code></pre>
</details>
</dd>
<dt id="backtrader.trade.Trade.getdataname"><code class="name flex">
<span>def <span class="ident">getdataname</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shortcut to retrieve the name of the data this trade references</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getdataname(self):
    &#39;&#39;&#39;Shortcut to retrieve the name of the data this trade references&#39;&#39;&#39;
    return self.data._name</code></pre>
</details>
</dd>
<dt id="backtrader.trade.Trade.open_datetime"><code class="name flex">
<span>def <span class="ident">open_datetime</span></span>(<span>self, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a datetime.datetime object with the datetime in which
the trade was opened</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_datetime(self, tz=None, naive=True):
    &#39;&#39;&#39;Returns a datetime.datetime object with the datetime in which
    the trade was opened
    &#39;&#39;&#39;
    return self.data.num2date(self.dtopen, tz=tz, naive=naive)</code></pre>
</details>
</dd>
<dt id="backtrader.trade.Trade.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, order, size, price, value, commission, pnl, comminfo)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the current trade. The logic does not check if the
trade is reversed, which is not conceptually supported by the
object.</p>
<p>If an update sets the size attribute to 0, "closed" will be
set to true</p>
<p>Updates may be received twice for each order, once for the existing
size which has been closed (sell undoing a buy) and a second time for
the the opening part (sell reversing a buy)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>order</code></strong></dt>
<dd>the order object which has (completely or partially)
generated this update</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>amount to update the order
if size has the same sign as the current trade a
position increase will happen
if size has the opposite sign as current op size a
reduction/close will happen</dd>
<dt><strong><code>price</code></strong> :&ensp;<code>float</code></dt>
<dd>always be positive to ensure consistency</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code></dt>
<dd>(unused) cost incurred in new size/price op
Not used because the value is calculated for the
trade</dd>
<dt><strong><code>commission</code></strong> :&ensp;<code>float</code></dt>
<dd>incurred commission in the new size/price op</dd>
<dt><strong><code>pnl</code></strong> :&ensp;<code>float</code></dt>
<dd>(unused) generated by the executed part
Not used because the trade has an independent pnl</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, order, size, price, value, commission, pnl,
           comminfo):
    &#39;&#39;&#39;
    Updates the current trade. The logic does not check if the
    trade is reversed, which is not conceptually supported by the
    object.

    If an update sets the size attribute to 0, &#34;closed&#34; will be
    set to true

    Updates may be received twice for each order, once for the existing
    size which has been closed (sell undoing a buy) and a second time for
    the the opening part (sell reversing a buy)

    Args:
        order: the order object which has (completely or partially)
            generated this update
        size (int): amount to update the order
            if size has the same sign as the current trade a
            position increase will happen
            if size has the opposite sign as current op size a
            reduction/close will happen

        price (float): always be positive to ensure consistency
        value (float): (unused) cost incurred in new size/price op
                       Not used because the value is calculated for the
                       trade
        commission (float): incurred commission in the new size/price op
        pnl (float): (unused) generated by the executed part
                     Not used because the trade has an independent pnl
    &#39;&#39;&#39;
    if not size:
        return  # empty update, skip all other calculations

    # Commission can only increase
    self.commission += commission

    # Update size and keep a reference for logic an calculations
    oldsize = self.size
    self.size += size  # size will carry the opposite sign if reducing

    # Check if it has been currently opened
    self.justopened = bool(not oldsize and size)

    if self.justopened:
        self.baropen = len(self.data)
        self.dtopen = 0.0 if order.p.simulated else self.data.datetime[0]
        self.long = self.size &gt; 0

    # Any size means the trade was opened
    self.isopen = bool(self.size)

    # Update current trade length
    self.barlen = len(self.data) - self.baropen

    # record if the position was closed (set to null)
    self.isclosed = bool(oldsize and not self.size)

    # record last bar for the trade
    if self.isclosed:
        self.isopen = False
        self.barclose = len(self.data)
        self.dtclose = self.data.datetime[0]

        self.status = self.Closed
    elif self.isopen:
        self.status = self.Open

    if abs(self.size) &gt; abs(oldsize):
        # position increased (be it positive or negative)
        # update the average price
        self.price = (oldsize * self.price + size * price) / self.size
        pnl = 0.0

    else:  # abs(self.size) &lt; abs(oldsize)
        # position reduced/closed
        pnl = comminfo.profitandloss(-size, self.price, price)

    self.pnl += pnl
    self.pnlcomm = self.pnl - self.commission

    self.value = comminfo.getvaluesize(self.size, self.price)

    # Update the history if needed
    if self.historyon:
        dt0 = self.data.datetime[0] if not order.p.simulated else 0.0
        histentry = TradeHistory(
            self.status, dt0, self.barlen,
            self.size, self.price, self.value,
            self.pnl, self.pnlcomm, self.data._tz)
        histentry.doupdate(order, size, price, commission)
        self.history.append(histentry)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.trade.TradeHistory"><code class="flex name class">
<span>class <span class="ident">TradeHistory</span></span>
<span>(</span><span>status, dt, barlen, size, price, value, pnl, pnlcomm, tz, event=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the status and update event for each update a Trade has</p>
<p>This object is a dictionary which allows '.' notation</p>
<h2 id="attributes">Attributes</h2>
<ul>
<li>
<p><code>status</code> (<code>dict</code> with '.' notation): Holds the resulting status of
an update event and has the following sub-attributes</p>
<ul>
<li><code>status</code> (<code>int</code>): Trade status</li>
<li><code>dt</code> (<code>float</code>): float coded datetime</li>
<li><code>barlen</code> (<code>int</code>): number of bars the trade has been active</li>
<li><code>size</code> (<code>int</code>): current size of the Trade</li>
<li><code>price</code> (<code>float</code>): current price of the Trade</li>
<li><code>value</code> (<code>float</code>): current monetary value of the Trade</li>
<li><code>pnl</code> (<code>float</code>): current profit and loss of the Trade</li>
<li><code>pnlcomm</code> (<code>float</code>): current profit and loss minus commission</li>
</ul>
</li>
<li>
<p><code>event</code> (<code>dict</code> with '.' notation): Holds the event update</p>
<ul>
<li>
<p>parameters</p>
</li>
<li>
<p><code>order</code> (<code>object</code>): the order which initiated the<code>update</code></p>
</li>
<li><code>size</code> (<code>int</code>): size of the update</li>
<li><code>price</code> (<code>float</code>):price of the update</li>
<li><code>commission</code> (<code>float</code>): price of the update
Initializes the object to the current status of the Trade</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TradeHistory(AutoOrderedDict):
    &#39;&#39;&#39;Represents the status and update event for each update a Trade has

    This object is a dictionary which allows &#39;.&#39; notation

    Attributes:
      - ``status`` (``dict`` with &#39;.&#39; notation): Holds the resulting status of
        an update event and has the following sub-attributes

        - ``status`` (``int``): Trade status
        - ``dt`` (``float``): float coded datetime
        - ``barlen`` (``int``): number of bars the trade has been active
        - ``size`` (``int``): current size of the Trade
        - ``price`` (``float``): current price of the Trade
        - ``value`` (``float``): current monetary value of the Trade
        - ``pnl`` (``float``): current profit and loss of the Trade
        - ``pnlcomm`` (``float``): current profit and loss minus commission

      - ``event`` (``dict`` with &#39;.&#39; notation): Holds the event update
        - parameters

        - ``order`` (``object``): the order which initiated the``update``
        - ``size`` (``int``): size of the update
        - ``price`` (``float``):price of the update
        - ``commission`` (``float``): price of the update
    &#39;&#39;&#39;

    def __init__(self,
                 status, dt, barlen, size, price, value, pnl, pnlcomm, tz, event=None):
        &#39;&#39;&#39;Initializes the object to the current status of the Trade&#39;&#39;&#39;
        super(TradeHistory, self).__init__()
        self.status.status = status
        self.status.dt = dt
        self.status.barlen = barlen
        self.status.size = size
        self.status.price = price
        self.status.value = value
        self.status.pnl = pnl
        self.status.pnlcomm = pnlcomm
        self.status.tz = tz
        if event is not None:
            self.event = event

    def __reduce__(self):
        return (self.__class__, (self.status.status, self.status.dt, self.status.barlen, self.status.size,
                                 self.status.price, self.status.value, self.status.pnl, self.status.pnlcomm,
                                 self.status.tz, self.event, ))

    def doupdate(self, order, size, price, commission):
        &#39;&#39;&#39;Used to fill the ``update`` part of the history entry&#39;&#39;&#39;
        self.event.order = order
        self.event.size = size
        self.event.price = price
        self.event.commission = commission

        # Do not allow updates (avoids typing errors)
        self._close()

    def datetime(self, tz=None, naive=True):
        &#39;&#39;&#39;Returns a datetime for the time the update event happened&#39;&#39;&#39;
        return num2date(self.status.dt, tz or self.status.tz, naive)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.utils.autodict.AutoOrderedDict" href="utils/autodict.html#backtrader.utils.autodict.AutoOrderedDict">AutoOrderedDict</a></li>
<li>collections.OrderedDict</li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backtrader.trade.TradeHistory.datetime"><code class="name flex">
<span>def <span class="ident">datetime</span></span>(<span>self, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a datetime for the time the update event happened</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datetime(self, tz=None, naive=True):
    &#39;&#39;&#39;Returns a datetime for the time the update event happened&#39;&#39;&#39;
    return num2date(self.status.dt, tz or self.status.tz, naive)</code></pre>
</details>
</dd>
<dt id="backtrader.trade.TradeHistory.doupdate"><code class="name flex">
<span>def <span class="ident">doupdate</span></span>(<span>self, order, size, price, commission)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to fill the <code>update</code> part of the history entry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doupdate(self, order, size, price, commission):
    &#39;&#39;&#39;Used to fill the ``update`` part of the history entry&#39;&#39;&#39;
    self.event.order = order
    self.event.size = size
    self.event.price = price
    self.event.commission = commission

    # Do not allow updates (avoids typing errors)
    self._close()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.trade.Trade" href="#backtrader.trade.Trade">Trade</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.trade.Trade.Closed" href="#backtrader.trade.Trade.Closed">Closed</a></code></li>
<li><code><a title="backtrader.trade.Trade.Created" href="#backtrader.trade.Trade.Created">Created</a></code></li>
<li><code><a title="backtrader.trade.Trade.Open" href="#backtrader.trade.Trade.Open">Open</a></code></li>
<li><code><a title="backtrader.trade.Trade.close_datetime" href="#backtrader.trade.Trade.close_datetime">close_datetime</a></code></li>
<li><code><a title="backtrader.trade.Trade.getdataname" href="#backtrader.trade.Trade.getdataname">getdataname</a></code></li>
<li><code><a title="backtrader.trade.Trade.open_datetime" href="#backtrader.trade.Trade.open_datetime">open_datetime</a></code></li>
<li><code><a title="backtrader.trade.Trade.refbasis" href="#backtrader.trade.Trade.refbasis">refbasis</a></code></li>
<li><code><a title="backtrader.trade.Trade.status_names" href="#backtrader.trade.Trade.status_names">status_names</a></code></li>
<li><code><a title="backtrader.trade.Trade.update" href="#backtrader.trade.Trade.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.trade.TradeHistory" href="#backtrader.trade.TradeHistory">TradeHistory</a></code></h4>
<ul class="">
<li><code><a title="backtrader.trade.TradeHistory.datetime" href="#backtrader.trade.TradeHistory.datetime">datetime</a></code></li>
<li><code><a title="backtrader.trade.TradeHistory.doupdate" href="#backtrader.trade.TradeHistory.doupdate">doupdate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>