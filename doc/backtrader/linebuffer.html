<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.linebuffer API documentation</title>
<meta name="description" content=".. module:: linebuffer â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.linebuffer</code></h1>
</header>
<section id="section-intro">
<div class="admonition module">
<p class="admonition-title">Module:&ensp;linebuffer</p>
</div>
<p>Classes that hold the buffer for a <em>line</em> and can operate on it
with appends, forwarding, rewinding, resetting and other</p>
<div class="admonition moduleauthor">
<p class="admonition-title">Moduleauthor:&ensp;Daniel Rodriguez</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
&#39;&#39;&#39;

.. module:: linebuffer

Classes that hold the buffer for a *line* and can operate on it
with appends, forwarding, rewinding, resetting and other

.. moduleauthor:: Daniel Rodriguez

&#39;&#39;&#39;
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import array
import collections
import datetime
from itertools import islice
import math

from .utils.py3 import range, with_metaclass, string_types

from .lineroot import LineRoot, LineSingle, LineMultiple
from . import metabase
from .utils import num2date, time2num


NAN = float(&#39;NaN&#39;)


class LineBuffer(LineSingle):
    &#39;&#39;&#39;
    LineBuffer defines an interface to an &#34;array.array&#34; (or list) in which
    index 0 points to the item which is active for input and output.

    Positive indices fetch values from the past (left hand side)
    Negative indices fetch values from the future (if the array has been
    extended on the right hand side)

    With this behavior no index has to be passed around to entities which have
    to work with the current value produced by other entities: the value is
    always reachable at &#34;0&#34;.

    Likewise storing the current value produced by &#34;self&#34; is done at 0.

    Additional operations to move the pointer (home, forward, extend, rewind,
    advance getzero) are provided

    The class can also hold &#34;bindings&#34; to other LineBuffers. When a value
    is set in this class
    it will also be set in the binding.
    &#39;&#39;&#39;

    UnBounded, QBuffer = (0, 1)

    def __init__(self):
        self.lines = [self]
        self.mode = self.UnBounded
        self.bindings = list()
        self.reset()
        self._tz = None

    def get_idx(self):
        return self._idx

    def set_idx(self, idx, force=False):
        # if QBuffer and the last position of the buffer was reached, keep
        # it (unless force) as index 0. This allows resampling
        #  - forward adds a position, but the 1st one is discarded, the 0 is
        #  invariant
        # force supports replaying, which needs the extra bar to float
        # forward/backwards, because the last input is read, and after a
        # &#34;backwards&#34; is used to update the previous data. Unless the position
        # 0 was moved to the previous index, it would fail
        if self.mode == self.QBuffer:
            if force or self._idx &lt; self.lenmark:
                self._idx = idx
        else:  # default: UnBounded
            self._idx = idx

    idx = property(get_idx, set_idx)

    def reset(self):
        &#39;&#39;&#39; Resets the internal buffer structure and the indices
        &#39;&#39;&#39;
        if self.mode == self.QBuffer:
            # add extrasize to ensure resample/replay work because they will
            # use backwards to erase the last bar/tick before delivering a new
            # bar The previous forward would have discarded the bar &#34;period&#34;
            # times ago and it will not come back. Having + 1 in the size
            # allows the forward without removing that bar
            self.array = collections.deque(maxlen=self.maxlen + self.extrasize)
            self.useislice = True
        else:
            self.array = array.array(str(&#39;d&#39;))
            self.useislice = False

        self.lencount = 0
        self.idx = -1
        self.extension = 0

    def qbuffer(self, savemem=0, extrasize=0):
        self.mode = self.QBuffer
        self.maxlen = self._minperiod
        self.extrasize = extrasize
        self.lenmark = self.maxlen - (not self.extrasize)
        self.reset()

    def getindicators(self):
        return []

    def minbuffer(self, size):
        &#39;&#39;&#39;The linebuffer must guarantee the minimum requested size to be
        available.

        In non-dqbuffer mode, this is always true (of course until data is
        filled at the beginning, there are less values, but minperiod in the
        framework should account for this.

        In dqbuffer mode the buffer has to be adjusted for this if currently
        less than requested
        &#39;&#39;&#39;
        if self.mode != self.QBuffer or self.maxlen &gt;= size:
            return

        self.maxlen = size
        self.lenmark = self.maxlen - (not self.extrasize)
        self.reset()

    def __len__(self):
        return self.lencount

    def buflen(self):
        &#39;&#39;&#39; Real data that can be currently held in the internal buffer

        The internal buffer can be longer than the actual stored data to
        allow for &#34;lookahead&#34; operations. The real amount of data that is
        held/can be held in the buffer
        is returned
        &#39;&#39;&#39;
        return len(self.array) - self.extension

    def __getitem__(self, ago):
        return self.array[self.idx + ago]

    def get(self, ago=0, size=1):
        &#39;&#39;&#39; Returns a slice of the array relative to *ago*

        Keyword Args:
            ago (int): Point of the array to which size will be added
            to return the slice size(int): size of the slice to return,
            can be positive or negative

        If size is positive *ago* will mark the end of the iterable and vice
        versa if size is negative

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        if self.useislice:
            start = self.idx + ago - size + 1
            end = self.idx + ago + 1
            return list(islice(self.array, start, end))

        return self.array[self.idx + ago - size + 1:self.idx + ago + 1]

    def getzeroval(self, idx=0):
        &#39;&#39;&#39; Returns a single value of the array relative to the real zero
        of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        return self.array[idx]

    def getzero(self, idx=0, size=1):
        &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        if self.useislice:
            return list(islice(self.array, idx, idx + size))

        return self.array[idx:idx + size]

    def __setitem__(self, ago, value):
        &#39;&#39;&#39; Sets a value at position &#34;ago&#34; and executes any associated bindings

        Keyword Args:
            ago (int): Point of the array to which size will be added to return
            the slice
            value (variable): value to be set
        &#39;&#39;&#39;
        self.array[self.idx + ago] = value
        for binding in self.bindings:
            binding[ago] = value

    def set(self, value, ago=0):
        &#39;&#39;&#39; Sets a value at position &#34;ago&#34; and executes any associated bindings

        Keyword Args:
            value (variable): value to be set
            ago (int): Point of the array to which size will be added to return
            the slice
        &#39;&#39;&#39;
        self.array[self.idx + ago] = value
        for binding in self.bindings:
            binding[ago] = value

    def home(self):
        &#39;&#39;&#39; Rewinds the logical index to the beginning

        The underlying buffer remains untouched and the actual len can be found
        out with buflen
        &#39;&#39;&#39;
        self.idx = -1
        self.lencount = 0

    def forward(self, value=NAN, size=1):
        &#39;&#39;&#39; Moves the logical index foward and enlarges the buffer as much as needed

        Keyword Args:
            value (variable): value to be set in new positins
            size (int): How many extra positions to enlarge the buffer
        &#39;&#39;&#39;
        self.idx += size
        self.lencount += size

        for i in range(size):
            self.array.append(value)

    def backwards(self, size=1, force=False):
        &#39;&#39;&#39; Moves the logical index backwards and reduces the buffer as much as needed

        Keyword Args:
            size (int): How many extra positions to rewind and reduce the
            buffer
        &#39;&#39;&#39;
        # Go directly to property setter to support force
        self.set_idx(self._idx - size, force=force)
        self.lencount -= size
        for i in range(size):
            self.array.pop()

    def rewind(self, size=1):
        self.idx -= size
        self.lencount -= size

    def advance(self, size=1):
        &#39;&#39;&#39; Advances the logical index without touching the underlying buffer

        Keyword Args:
            size (int): How many extra positions to move forward
        &#39;&#39;&#39;
        self.idx += size
        self.lencount += size

    def extend(self, value=NAN, size=0):
        &#39;&#39;&#39; Extends the underlying array with positions that the index will not reach

        Keyword Args:
            value (variable): value to be set in new positins
            size (int): How many extra positions to enlarge the buffer

        The purpose is to allow for lookahead operations or to be able to
        set values in the buffer &#34;future&#34;
        &#39;&#39;&#39;
        self.extension += size
        for i in range(size):
            self.array.append(value)

    def addbinding(self, binding):
        &#39;&#39;&#39; Adds another line binding

        Keyword Args:
            binding (LineBuffer): another line that must be set when this line
            becomes a value
        &#39;&#39;&#39;
        self.bindings.append(binding)
        # record in the binding when the period is starting (never sooner
        # than self)
        binding.updateminperiod(self._minperiod)

    def plot(self, idx=0, size=None):
        &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        This is a variant of getzero which unless told otherwise returns the
        entire buffer, which is usually the idea behind plottint (all must
        plotted)

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        return self.getzero(idx, size or len(self))

    def plotrange(self, start, end):
        if self.useislice:
            return list(islice(self.array, start, end))

        return self.array[start:end]

    def oncebinding(self):
        &#39;&#39;&#39;
        Executes the bindings when running in &#34;once&#34; mode
        &#39;&#39;&#39;
        larray = self.array
        blen = self.buflen()
        for binding in self.bindings:
            binding.array[0:blen] = larray[0:blen]

    def bind2lines(self, binding=0):
        &#39;&#39;&#39;
        Stores a binding to another line. &#34;binding&#34; can be an index or a name
        &#39;&#39;&#39;
        if isinstance(binding, string_types):
            line = getattr(self._owner.lines, binding)
        else:
            line = self._owner.lines[binding]

        self.addbinding(line)

        return self

    bind2line = bind2lines

    def __call__(self, ago=None):
        &#39;&#39;&#39;Returns either a delayed verison of itself in the form of a
        LineDelay object or a timeframe adapting version with regards to a ago

        Param: ago (default: None)

          If ago is None or an instance of LineRoot (a lines object) the
          returned valued is a LineCoupler instance

          If ago is anything else, it is assumed to be an int and a LineDelay
          object will be returned
        &#39;&#39;&#39;
        from .lineiterator import LineCoupler
        if ago is None or isinstance(ago, LineRoot):
            return LineCoupler(self, ago)

        return LineDelay(self, ago)

    def _makeoperation(self, other, operation, r=False, _ownerskip=None):
        return LinesOperation(self, other, operation, r=r,
                              _ownerskip=_ownerskip)

    def _makeoperationown(self, operation, _ownerskip=None):
        return LineOwnOperation(self, operation, _ownerskip=_ownerskip)

    def _settz(self, tz):
        self._tz = tz

    def datetime(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive)

    def date(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive).date()

    def time(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive).time()

    def dt(self, ago=0):
        &#39;&#39;&#39;
        return numeric date part of datetimefloat
        &#39;&#39;&#39;
        return math.trunc(self.array[self.idx + ago])

    def tm_raw(self, ago=0):
        &#39;&#39;&#39;
        return raw numeric time part of datetimefloat
        &#39;&#39;&#39;
        # This function is named raw because it retrieves the fractional part
        # without transforming it to time to avoid the influence of the day
        # count (integer part of coding)
        return math.modf(self.array[self.idx + ago])[0]

    def tm(self, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To avoid precision errors, this returns the fractional part after
        # having converted it to a datetime.time object to avoid precision
        # errors in comparisons
        return time2num(num2date(self.array[self.idx + ago]).time())

    def tm_lt(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &lt; (dt + other)

    def tm_le(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &lt;= (dt + other)

    def tm_eq(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime == (dt + other)

    def tm_gt(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &gt; (dt + other)

    def tm_ge(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &gt;= (dt + other)

    def tm2dtime(self, tm, ago=0):
        &#39;&#39;&#39;
        Returns the given ``tm`` in the frame of the (ago bars) datatime.

        Useful for external comparisons to avoid precision errors
        &#39;&#39;&#39;
        return int(self.array[self.idx + ago]) + tm

    def tm2datetime(self, tm, ago=0):
        &#39;&#39;&#39;
        Returns the given ``tm`` in the frame of the (ago bars) datatime.

        Useful for external comparisons to avoid precision errors
        &#39;&#39;&#39;
        return num2date(int(self.array[self.idx + ago]) + tm)


class MetaLineActions(LineBuffer.__class__):
    &#39;&#39;&#39;
    Metaclass for Lineactions

    Scans the instance before init for LineBuffer (or parentclass LineSingle)
    instances to calculate the minperiod for this instance

    postinit it registers the instance to the owner (remember that owner has
    been found in the base Metaclass for LineRoot)
    &#39;&#39;&#39;
    _acache = dict()
    _acacheuse = False

    @classmethod
    def cleancache(cls):
        cls._acache = dict()

    @classmethod
    def usecache(cls, onoff):
        cls._acacheuse = onoff

    def __call__(cls, *args, **kwargs):
        if not cls._acacheuse:
            return super(MetaLineActions, cls).__call__(*args, **kwargs)

        # implement a cache to avoid duplicating lines actions
        ckey = (cls, tuple(args), tuple(kwargs.items()))  # tuples hashable
        try:
            return cls._acache[ckey]
        except TypeError:  # something not hashable
            return super(MetaLineActions, cls).__call__(*args, **kwargs)
        except KeyError:
            pass  # hashable but not in the cache

        _obj = super(MetaLineActions, cls).__call__(*args, **kwargs)
        return cls._acache.setdefault(ckey, _obj)

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineActions, cls).dopreinit(_obj, *args, **kwargs)

        _obj._clock = _obj._owner  # default setting

        if isinstance(args[0], LineRoot):
            _obj._clock = args[0]

        # Keep a reference to the datas for buffer adjustment purposes
        _obj._datas = [x for x in args if isinstance(x, LineRoot)]

        # Do not produce anything until the operation lines produce something
        _minperiods = [x._minperiod for x in args if isinstance(x, LineSingle)]

        mlines = [x.lines[0] for x in args if isinstance(x, LineMultiple)]
        _minperiods += [x._minperiod for x in mlines]

        _minperiod = max(_minperiods or [1])

        # update own minperiod if needed
        _obj.updateminperiod(_minperiod)

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineActions, cls).dopostinit(_obj, *args, **kwargs)

        # register with _owner to be kicked later
        _obj._owner.addindicator(_obj)

        return _obj, args, kwargs


class PseudoArray(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def __getitem__(self, key):
        return self.wrapped

    @property
    def array(self):
        return self


class LineActions(with_metaclass(MetaLineActions, LineBuffer)):
    &#39;&#39;&#39;
    Base class derived from LineBuffer intented to defined the
    minimum interface to make it compatible with a LineIterator by
    providing operational _next and _once interfaces.

    The metaclass does the dirty job of calculating minperiods and registering
    &#39;&#39;&#39;

    _ltype = LineBuffer.IndType

    def getindicators(self):
        return []

    def qbuffer(self, savemem=0):
        super(LineActions, self).qbuffer(savemem=savemem)
        for data in self._datas:
            data.minbuffer(size=self._minperiod)

    @staticmethod
    def arrayize(obj):
        if isinstance(obj, LineRoot):
            if not isinstance(obj, LineSingle):
                obj = obj.lines[0]  # get 1st line from multiline
        else:
            obj = PseudoArray(obj)

        return obj

    def _next(self):
        clock_len = len(self._clock)
        if clock_len &gt; len(self):
            self.forward()

        if clock_len &gt; self._minperiod:
            self.next()
        elif clock_len == self._minperiod:
            # only called for the 1st value
            self.nextstart()
        else:
            self.prenext()

    def _once(self):
        self.forward(size=self._clock.buflen())
        self.home()

        self.preonce(0, self._minperiod - 1)
        self.oncestart(self._minperiod - 1, self._minperiod)
        self.once(self._minperiod, self.buflen())

        self.oncebinding()


def LineDelay(a, ago=0, **kwargs):
    if ago &lt;= 0:
        return _LineDelay(a, ago, **kwargs)

    return _LineForward(a, ago, **kwargs)


def LineNum(num):
    return LineDelay(PseudoArray(num))


class _LineDelay(LineActions):
    &#39;&#39;&#39;
    Takes a LineBuffer (or derived) object and stores the value from
    &#34;ago&#34; periods effectively delaying the delivery of data
    &#39;&#39;&#39;
    def __init__(self, a, ago):
        super(_LineDelay, self).__init__()
        self.a = a
        self.ago = ago

        # Need to add the delay to the period. &#34;ago&#34; is 0 based and therefore
        # we need to pass and extra 1 which is the minimum defined period for
        # any data (which will be substracted inside addminperiod)
        self.addminperiod(abs(ago) + 1)

    def next(self):
        self[0] = self.a[self.ago]

    def once(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        src = self.a.array
        ago = self.ago

        for i in range(start, end):
            dst[i] = src[i + ago]


class _LineForward(LineActions):
    &#39;&#39;&#39;
    Takes a LineBuffer (or derived) object and stores the value from
    &#34;ago&#34; periods from the future
    &#39;&#39;&#39;
    def __init__(self, a, ago):
        super(_LineForward, self).__init__()
        self.a = a
        self.ago = ago

        # Need to add the delay to the period. &#34;ago&#34; is 0 based and therefore
        # we need to pass and extra 1 which is the minimum defined period for
        # any data (which will be substracted inside addminperiod)
        # self.addminperiod(abs(ago) + 1)
        if ago &gt; self.a._minperiod:
            self.addminperiod(ago - self.a._minperiod + 1)

    def next(self):
        self[-self.ago] = self.a[0]

    def once(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        src = self.a.array
        ago = self.ago

        for i in range(start, end):
            dst[i - ago] = src[i]


class LinesOperation(LineActions):

    &#39;&#39;&#39;
    Holds an operation that operates on a two operands. Example: mul

    It will &#34;next&#34;/traverse the array applying the operation on the
    two operands and storing the result in self.

    To optimize the operations and avoid conditional checks the right
    next/once is chosen using the operation direction (normal or reversed)
    and the nature of the operands (LineBuffer vs non-LineBuffer)

    In the &#34;once&#34; operations &#34;map&#34; could be used as in:

        operated = map(self.operation, srca[start:end], srcb[start:end])
        self.array[start:end] = array.array(str(self.typecode), operated)

    No real execution time benefits were appreciated and therefore the loops
    have been kept in place for clarity (although the maps are not really
    unclear here)
    &#39;&#39;&#39;

    def __init__(self, a, b, operation, r=False):
        super(LinesOperation, self).__init__()

        self.operation = operation
        self.a = a  # always a linebuffer
        self.b = b

        self.r = r
        self.bline = isinstance(b, LineBuffer)
        self.btime = isinstance(b, datetime.time)
        self.bfloat = not self.bline and not self.btime

        if r:
            self.a, self.b = b, a

    def next(self):
        if self.bline:
            self[0] = self.operation(self.a[0], self.b[0])
        elif not self.r:
            if not self.btime:
                self[0] = self.operation(self.a[0], self.b)
            else:
                self[0] = self.operation(self.a.time(), self.b)
        else:
            self[0] = self.operation(self.a, self.b[0])

    def once(self, start, end):
        if self.bline:
            self._once_op(start, end)
        elif not self.r:
            if not self.btime:
                self._once_val_op(start, end)
            else:
                self._once_time_op(start, end)
        else:
            self._once_val_op_r(start, end)

    def _once_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i], srcb[i])

    def _once_time_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b
        op = self.operation
        tz = self._tz

        for i in range(start, end):
            dst[i] = op(num2date(srca[i], tz=tz).time(), srcb)

    def _once_val_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i], srcb)

    def _once_val_op_r(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a
        srcb = self.b.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca, srcb[i])


class LineOwnOperation(LineActions):
    &#39;&#39;&#39;
    Holds an operation that operates on a single operand. Example: abs

    It will &#34;next&#34;/traverse the array applying the operation and storing
    the result in self
    &#39;&#39;&#39;
    def __init__(self, a, operation):
        super(LineOwnOperation, self).__init__()

        self.operation = operation
        self.a = a

    def next(self):
        self[0] = self.operation(self.a[0])

    def once(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backtrader.linebuffer.LineDelay"><code class="name flex">
<span>def <span class="ident">LineDelay</span></span>(<span>a, ago=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LineDelay(a, ago=0, **kwargs):
    if ago &lt;= 0:
        return _LineDelay(a, ago, **kwargs)

    return _LineForward(a, ago, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineNum"><code class="name flex">
<span>def <span class="ident">LineNum</span></span>(<span>num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LineNum(num):
    return LineDelay(PseudoArray(num))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.linebuffer.LineActions"><code class="flex name class">
<span>class <span class="ident">LineActions</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class derived from LineBuffer intented to defined the
minimum interface to make it compatible with a LineIterator by
providing operational _next and _once interfaces.</p>
<p>The metaclass does the dirty job of calculating minperiods and registering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineActions(with_metaclass(MetaLineActions, LineBuffer)):
    &#39;&#39;&#39;
    Base class derived from LineBuffer intented to defined the
    minimum interface to make it compatible with a LineIterator by
    providing operational _next and _once interfaces.

    The metaclass does the dirty job of calculating minperiods and registering
    &#39;&#39;&#39;

    _ltype = LineBuffer.IndType

    def getindicators(self):
        return []

    def qbuffer(self, savemem=0):
        super(LineActions, self).qbuffer(savemem=savemem)
        for data in self._datas:
            data.minbuffer(size=self._minperiod)

    @staticmethod
    def arrayize(obj):
        if isinstance(obj, LineRoot):
            if not isinstance(obj, LineSingle):
                obj = obj.lines[0]  # get 1st line from multiline
        else:
            obj = PseudoArray(obj)

        return obj

    def _next(self):
        clock_len = len(self._clock)
        if clock_len &gt; len(self):
            self.forward()

        if clock_len &gt; self._minperiod:
            self.next()
        elif clock_len == self._minperiod:
            # only called for the 1st value
            self.nextstart()
        else:
            self.prenext()

    def _once(self):
        self.forward(size=self._clock.buflen())
        self.home()

        self.preonce(0, self._minperiod - 1)
        self.oncestart(self._minperiod - 1, self._minperiod)
        self.once(self._minperiod, self.buflen())

        self.oncebinding()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.linebuffer.LineBuffer" href="#backtrader.linebuffer.LineBuffer">LineBuffer</a></li>
<li><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.functions.Logic" href="functions.html#backtrader.functions.Logic">Logic</a></li>
<li><a title="backtrader.linebuffer.LineOwnOperation" href="#backtrader.linebuffer.LineOwnOperation">LineOwnOperation</a></li>
<li><a title="backtrader.linebuffer.LinesOperation" href="#backtrader.linebuffer.LinesOperation">LinesOperation</a></li>
<li>backtrader.linebuffer._LineDelay</li>
<li>backtrader.linebuffer._LineForward</li>
<li><a title="backtrader.lineiterator.SingleCoupler" href="lineiterator.html#backtrader.lineiterator.SingleCoupler">SingleCoupler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.linebuffer.LineActions.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineActions.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineActions.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="backtrader.linebuffer.LineActions.arrayize"><code class="name flex">
<span>def <span class="ident">arrayize</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def arrayize(obj):
    if isinstance(obj, LineRoot):
        if not isinstance(obj, LineSingle):
            obj = obj.lines[0]  # get 1st line from multiline
    else:
        obj = PseudoArray(obj)

    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.linebuffer.LineActions.getindicators"><code class="name flex">
<span>def <span class="ident">getindicators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getindicators(self):
    return []</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.linebuffer.LineBuffer" href="#backtrader.linebuffer.LineBuffer">LineBuffer</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.linebuffer.LineBuffer.addbinding" href="#backtrader.linebuffer.LineBuffer.addbinding">addbinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.addminperiod" href="lineroot.html#backtrader.lineroot.LineSingle.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.advance" href="#backtrader.linebuffer.LineBuffer.advance">advance</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.backwards" href="#backtrader.linebuffer.LineBuffer.backwards">backwards</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.bind2line" href="#backtrader.linebuffer.LineBuffer.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.bind2lines" href="#backtrader.linebuffer.LineBuffer.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.buflen" href="#backtrader.linebuffer.LineBuffer.buflen">buflen</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.dt" href="#backtrader.linebuffer.LineBuffer.dt">dt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.extend" href="#backtrader.linebuffer.LineBuffer.extend">extend</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.forward" href="#backtrader.linebuffer.LineBuffer.forward">forward</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.get" href="#backtrader.linebuffer.LineBuffer.get">get</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.getzero" href="#backtrader.linebuffer.LineBuffer.getzero">getzero</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.getzeroval" href="#backtrader.linebuffer.LineBuffer.getzeroval">getzeroval</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.home" href="#backtrader.linebuffer.LineBuffer.home">home</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.incminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.minbuffer" href="#backtrader.linebuffer.LineBuffer.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.next" href="lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.nextstart" href="lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.oncebinding" href="#backtrader.linebuffer.LineBuffer.oncebinding">oncebinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.plot" href="#backtrader.linebuffer.LineBuffer.plot">plot</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.prenext" href="lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.reset" href="#backtrader.linebuffer.LineBuffer.reset">reset</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.set" href="#backtrader.linebuffer.LineBuffer.set">set</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm" href="#backtrader.linebuffer.LineBuffer.tm">tm</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm2datetime" href="#backtrader.linebuffer.LineBuffer.tm2datetime">tm2datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm2dtime" href="#backtrader.linebuffer.LineBuffer.tm2dtime">tm2dtime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_eq" href="#backtrader.linebuffer.LineBuffer.tm_eq">tm_eq</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_ge" href="#backtrader.linebuffer.LineBuffer.tm_ge">tm_ge</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_gt" href="#backtrader.linebuffer.LineBuffer.tm_gt">tm_gt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_le" href="#backtrader.linebuffer.LineBuffer.tm_le">tm_le</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_lt" href="#backtrader.linebuffer.LineBuffer.tm_lt">tm_lt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_raw" href="#backtrader.linebuffer.LineBuffer.tm_raw">tm_raw</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.linebuffer.LineBuffer"><code class="flex name class">
<span>class <span class="ident">LineBuffer</span></span>
</code></dt>
<dd>
<div class="desc"><p>LineBuffer defines an interface to an "array.array" (or list) in which
index 0 points to the item which is active for input and output.</p>
<p>Positive indices fetch values from the past (left hand side)
Negative indices fetch values from the future (if the array has been
extended on the right hand side)</p>
<p>With this behavior no index has to be passed around to entities which have
to work with the current value produced by other entities: the value is
always reachable at "0".</p>
<p>Likewise storing the current value produced by "self" is done at 0.</p>
<p>Additional operations to move the pointer (home, forward, extend, rewind,
advance getzero) are provided</p>
<p>The class can also hold "bindings" to other LineBuffers. When a value
is set in this class
it will also be set in the binding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineBuffer(LineSingle):
    &#39;&#39;&#39;
    LineBuffer defines an interface to an &#34;array.array&#34; (or list) in which
    index 0 points to the item which is active for input and output.

    Positive indices fetch values from the past (left hand side)
    Negative indices fetch values from the future (if the array has been
    extended on the right hand side)

    With this behavior no index has to be passed around to entities which have
    to work with the current value produced by other entities: the value is
    always reachable at &#34;0&#34;.

    Likewise storing the current value produced by &#34;self&#34; is done at 0.

    Additional operations to move the pointer (home, forward, extend, rewind,
    advance getzero) are provided

    The class can also hold &#34;bindings&#34; to other LineBuffers. When a value
    is set in this class
    it will also be set in the binding.
    &#39;&#39;&#39;

    UnBounded, QBuffer = (0, 1)

    def __init__(self):
        self.lines = [self]
        self.mode = self.UnBounded
        self.bindings = list()
        self.reset()
        self._tz = None

    def get_idx(self):
        return self._idx

    def set_idx(self, idx, force=False):
        # if QBuffer and the last position of the buffer was reached, keep
        # it (unless force) as index 0. This allows resampling
        #  - forward adds a position, but the 1st one is discarded, the 0 is
        #  invariant
        # force supports replaying, which needs the extra bar to float
        # forward/backwards, because the last input is read, and after a
        # &#34;backwards&#34; is used to update the previous data. Unless the position
        # 0 was moved to the previous index, it would fail
        if self.mode == self.QBuffer:
            if force or self._idx &lt; self.lenmark:
                self._idx = idx
        else:  # default: UnBounded
            self._idx = idx

    idx = property(get_idx, set_idx)

    def reset(self):
        &#39;&#39;&#39; Resets the internal buffer structure and the indices
        &#39;&#39;&#39;
        if self.mode == self.QBuffer:
            # add extrasize to ensure resample/replay work because they will
            # use backwards to erase the last bar/tick before delivering a new
            # bar The previous forward would have discarded the bar &#34;period&#34;
            # times ago and it will not come back. Having + 1 in the size
            # allows the forward without removing that bar
            self.array = collections.deque(maxlen=self.maxlen + self.extrasize)
            self.useislice = True
        else:
            self.array = array.array(str(&#39;d&#39;))
            self.useislice = False

        self.lencount = 0
        self.idx = -1
        self.extension = 0

    def qbuffer(self, savemem=0, extrasize=0):
        self.mode = self.QBuffer
        self.maxlen = self._minperiod
        self.extrasize = extrasize
        self.lenmark = self.maxlen - (not self.extrasize)
        self.reset()

    def getindicators(self):
        return []

    def minbuffer(self, size):
        &#39;&#39;&#39;The linebuffer must guarantee the minimum requested size to be
        available.

        In non-dqbuffer mode, this is always true (of course until data is
        filled at the beginning, there are less values, but minperiod in the
        framework should account for this.

        In dqbuffer mode the buffer has to be adjusted for this if currently
        less than requested
        &#39;&#39;&#39;
        if self.mode != self.QBuffer or self.maxlen &gt;= size:
            return

        self.maxlen = size
        self.lenmark = self.maxlen - (not self.extrasize)
        self.reset()

    def __len__(self):
        return self.lencount

    def buflen(self):
        &#39;&#39;&#39; Real data that can be currently held in the internal buffer

        The internal buffer can be longer than the actual stored data to
        allow for &#34;lookahead&#34; operations. The real amount of data that is
        held/can be held in the buffer
        is returned
        &#39;&#39;&#39;
        return len(self.array) - self.extension

    def __getitem__(self, ago):
        return self.array[self.idx + ago]

    def get(self, ago=0, size=1):
        &#39;&#39;&#39; Returns a slice of the array relative to *ago*

        Keyword Args:
            ago (int): Point of the array to which size will be added
            to return the slice size(int): size of the slice to return,
            can be positive or negative

        If size is positive *ago* will mark the end of the iterable and vice
        versa if size is negative

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        if self.useislice:
            start = self.idx + ago - size + 1
            end = self.idx + ago + 1
            return list(islice(self.array, start, end))

        return self.array[self.idx + ago - size + 1:self.idx + ago + 1]

    def getzeroval(self, idx=0):
        &#39;&#39;&#39; Returns a single value of the array relative to the real zero
        of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        return self.array[idx]

    def getzero(self, idx=0, size=1):
        &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        if self.useislice:
            return list(islice(self.array, idx, idx + size))

        return self.array[idx:idx + size]

    def __setitem__(self, ago, value):
        &#39;&#39;&#39; Sets a value at position &#34;ago&#34; and executes any associated bindings

        Keyword Args:
            ago (int): Point of the array to which size will be added to return
            the slice
            value (variable): value to be set
        &#39;&#39;&#39;
        self.array[self.idx + ago] = value
        for binding in self.bindings:
            binding[ago] = value

    def set(self, value, ago=0):
        &#39;&#39;&#39; Sets a value at position &#34;ago&#34; and executes any associated bindings

        Keyword Args:
            value (variable): value to be set
            ago (int): Point of the array to which size will be added to return
            the slice
        &#39;&#39;&#39;
        self.array[self.idx + ago] = value
        for binding in self.bindings:
            binding[ago] = value

    def home(self):
        &#39;&#39;&#39; Rewinds the logical index to the beginning

        The underlying buffer remains untouched and the actual len can be found
        out with buflen
        &#39;&#39;&#39;
        self.idx = -1
        self.lencount = 0

    def forward(self, value=NAN, size=1):
        &#39;&#39;&#39; Moves the logical index foward and enlarges the buffer as much as needed

        Keyword Args:
            value (variable): value to be set in new positins
            size (int): How many extra positions to enlarge the buffer
        &#39;&#39;&#39;
        self.idx += size
        self.lencount += size

        for i in range(size):
            self.array.append(value)

    def backwards(self, size=1, force=False):
        &#39;&#39;&#39; Moves the logical index backwards and reduces the buffer as much as needed

        Keyword Args:
            size (int): How many extra positions to rewind and reduce the
            buffer
        &#39;&#39;&#39;
        # Go directly to property setter to support force
        self.set_idx(self._idx - size, force=force)
        self.lencount -= size
        for i in range(size):
            self.array.pop()

    def rewind(self, size=1):
        self.idx -= size
        self.lencount -= size

    def advance(self, size=1):
        &#39;&#39;&#39; Advances the logical index without touching the underlying buffer

        Keyword Args:
            size (int): How many extra positions to move forward
        &#39;&#39;&#39;
        self.idx += size
        self.lencount += size

    def extend(self, value=NAN, size=0):
        &#39;&#39;&#39; Extends the underlying array with positions that the index will not reach

        Keyword Args:
            value (variable): value to be set in new positins
            size (int): How many extra positions to enlarge the buffer

        The purpose is to allow for lookahead operations or to be able to
        set values in the buffer &#34;future&#34;
        &#39;&#39;&#39;
        self.extension += size
        for i in range(size):
            self.array.append(value)

    def addbinding(self, binding):
        &#39;&#39;&#39; Adds another line binding

        Keyword Args:
            binding (LineBuffer): another line that must be set when this line
            becomes a value
        &#39;&#39;&#39;
        self.bindings.append(binding)
        # record in the binding when the period is starting (never sooner
        # than self)
        binding.updateminperiod(self._minperiod)

    def plot(self, idx=0, size=None):
        &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

        Keyword Args:
            idx (int): Where to start relative to the real start of the buffer
            size(int): size of the slice to return

        This is a variant of getzero which unless told otherwise returns the
        entire buffer, which is usually the idea behind plottint (all must
        plotted)

        Returns:
            A slice of the underlying buffer
        &#39;&#39;&#39;
        return self.getzero(idx, size or len(self))

    def plotrange(self, start, end):
        if self.useislice:
            return list(islice(self.array, start, end))

        return self.array[start:end]

    def oncebinding(self):
        &#39;&#39;&#39;
        Executes the bindings when running in &#34;once&#34; mode
        &#39;&#39;&#39;
        larray = self.array
        blen = self.buflen()
        for binding in self.bindings:
            binding.array[0:blen] = larray[0:blen]

    def bind2lines(self, binding=0):
        &#39;&#39;&#39;
        Stores a binding to another line. &#34;binding&#34; can be an index or a name
        &#39;&#39;&#39;
        if isinstance(binding, string_types):
            line = getattr(self._owner.lines, binding)
        else:
            line = self._owner.lines[binding]

        self.addbinding(line)

        return self

    bind2line = bind2lines

    def __call__(self, ago=None):
        &#39;&#39;&#39;Returns either a delayed verison of itself in the form of a
        LineDelay object or a timeframe adapting version with regards to a ago

        Param: ago (default: None)

          If ago is None or an instance of LineRoot (a lines object) the
          returned valued is a LineCoupler instance

          If ago is anything else, it is assumed to be an int and a LineDelay
          object will be returned
        &#39;&#39;&#39;
        from .lineiterator import LineCoupler
        if ago is None or isinstance(ago, LineRoot):
            return LineCoupler(self, ago)

        return LineDelay(self, ago)

    def _makeoperation(self, other, operation, r=False, _ownerskip=None):
        return LinesOperation(self, other, operation, r=r,
                              _ownerskip=_ownerskip)

    def _makeoperationown(self, operation, _ownerskip=None):
        return LineOwnOperation(self, operation, _ownerskip=_ownerskip)

    def _settz(self, tz):
        self._tz = tz

    def datetime(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive)

    def date(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive).date()

    def time(self, ago=0, tz=None, naive=True):
        return num2date(self.array[self.idx + ago],
                        tz=tz or self._tz, naive=naive).time()

    def dt(self, ago=0):
        &#39;&#39;&#39;
        return numeric date part of datetimefloat
        &#39;&#39;&#39;
        return math.trunc(self.array[self.idx + ago])

    def tm_raw(self, ago=0):
        &#39;&#39;&#39;
        return raw numeric time part of datetimefloat
        &#39;&#39;&#39;
        # This function is named raw because it retrieves the fractional part
        # without transforming it to time to avoid the influence of the day
        # count (integer part of coding)
        return math.modf(self.array[self.idx + ago])[0]

    def tm(self, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To avoid precision errors, this returns the fractional part after
        # having converted it to a datetime.time object to avoid precision
        # errors in comparisons
        return time2num(num2date(self.array[self.idx + ago]).time())

    def tm_lt(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &lt; (dt + other)

    def tm_le(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &lt;= (dt + other)

    def tm_eq(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime == (dt + other)

    def tm_gt(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &gt; (dt + other)

    def tm_ge(self, other, ago=0):
        &#39;&#39;&#39;
        return numeric time part of datetimefloat
        &#39;&#39;&#39;
        # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
        # with the tm of the current datetime, the raw &#34;tm&#34; has to be
        # brought in sync with the current &#34;day&#34; count (integer part) to avoid
        dtime = self.array[self.idx + ago]
        tm, dt = math.modf(dtime)

        return dtime &gt;= (dt + other)

    def tm2dtime(self, tm, ago=0):
        &#39;&#39;&#39;
        Returns the given ``tm`` in the frame of the (ago bars) datatime.

        Useful for external comparisons to avoid precision errors
        &#39;&#39;&#39;
        return int(self.array[self.idx + ago]) + tm

    def tm2datetime(self, tm, ago=0):
        &#39;&#39;&#39;
        Returns the given ``tm`` in the frame of the (ago bars) datatime.

        Useful for external comparisons to avoid precision errors
        &#39;&#39;&#39;
        return num2date(int(self.array[self.idx + ago]) + tm)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.linebuffer.LineBuffer.QBuffer"><code class="name">var <span class="ident">QBuffer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.UnBounded"><code class="name">var <span class="ident">UnBounded</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="backtrader.linebuffer.LineBuffer.idx"><code class="name">var <span class="ident">idx</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_idx(self):
    return self._idx</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.linebuffer.LineBuffer.addbinding"><code class="name flex">
<span>def <span class="ident">addbinding</span></span>(<span>self, binding)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds another line binding</p>
<p>Keyword Args:
binding (LineBuffer): another line that must be set when this line
becomes a value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addbinding(self, binding):
    &#39;&#39;&#39; Adds another line binding

    Keyword Args:
        binding (LineBuffer): another line that must be set when this line
        becomes a value
    &#39;&#39;&#39;
    self.bindings.append(binding)
    # record in the binding when the period is starting (never sooner
    # than self)
    binding.updateminperiod(self._minperiod)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.advance"><code class="name flex">
<span>def <span class="ident">advance</span></span>(<span>self, size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Advances the logical index without touching the underlying buffer</p>
<p>Keyword Args:
size (int): How many extra positions to move forward</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advance(self, size=1):
    &#39;&#39;&#39; Advances the logical index without touching the underlying buffer

    Keyword Args:
        size (int): How many extra positions to move forward
    &#39;&#39;&#39;
    self.idx += size
    self.lencount += size</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.backwards"><code class="name flex">
<span>def <span class="ident">backwards</span></span>(<span>self, size=1, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the logical index backwards and reduces the buffer as much as needed</p>
<p>Keyword Args:
size (int): How many extra positions to rewind and reduce the
buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backwards(self, size=1, force=False):
    &#39;&#39;&#39; Moves the logical index backwards and reduces the buffer as much as needed

    Keyword Args:
        size (int): How many extra positions to rewind and reduce the
        buffer
    &#39;&#39;&#39;
    # Go directly to property setter to support force
    self.set_idx(self._idx - size, force=force)
    self.lencount -= size
    for i in range(size):
        self.array.pop()</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.bind2line"><code class="name flex">
<span>def <span class="ident">bind2line</span></span>(<span>self, binding=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a binding to another line. "binding" can be an index or a name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind2lines(self, binding=0):
    &#39;&#39;&#39;
    Stores a binding to another line. &#34;binding&#34; can be an index or a name
    &#39;&#39;&#39;
    if isinstance(binding, string_types):
        line = getattr(self._owner.lines, binding)
    else:
        line = self._owner.lines[binding]

    self.addbinding(line)

    return self</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.bind2lines"><code class="name flex">
<span>def <span class="ident">bind2lines</span></span>(<span>self, binding=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores a binding to another line. "binding" can be an index or a name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind2lines(self, binding=0):
    &#39;&#39;&#39;
    Stores a binding to another line. &#34;binding&#34; can be an index or a name
    &#39;&#39;&#39;
    if isinstance(binding, string_types):
        line = getattr(self._owner.lines, binding)
    else:
        line = self._owner.lines[binding]

    self.addbinding(line)

    return self</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.buflen"><code class="name flex">
<span>def <span class="ident">buflen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Real data that can be currently held in the internal buffer</p>
<p>The internal buffer can be longer than the actual stored data to
allow for "lookahead" operations. The real amount of data that is
held/can be held in the buffer
is returned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buflen(self):
    &#39;&#39;&#39; Real data that can be currently held in the internal buffer

    The internal buffer can be longer than the actual stored data to
    allow for &#34;lookahead&#34; operations. The real amount of data that is
    held/can be held in the buffer
    is returned
    &#39;&#39;&#39;
    return len(self.array) - self.extension</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.date"><code class="name flex">
<span>def <span class="ident">date</span></span>(<span>self, ago=0, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date(self, ago=0, tz=None, naive=True):
    return num2date(self.array[self.idx + ago],
                    tz=tz or self._tz, naive=naive).date()</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.datetime"><code class="name flex">
<span>def <span class="ident">datetime</span></span>(<span>self, ago=0, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datetime(self, ago=0, tz=None, naive=True):
    return num2date(self.array[self.idx + ago],
                    tz=tz or self._tz, naive=naive)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.dt"><code class="name flex">
<span>def <span class="ident">dt</span></span>(<span>self, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric date part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dt(self, ago=0):
    &#39;&#39;&#39;
    return numeric date part of datetimefloat
    &#39;&#39;&#39;
    return math.trunc(self.array[self.idx + ago])</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, value=nan, size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the underlying array with positions that the index will not reach</p>
<p>Keyword Args:
value (variable): value to be set in new positins
size (int): How many extra positions to enlarge the buffer</p>
<p>The purpose is to allow for lookahead operations or to be able to
set values in the buffer "future"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, value=NAN, size=0):
    &#39;&#39;&#39; Extends the underlying array with positions that the index will not reach

    Keyword Args:
        value (variable): value to be set in new positins
        size (int): How many extra positions to enlarge the buffer

    The purpose is to allow for lookahead operations or to be able to
    set values in the buffer &#34;future&#34;
    &#39;&#39;&#39;
    self.extension += size
    for i in range(size):
        self.array.append(value)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, value=nan, size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the logical index foward and enlarges the buffer as much as needed</p>
<p>Keyword Args:
value (variable): value to be set in new positins
size (int): How many extra positions to enlarge the buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, value=NAN, size=1):
    &#39;&#39;&#39; Moves the logical index foward and enlarges the buffer as much as needed

    Keyword Args:
        value (variable): value to be set in new positins
        size (int): How many extra positions to enlarge the buffer
    &#39;&#39;&#39;
    self.idx += size
    self.lencount += size

    for i in range(size):
        self.array.append(value)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, ago=0, size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a slice of the array relative to <em>ago</em></p>
<p>Keyword Args:
ago (int): Point of the array to which size will be added
to return the slice size(int): size of the slice to return,
can be positive or negative</p>
<p>If size is positive <em>ago</em> will mark the end of the iterable and vice
versa if size is negative</p>
<h2 id="returns">Returns</h2>
<p>A slice of the underlying buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, ago=0, size=1):
    &#39;&#39;&#39; Returns a slice of the array relative to *ago*

    Keyword Args:
        ago (int): Point of the array to which size will be added
        to return the slice size(int): size of the slice to return,
        can be positive or negative

    If size is positive *ago* will mark the end of the iterable and vice
    versa if size is negative

    Returns:
        A slice of the underlying buffer
    &#39;&#39;&#39;
    if self.useislice:
        start = self.idx + ago - size + 1
        end = self.idx + ago + 1
        return list(islice(self.array, start, end))

    return self.array[self.idx + ago - size + 1:self.idx + ago + 1]</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.get_idx"><code class="name flex">
<span>def <span class="ident">get_idx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_idx(self):
    return self._idx</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.getindicators"><code class="name flex">
<span>def <span class="ident">getindicators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getindicators(self):
    return []</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.getzero"><code class="name flex">
<span>def <span class="ident">getzero</span></span>(<span>self, idx=0, size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a slice of the array relative to the real zero of the buffer</p>
<p>Keyword Args:
idx (int): Where to start relative to the real start of the buffer
size(int): size of the slice to return</p>
<h2 id="returns">Returns</h2>
<p>A slice of the underlying buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getzero(self, idx=0, size=1):
    &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

    Keyword Args:
        idx (int): Where to start relative to the real start of the buffer
        size(int): size of the slice to return

    Returns:
        A slice of the underlying buffer
    &#39;&#39;&#39;
    if self.useislice:
        return list(islice(self.array, idx, idx + size))

    return self.array[idx:idx + size]</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.getzeroval"><code class="name flex">
<span>def <span class="ident">getzeroval</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a single value of the array relative to the real zero
of the buffer</p>
<p>Keyword Args:
idx (int): Where to start relative to the real start of the buffer
size(int): size of the slice to return</p>
<h2 id="returns">Returns</h2>
<p>A slice of the underlying buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getzeroval(self, idx=0):
    &#39;&#39;&#39; Returns a single value of the array relative to the real zero
    of the buffer

    Keyword Args:
        idx (int): Where to start relative to the real start of the buffer
        size(int): size of the slice to return

    Returns:
        A slice of the underlying buffer
    &#39;&#39;&#39;
    return self.array[idx]</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.home"><code class="name flex">
<span>def <span class="ident">home</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rewinds the logical index to the beginning</p>
<p>The underlying buffer remains untouched and the actual len can be found
out with buflen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def home(self):
    &#39;&#39;&#39; Rewinds the logical index to the beginning

    The underlying buffer remains untouched and the actual len can be found
    out with buflen
    &#39;&#39;&#39;
    self.idx = -1
    self.lencount = 0</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.minbuffer"><code class="name flex">
<span>def <span class="ident">minbuffer</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>The linebuffer must guarantee the minimum requested size to be
available.</p>
<p>In non-dqbuffer mode, this is always true (of course until data is
filled at the beginning, there are less values, but minperiod in the
framework should account for this.</p>
<p>In dqbuffer mode the buffer has to be adjusted for this if currently
less than requested</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minbuffer(self, size):
    &#39;&#39;&#39;The linebuffer must guarantee the minimum requested size to be
    available.

    In non-dqbuffer mode, this is always true (of course until data is
    filled at the beginning, there are less values, but minperiod in the
    framework should account for this.

    In dqbuffer mode the buffer has to be adjusted for this if currently
    less than requested
    &#39;&#39;&#39;
    if self.mode != self.QBuffer or self.maxlen &gt;= size:
        return

    self.maxlen = size
    self.lenmark = self.maxlen - (not self.extrasize)
    self.reset()</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.oncebinding"><code class="name flex">
<span>def <span class="ident">oncebinding</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes the bindings when running in "once" mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oncebinding(self):
    &#39;&#39;&#39;
    Executes the bindings when running in &#34;once&#34; mode
    &#39;&#39;&#39;
    larray = self.array
    blen = self.buflen()
    for binding in self.bindings:
        binding.array[0:blen] = larray[0:blen]</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, idx=0, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a slice of the array relative to the real zero of the buffer</p>
<p>Keyword Args:
idx (int): Where to start relative to the real start of the buffer
size(int): size of the slice to return</p>
<p>This is a variant of getzero which unless told otherwise returns the
entire buffer, which is usually the idea behind plottint (all must
plotted)</p>
<h2 id="returns">Returns</h2>
<p>A slice of the underlying buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, idx=0, size=None):
    &#39;&#39;&#39; Returns a slice of the array relative to the real zero of the buffer

    Keyword Args:
        idx (int): Where to start relative to the real start of the buffer
        size(int): size of the slice to return

    This is a variant of getzero which unless told otherwise returns the
    entire buffer, which is usually the idea behind plottint (all must
    plotted)

    Returns:
        A slice of the underlying buffer
    &#39;&#39;&#39;
    return self.getzero(idx, size or len(self))</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.plotrange"><code class="name flex">
<span>def <span class="ident">plotrange</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotrange(self, start, end):
    if self.useislice:
        return list(islice(self.array, start, end))

    return self.array[start:end]</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the internal buffer structure and the indices</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39; Resets the internal buffer structure and the indices
    &#39;&#39;&#39;
    if self.mode == self.QBuffer:
        # add extrasize to ensure resample/replay work because they will
        # use backwards to erase the last bar/tick before delivering a new
        # bar The previous forward would have discarded the bar &#34;period&#34;
        # times ago and it will not come back. Having + 1 in the size
        # allows the forward without removing that bar
        self.array = collections.deque(maxlen=self.maxlen + self.extrasize)
        self.useislice = True
    else:
        self.array = array.array(str(&#39;d&#39;))
        self.useislice = False

    self.lencount = 0
    self.idx = -1
    self.extension = 0</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self, size=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self, size=1):
    self.idx -= size
    self.lencount -= size</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a value at position "ago" and executes any associated bindings</p>
<p>Keyword Args:
value (variable): value to be set
ago (int): Point of the array to which size will be added to return
the slice</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value, ago=0):
    &#39;&#39;&#39; Sets a value at position &#34;ago&#34; and executes any associated bindings

    Keyword Args:
        value (variable): value to be set
        ago (int): Point of the array to which size will be added to return
        the slice
    &#39;&#39;&#39;
    self.array[self.idx + ago] = value
    for binding in self.bindings:
        binding[ago] = value</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.set_idx"><code class="name flex">
<span>def <span class="ident">set_idx</span></span>(<span>self, idx, force=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_idx(self, idx, force=False):
    # if QBuffer and the last position of the buffer was reached, keep
    # it (unless force) as index 0. This allows resampling
    #  - forward adds a position, but the 1st one is discarded, the 0 is
    #  invariant
    # force supports replaying, which needs the extra bar to float
    # forward/backwards, because the last input is read, and after a
    # &#34;backwards&#34; is used to update the previous data. Unless the position
    # 0 was moved to the previous index, it would fail
    if self.mode == self.QBuffer:
        if force or self._idx &lt; self.lenmark:
            self._idx = idx
    else:  # default: UnBounded
        self._idx = idx</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.time"><code class="name flex">
<span>def <span class="ident">time</span></span>(<span>self, ago=0, tz=None, naive=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time(self, ago=0, tz=None, naive=True):
    return num2date(self.array[self.idx + ago],
                    tz=tz or self._tz, naive=naive).time()</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm"><code class="name flex">
<span>def <span class="ident">tm</span></span>(<span>self, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm(self, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To avoid precision errors, this returns the fractional part after
    # having converted it to a datetime.time object to avoid precision
    # errors in comparisons
    return time2num(num2date(self.array[self.idx + ago]).time())</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm2datetime"><code class="name flex">
<span>def <span class="ident">tm2datetime</span></span>(<span>self, tm, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the given <code>tm</code> in the frame of the (ago bars) datatime.</p>
<p>Useful for external comparisons to avoid precision errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm2datetime(self, tm, ago=0):
    &#39;&#39;&#39;
    Returns the given ``tm`` in the frame of the (ago bars) datatime.

    Useful for external comparisons to avoid precision errors
    &#39;&#39;&#39;
    return num2date(int(self.array[self.idx + ago]) + tm)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm2dtime"><code class="name flex">
<span>def <span class="ident">tm2dtime</span></span>(<span>self, tm, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the given <code>tm</code> in the frame of the (ago bars) datatime.</p>
<p>Useful for external comparisons to avoid precision errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm2dtime(self, tm, ago=0):
    &#39;&#39;&#39;
    Returns the given ``tm`` in the frame of the (ago bars) datatime.

    Useful for external comparisons to avoid precision errors
    &#39;&#39;&#39;
    return int(self.array[self.idx + ago]) + tm</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_eq"><code class="name flex">
<span>def <span class="ident">tm_eq</span></span>(<span>self, other, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_eq(self, other, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
    # with the tm of the current datetime, the raw &#34;tm&#34; has to be
    # brought in sync with the current &#34;day&#34; count (integer part) to avoid
    dtime = self.array[self.idx + ago]
    tm, dt = math.modf(dtime)

    return dtime == (dt + other)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_ge"><code class="name flex">
<span>def <span class="ident">tm_ge</span></span>(<span>self, other, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_ge(self, other, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
    # with the tm of the current datetime, the raw &#34;tm&#34; has to be
    # brought in sync with the current &#34;day&#34; count (integer part) to avoid
    dtime = self.array[self.idx + ago]
    tm, dt = math.modf(dtime)

    return dtime &gt;= (dt + other)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_gt"><code class="name flex">
<span>def <span class="ident">tm_gt</span></span>(<span>self, other, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_gt(self, other, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
    # with the tm of the current datetime, the raw &#34;tm&#34; has to be
    # brought in sync with the current &#34;day&#34; count (integer part) to avoid
    dtime = self.array[self.idx + ago]
    tm, dt = math.modf(dtime)

    return dtime &gt; (dt + other)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_le"><code class="name flex">
<span>def <span class="ident">tm_le</span></span>(<span>self, other, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_le(self, other, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
    # with the tm of the current datetime, the raw &#34;tm&#34; has to be
    # brought in sync with the current &#34;day&#34; count (integer part) to avoid
    dtime = self.array[self.idx + ago]
    tm, dt = math.modf(dtime)

    return dtime &lt;= (dt + other)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_lt"><code class="name flex">
<span>def <span class="ident">tm_lt</span></span>(<span>self, other, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_lt(self, other, ago=0):
    &#39;&#39;&#39;
    return numeric time part of datetimefloat
    &#39;&#39;&#39;
    # To compare a raw &#34;tm&#34; part (fractional part of coded datetime)
    # with the tm of the current datetime, the raw &#34;tm&#34; has to be
    # brought in sync with the current &#34;day&#34; count (integer part) to avoid
    dtime = self.array[self.idx + ago]
    tm, dt = math.modf(dtime)

    return dtime &lt; (dt + other)</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.LineBuffer.tm_raw"><code class="name flex">
<span>def <span class="ident">tm_raw</span></span>(<span>self, ago=0)</span>
</code></dt>
<dd>
<div class="desc"><p>return raw numeric time part of datetimefloat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm_raw(self, ago=0):
    &#39;&#39;&#39;
    return raw numeric time part of datetimefloat
    &#39;&#39;&#39;
    # This function is named raw because it retrieves the fractional part
    # without transforming it to time to avoid the influence of the day
    # count (integer part of coding)
    return math.modf(self.array[self.idx + ago])[0]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineroot.LineSingle.addminperiod" href="lineroot.html#backtrader.lineroot.LineSingle.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.incminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.next" href="lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.nextstart" href="lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.prenext" href="lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineroot.LineSingle.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.linebuffer.LineOwnOperation"><code class="flex name class">
<span>class <span class="ident">LineOwnOperation</span></span>
<span>(</span><span>a, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds an operation that operates on a single operand. Example: abs</p>
<p>It will "next"/traverse the array applying the operation and storing
the result in self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineOwnOperation(LineActions):
    &#39;&#39;&#39;
    Holds an operation that operates on a single operand. Example: abs

    It will &#34;next&#34;/traverse the array applying the operation and storing
    the result in self
    &#39;&#39;&#39;
    def __init__(self, a, operation):
        super(LineOwnOperation, self).__init__()

        self.operation = operation
        self.a = a

    def next(self):
        self[0] = self.operation(self.a[0])

    def once(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></li>
<li><a title="backtrader.linebuffer.LineBuffer" href="#backtrader.linebuffer.LineBuffer">LineBuffer</a></li>
<li><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.linebuffer.LineOwnOperation.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineOwnOperation.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LineOwnOperation.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.linebuffer.LineActions.addbinding" href="#backtrader.linebuffer.LineBuffer.addbinding">addbinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.addminperiod" href="lineroot.html#backtrader.lineroot.LineSingle.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.advance" href="#backtrader.linebuffer.LineBuffer.advance">advance</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.backwards" href="#backtrader.linebuffer.LineBuffer.backwards">backwards</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2line" href="#backtrader.linebuffer.LineBuffer.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2lines" href="#backtrader.linebuffer.LineBuffer.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.buflen" href="#backtrader.linebuffer.LineBuffer.buflen">buflen</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.dt" href="#backtrader.linebuffer.LineBuffer.dt">dt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.extend" href="#backtrader.linebuffer.LineBuffer.extend">extend</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.forward" href="#backtrader.linebuffer.LineBuffer.forward">forward</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.get" href="#backtrader.linebuffer.LineBuffer.get">get</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzero" href="#backtrader.linebuffer.LineBuffer.getzero">getzero</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzeroval" href="#backtrader.linebuffer.LineBuffer.getzeroval">getzeroval</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.home" href="#backtrader.linebuffer.LineBuffer.home">home</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.incminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.minbuffer" href="#backtrader.linebuffer.LineBuffer.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.next" href="lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.nextstart" href="lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncebinding" href="#backtrader.linebuffer.LineBuffer.oncebinding">oncebinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.plot" href="#backtrader.linebuffer.LineBuffer.plot">plot</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.prenext" href="lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.reset" href="#backtrader.linebuffer.LineBuffer.reset">reset</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.set" href="#backtrader.linebuffer.LineBuffer.set">set</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm" href="#backtrader.linebuffer.LineBuffer.tm">tm</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2datetime" href="#backtrader.linebuffer.LineBuffer.tm2datetime">tm2datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2dtime" href="#backtrader.linebuffer.LineBuffer.tm2dtime">tm2dtime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_eq" href="#backtrader.linebuffer.LineBuffer.tm_eq">tm_eq</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_ge" href="#backtrader.linebuffer.LineBuffer.tm_ge">tm_ge</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_gt" href="#backtrader.linebuffer.LineBuffer.tm_gt">tm_gt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_le" href="#backtrader.linebuffer.LineBuffer.tm_le">tm_le</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_lt" href="#backtrader.linebuffer.LineBuffer.tm_lt">tm_lt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_raw" href="#backtrader.linebuffer.LineBuffer.tm_raw">tm_raw</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.linebuffer.LinesOperation"><code class="flex name class">
<span>class <span class="ident">LinesOperation</span></span>
<span>(</span><span>a, b, operation, r=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds an operation that operates on a two operands. Example: mul</p>
<p>It will "next"/traverse the array applying the operation on the
two operands and storing the result in self.</p>
<p>To optimize the operations and avoid conditional checks the right
next/once is chosen using the operation direction (normal or reversed)
and the nature of the operands (LineBuffer vs non-LineBuffer)</p>
<p>In the "once" operations "map" could be used as in:</p>
<pre><code>operated = map(self.operation, srca[start:end], srcb[start:end])
self.array[start:end] = array.array(str(self.typecode), operated)
</code></pre>
<p>No real execution time benefits were appreciated and therefore the loops
have been kept in place for clarity (although the maps are not really
unclear here)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinesOperation(LineActions):

    &#39;&#39;&#39;
    Holds an operation that operates on a two operands. Example: mul

    It will &#34;next&#34;/traverse the array applying the operation on the
    two operands and storing the result in self.

    To optimize the operations and avoid conditional checks the right
    next/once is chosen using the operation direction (normal or reversed)
    and the nature of the operands (LineBuffer vs non-LineBuffer)

    In the &#34;once&#34; operations &#34;map&#34; could be used as in:

        operated = map(self.operation, srca[start:end], srcb[start:end])
        self.array[start:end] = array.array(str(self.typecode), operated)

    No real execution time benefits were appreciated and therefore the loops
    have been kept in place for clarity (although the maps are not really
    unclear here)
    &#39;&#39;&#39;

    def __init__(self, a, b, operation, r=False):
        super(LinesOperation, self).__init__()

        self.operation = operation
        self.a = a  # always a linebuffer
        self.b = b

        self.r = r
        self.bline = isinstance(b, LineBuffer)
        self.btime = isinstance(b, datetime.time)
        self.bfloat = not self.bline and not self.btime

        if r:
            self.a, self.b = b, a

    def next(self):
        if self.bline:
            self[0] = self.operation(self.a[0], self.b[0])
        elif not self.r:
            if not self.btime:
                self[0] = self.operation(self.a[0], self.b)
            else:
                self[0] = self.operation(self.a.time(), self.b)
        else:
            self[0] = self.operation(self.a, self.b[0])

    def once(self, start, end):
        if self.bline:
            self._once_op(start, end)
        elif not self.r:
            if not self.btime:
                self._once_val_op(start, end)
            else:
                self._once_time_op(start, end)
        else:
            self._once_val_op_r(start, end)

    def _once_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i], srcb[i])

    def _once_time_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b
        op = self.operation
        tz = self._tz

        for i in range(start, end):
            dst[i] = op(num2date(srca[i], tz=tz).time(), srcb)

    def _once_val_op(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a.array
        srcb = self.b
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca[i], srcb)

    def _once_val_op_r(self, start, end):
        # cache python dictionary lookups
        dst = self.array
        srca = self.a
        srcb = self.b.array
        op = self.operation

        for i in range(start, end):
            dst[i] = op(srca, srcb[i])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></li>
<li><a title="backtrader.linebuffer.LineBuffer" href="#backtrader.linebuffer.LineBuffer">LineBuffer</a></li>
<li><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.linebuffer.LinesOperation.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LinesOperation.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.linebuffer.LinesOperation.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.linebuffer.LineActions.addbinding" href="#backtrader.linebuffer.LineBuffer.addbinding">addbinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.addminperiod" href="lineroot.html#backtrader.lineroot.LineSingle.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.advance" href="#backtrader.linebuffer.LineBuffer.advance">advance</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.backwards" href="#backtrader.linebuffer.LineBuffer.backwards">backwards</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2line" href="#backtrader.linebuffer.LineBuffer.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2lines" href="#backtrader.linebuffer.LineBuffer.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.buflen" href="#backtrader.linebuffer.LineBuffer.buflen">buflen</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.dt" href="#backtrader.linebuffer.LineBuffer.dt">dt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.extend" href="#backtrader.linebuffer.LineBuffer.extend">extend</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.forward" href="#backtrader.linebuffer.LineBuffer.forward">forward</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.get" href="#backtrader.linebuffer.LineBuffer.get">get</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzero" href="#backtrader.linebuffer.LineBuffer.getzero">getzero</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzeroval" href="#backtrader.linebuffer.LineBuffer.getzeroval">getzeroval</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.home" href="#backtrader.linebuffer.LineBuffer.home">home</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.incminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.minbuffer" href="#backtrader.linebuffer.LineBuffer.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.next" href="lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.nextstart" href="lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncebinding" href="#backtrader.linebuffer.LineBuffer.oncebinding">oncebinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.plot" href="#backtrader.linebuffer.LineBuffer.plot">plot</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.prenext" href="lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.reset" href="#backtrader.linebuffer.LineBuffer.reset">reset</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.set" href="#backtrader.linebuffer.LineBuffer.set">set</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm" href="#backtrader.linebuffer.LineBuffer.tm">tm</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2datetime" href="#backtrader.linebuffer.LineBuffer.tm2datetime">tm2datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2dtime" href="#backtrader.linebuffer.LineBuffer.tm2dtime">tm2dtime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_eq" href="#backtrader.linebuffer.LineBuffer.tm_eq">tm_eq</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_ge" href="#backtrader.linebuffer.LineBuffer.tm_ge">tm_ge</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_gt" href="#backtrader.linebuffer.LineBuffer.tm_gt">tm_gt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_le" href="#backtrader.linebuffer.LineBuffer.tm_le">tm_le</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_lt" href="#backtrader.linebuffer.LineBuffer.tm_lt">tm_lt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_raw" href="#backtrader.linebuffer.LineBuffer.tm_raw">tm_raw</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.linebuffer.MetaLineActions"><code class="flex name class">
<span>class <span class="ident">MetaLineActions</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Metaclass for Lineactions</p>
<p>Scans the instance before init for LineBuffer (or parentclass LineSingle)
instances to calculate the minperiod for this instance</p>
<p>postinit it registers the instance to the owner (remember that owner has
been found in the base Metaclass for LineRoot)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaLineActions(LineBuffer.__class__):
    &#39;&#39;&#39;
    Metaclass for Lineactions

    Scans the instance before init for LineBuffer (or parentclass LineSingle)
    instances to calculate the minperiod for this instance

    postinit it registers the instance to the owner (remember that owner has
    been found in the base Metaclass for LineRoot)
    &#39;&#39;&#39;
    _acache = dict()
    _acacheuse = False

    @classmethod
    def cleancache(cls):
        cls._acache = dict()

    @classmethod
    def usecache(cls, onoff):
        cls._acacheuse = onoff

    def __call__(cls, *args, **kwargs):
        if not cls._acacheuse:
            return super(MetaLineActions, cls).__call__(*args, **kwargs)

        # implement a cache to avoid duplicating lines actions
        ckey = (cls, tuple(args), tuple(kwargs.items()))  # tuples hashable
        try:
            return cls._acache[ckey]
        except TypeError:  # something not hashable
            return super(MetaLineActions, cls).__call__(*args, **kwargs)
        except KeyError:
            pass  # hashable but not in the cache

        _obj = super(MetaLineActions, cls).__call__(*args, **kwargs)
        return cls._acache.setdefault(ckey, _obj)

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineActions, cls).dopreinit(_obj, *args, **kwargs)

        _obj._clock = _obj._owner  # default setting

        if isinstance(args[0], LineRoot):
            _obj._clock = args[0]

        # Keep a reference to the datas for buffer adjustment purposes
        _obj._datas = [x for x in args if isinstance(x, LineRoot)]

        # Do not produce anything until the operation lines produce something
        _minperiods = [x._minperiod for x in args if isinstance(x, LineSingle)]

        mlines = [x.lines[0] for x in args if isinstance(x, LineMultiple)]
        _minperiods += [x._minperiod for x in mlines]

        _minperiod = max(_minperiods or [1])

        # update own minperiod if needed
        _obj.updateminperiod(_minperiod)

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineActions, cls).dopostinit(_obj, *args, **kwargs)

        # register with _owner to be kicked later
        _obj._owner.addindicator(_obj)

        return _obj, args, kwargs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineroot.MetaLineRoot" href="lineroot.html#backtrader.lineroot.MetaLineRoot">MetaLineRoot</a></li>
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="backtrader.linebuffer.MetaLineActions.cleancache"><code class="name flex">
<span>def <span class="ident">cleancache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cleancache(cls):
    cls._acache = dict()</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.MetaLineActions.usecache"><code class="name flex">
<span>def <span class="ident">usecache</span></span>(<span>onoff)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def usecache(cls, onoff):
    cls._acacheuse = onoff</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.linebuffer.MetaLineActions.dopostinit"><code class="name flex">
<span>def <span class="ident">dopostinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopostinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaLineActions, cls).dopostinit(_obj, *args, **kwargs)

    # register with _owner to be kicked later
    _obj._owner.addindicator(_obj)

    return _obj, args, kwargs</code></pre>
</details>
</dd>
<dt id="backtrader.linebuffer.MetaLineActions.dopreinit"><code class="name flex">
<span>def <span class="ident">dopreinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopreinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaLineActions, cls).dopreinit(_obj, *args, **kwargs)

    _obj._clock = _obj._owner  # default setting

    if isinstance(args[0], LineRoot):
        _obj._clock = args[0]

    # Keep a reference to the datas for buffer adjustment purposes
    _obj._datas = [x for x in args if isinstance(x, LineRoot)]

    # Do not produce anything until the operation lines produce something
    _minperiods = [x._minperiod for x in args if isinstance(x, LineSingle)]

    mlines = [x.lines[0] for x in args if isinstance(x, LineMultiple)]
    _minperiods += [x._minperiod for x in mlines]

    _minperiod = max(_minperiods or [1])

    # update own minperiod if needed
    _obj.updateminperiod(_minperiod)

    return _obj, args, kwargs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.linebuffer.PseudoArray"><code class="flex name class">
<span>class <span class="ident">PseudoArray</span></span>
<span>(</span><span>wrapped)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PseudoArray(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def __getitem__(self, key):
        return self.wrapped

    @property
    def array(self):
        return self</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="backtrader.linebuffer.PseudoArray.array"><code class="name">var <span class="ident">array</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def array(self):
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backtrader.linebuffer.LineDelay" href="#backtrader.linebuffer.LineDelay">LineDelay</a></code></li>
<li><code><a title="backtrader.linebuffer.LineNum" href="#backtrader.linebuffer.LineNum">LineNum</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.linebuffer.LineActions" href="#backtrader.linebuffer.LineActions">LineActions</a></code></h4>
<ul class="">
<li><code><a title="backtrader.linebuffer.LineActions.arrayize" href="#backtrader.linebuffer.LineActions.arrayize">arrayize</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.frompackages" href="#backtrader.linebuffer.LineActions.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getindicators" href="#backtrader.linebuffer.LineActions.getindicators">getindicators</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.packages" href="#backtrader.linebuffer.LineActions.packages">packages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.params" href="#backtrader.linebuffer.LineActions.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.linebuffer.LineBuffer" href="#backtrader.linebuffer.LineBuffer">LineBuffer</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.linebuffer.LineBuffer.QBuffer" href="#backtrader.linebuffer.LineBuffer.QBuffer">QBuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.UnBounded" href="#backtrader.linebuffer.LineBuffer.UnBounded">UnBounded</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.addbinding" href="#backtrader.linebuffer.LineBuffer.addbinding">addbinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.advance" href="#backtrader.linebuffer.LineBuffer.advance">advance</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.backwards" href="#backtrader.linebuffer.LineBuffer.backwards">backwards</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.bind2line" href="#backtrader.linebuffer.LineBuffer.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.bind2lines" href="#backtrader.linebuffer.LineBuffer.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.buflen" href="#backtrader.linebuffer.LineBuffer.buflen">buflen</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.date" href="#backtrader.linebuffer.LineBuffer.date">date</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.datetime" href="#backtrader.linebuffer.LineBuffer.datetime">datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.dt" href="#backtrader.linebuffer.LineBuffer.dt">dt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.extend" href="#backtrader.linebuffer.LineBuffer.extend">extend</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.forward" href="#backtrader.linebuffer.LineBuffer.forward">forward</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.frompackages" href="#backtrader.linebuffer.LineBuffer.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.get" href="#backtrader.linebuffer.LineBuffer.get">get</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.get_idx" href="#backtrader.linebuffer.LineBuffer.get_idx">get_idx</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.getindicators" href="#backtrader.linebuffer.LineBuffer.getindicators">getindicators</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.getzero" href="#backtrader.linebuffer.LineBuffer.getzero">getzero</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.getzeroval" href="#backtrader.linebuffer.LineBuffer.getzeroval">getzeroval</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.home" href="#backtrader.linebuffer.LineBuffer.home">home</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.idx" href="#backtrader.linebuffer.LineBuffer.idx">idx</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.minbuffer" href="#backtrader.linebuffer.LineBuffer.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.oncebinding" href="#backtrader.linebuffer.LineBuffer.oncebinding">oncebinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.packages" href="#backtrader.linebuffer.LineBuffer.packages">packages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.params" href="#backtrader.linebuffer.LineBuffer.params">params</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.plot" href="#backtrader.linebuffer.LineBuffer.plot">plot</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.plotrange" href="#backtrader.linebuffer.LineBuffer.plotrange">plotrange</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.reset" href="#backtrader.linebuffer.LineBuffer.reset">reset</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.rewind" href="#backtrader.linebuffer.LineBuffer.rewind">rewind</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.set" href="#backtrader.linebuffer.LineBuffer.set">set</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.set_idx" href="#backtrader.linebuffer.LineBuffer.set_idx">set_idx</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.time" href="#backtrader.linebuffer.LineBuffer.time">time</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm" href="#backtrader.linebuffer.LineBuffer.tm">tm</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm2datetime" href="#backtrader.linebuffer.LineBuffer.tm2datetime">tm2datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm2dtime" href="#backtrader.linebuffer.LineBuffer.tm2dtime">tm2dtime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_eq" href="#backtrader.linebuffer.LineBuffer.tm_eq">tm_eq</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_ge" href="#backtrader.linebuffer.LineBuffer.tm_ge">tm_ge</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_gt" href="#backtrader.linebuffer.LineBuffer.tm_gt">tm_gt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_le" href="#backtrader.linebuffer.LineBuffer.tm_le">tm_le</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_lt" href="#backtrader.linebuffer.LineBuffer.tm_lt">tm_lt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineBuffer.tm_raw" href="#backtrader.linebuffer.LineBuffer.tm_raw">tm_raw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.linebuffer.LineOwnOperation" href="#backtrader.linebuffer.LineOwnOperation">LineOwnOperation</a></code></h4>
<ul class="">
<li><code><a title="backtrader.linebuffer.LineOwnOperation.frompackages" href="#backtrader.linebuffer.LineOwnOperation.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineOwnOperation.packages" href="#backtrader.linebuffer.LineOwnOperation.packages">packages</a></code></li>
<li><code><a title="backtrader.linebuffer.LineOwnOperation.params" href="#backtrader.linebuffer.LineOwnOperation.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.linebuffer.LinesOperation" href="#backtrader.linebuffer.LinesOperation">LinesOperation</a></code></h4>
<ul class="">
<li><code><a title="backtrader.linebuffer.LinesOperation.frompackages" href="#backtrader.linebuffer.LinesOperation.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.linebuffer.LinesOperation.packages" href="#backtrader.linebuffer.LinesOperation.packages">packages</a></code></li>
<li><code><a title="backtrader.linebuffer.LinesOperation.params" href="#backtrader.linebuffer.LinesOperation.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.linebuffer.MetaLineActions" href="#backtrader.linebuffer.MetaLineActions">MetaLineActions</a></code></h4>
<ul class="">
<li><code><a title="backtrader.linebuffer.MetaLineActions.cleancache" href="#backtrader.linebuffer.MetaLineActions.cleancache">cleancache</a></code></li>
<li><code><a title="backtrader.linebuffer.MetaLineActions.dopostinit" href="#backtrader.linebuffer.MetaLineActions.dopostinit">dopostinit</a></code></li>
<li><code><a title="backtrader.linebuffer.MetaLineActions.dopreinit" href="#backtrader.linebuffer.MetaLineActions.dopreinit">dopreinit</a></code></li>
<li><code><a title="backtrader.linebuffer.MetaLineActions.usecache" href="#backtrader.linebuffer.MetaLineActions.usecache">usecache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.linebuffer.PseudoArray" href="#backtrader.linebuffer.PseudoArray">PseudoArray</a></code></h4>
<ul class="">
<li><code><a title="backtrader.linebuffer.PseudoArray.array" href="#backtrader.linebuffer.PseudoArray.array">array</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>