<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.analyzer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.analyzer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import calendar
from collections import OrderedDict
import datetime
import pprint as pp

import backtrader as bt
from backtrader import TimeFrame
from backtrader.utils.py3 import MAXINT, with_metaclass


class MetaAnalyzer(bt.MetaParams):
    def donew(cls, *args, **kwargs):
        &#39;&#39;&#39;
        Intercept the strategy parameter
        &#39;&#39;&#39;
        # Create the object and set the params in place
        _obj, args, kwargs = super(MetaAnalyzer, cls).donew(*args, **kwargs)

        _obj._children = list()

        _obj.strategy = strategy = bt.metabase.findowner(_obj, bt.Strategy)
        _obj._parent = bt.metabase.findowner(_obj, Analyzer)

        # Register with a master observer if created inside one
        masterobs = bt.metabase.findowner(_obj, bt.Observer)
        if masterobs is not None:
            masterobs._register_analyzer(_obj)

        _obj.datas = strategy.datas

        # For each data add aliases: for first data: data and data0
        if _obj.datas:
            _obj.data = data = _obj.datas[0]

            for l, line in enumerate(data.lines):
                linealias = data._getlinealias(l)
                if linealias:
                    setattr(_obj, &#39;data_%s&#39; % linealias, line)
                setattr(_obj, &#39;data_%d&#39; % l, line)

            for d, data in enumerate(_obj.datas):
                setattr(_obj, &#39;data%d&#39; % d, data)

                for l, line in enumerate(data.lines):
                    linealias = data._getlinealias(l)
                    if linealias:
                        setattr(_obj, &#39;data%d_%s&#39; % (d, linealias), line)
                    setattr(_obj, &#39;data%d_%d&#39; % (d, l), line)

        _obj.create_analysis()

        # Return to the normal chain
        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaAnalyzer, cls).dopostinit(_obj, *args, **kwargs)

        if _obj._parent is not None:
            _obj._parent._register(_obj)

        # Return to the normal chain
        return _obj, args, kwargs


class Analyzer(with_metaclass(MetaAnalyzer, object)):
    &#39;&#39;&#39;Analyzer base class. All analyzers are subclass of this one

    An Analyzer instance operates in the frame of a strategy and provides an
    analysis for that strategy.

    Automagically set member attributes:

      - ``self.strategy`` (giving access to the *strategy* and anything
        accessible from it)

      - ``self.datas[x]`` giving access to the array of data feeds present in
        the the system, which could also be accessed via the strategy reference

      - ``self.data``, giving access to ``self.datas[0]``

      - ``self.dataX`` -&gt; ``self.datas[X]``

      - ``self.dataX_Y`` -&gt; ``self.datas[X].lines[Y]``

      - ``self.dataX_name`` -&gt; ``self.datas[X].name``

      - ``self.data_name`` -&gt; ``self.datas[0].name``

      - ``self.data_Y`` -&gt; ``self.datas[0].lines[Y]``

    This is not a *Lines* object, but the methods and operation follow the same
    design

      - ``__init__`` during instantiation and initial setup

      - ``start`` / ``stop`` to signal the begin and end of operations

      - ``prenext`` / ``nextstart`` / ``next`` family of methods that follow
        the calls made to the same methods in the strategy

      - ``notify_trade`` / ``notify_order`` / ``notify_cashvalue`` /
        ``notify_fund`` which receive the same notifications as the equivalent
        methods of the strategy

    The mode of operation is open and no pattern is preferred. As such the
    analysis can be generated with the ``next`` calls, at the end of operations
    during ``stop`` and even with a single method like ``notify_trade``

    The important thing is to override ``get_analysis`` to return a *dict-like*
    object containing the results of the analysis (the actual format is
    implementation dependent)

    &#39;&#39;&#39;
    csv = True

    def __len__(self):
        &#39;&#39;&#39;Support for invoking ``len`` on analyzers by actually returning the
        current length of the strategy the analyzer operates on&#39;&#39;&#39;
        return len(self.strategy)

    def _register(self, child):
        self._children.append(child)

    def _prenext(self):
        for child in self._children:
            child._prenext()

        self.prenext()

    def _notify_cashvalue(self, cash, value):
        for child in self._children:
            child._notify_cashvalue(cash, value)

        self.notify_cashvalue(cash, value)

    def _notify_fund(self, cash, value, fundvalue, shares):
        for child in self._children:
            child._notify_fund(cash, value, fundvalue, shares)

        self.notify_fund(cash, value, fundvalue, shares)

    def _notify_trade(self, trade):
        for child in self._children:
            child._notify_trade(trade)

        self.notify_trade(trade)

    def _notify_order(self, order):
        for child in self._children:
            child._notify_order(order)

        self.notify_order(order)

    def _nextstart(self):
        for child in self._children:
            child._nextstart()

        self.nextstart()

    def _next(self):
        for child in self._children:
            child._next()

        self.next()

    def _start(self):
        for child in self._children:
            child._start()

        self.start()

    def _stop(self):
        for child in self._children:
            child._stop()

        self.stop()

    def notify_cashvalue(self, cash, value):
        &#39;&#39;&#39;Receives the cash/value notification before each next cycle&#39;&#39;&#39;
        pass

    def notify_fund(self, cash, value, fundvalue, shares):
        &#39;&#39;&#39;Receives the current cash, value, fundvalue and fund shares&#39;&#39;&#39;
        pass

    def notify_order(self, order):
        &#39;&#39;&#39;Receives order notifications before each next cycle&#39;&#39;&#39;
        pass

    def notify_trade(self, trade):
        &#39;&#39;&#39;Receives trade notifications before each next cycle&#39;&#39;&#39;
        pass

    def next(self):
        &#39;&#39;&#39;Invoked for each next invocation of the strategy, once the minum
        preiod of the strategy has been reached&#39;&#39;&#39;
        pass

    def prenext(self):
        &#39;&#39;&#39;Invoked for each prenext invocation of the strategy, until the minimum
        period of the strategy has been reached

        The default behavior for an analyzer is to invoke ``next``
        &#39;&#39;&#39;
        self.next()

    def nextstart(self):
        &#39;&#39;&#39;Invoked exactly once for the nextstart invocation of the strategy,
        when the minimum period has been first reached
        &#39;&#39;&#39;
        self.next()

    def start(self):
        &#39;&#39;&#39;Invoked to indicate the start of operations, giving the analyzer
        time to setup up needed things&#39;&#39;&#39;
        pass

    def stop(self):
        &#39;&#39;&#39;Invoked to indicate the end of operations, giving the analyzer
        time to shut down needed things&#39;&#39;&#39;
        pass

    def create_analysis(self):
        &#39;&#39;&#39;Meant to be overriden by subclasses. Gives a chance to create the
        structures that hold the analysis.

        The default behaviour is to create a ``OrderedDict`` named ``rets``
        &#39;&#39;&#39;
        self.rets = OrderedDict()

    def get_analysis(self):
        &#39;&#39;&#39;Returns a *dict-like* object with the results of the analysis

        The keys and format of analysis results in the dictionary is
        implementation dependent.

        It is not even enforced that the result is a *dict-like object*, just
        the convention

        The default implementation returns the default OrderedDict ``rets``
        created by the default ``create_analysis`` method

        &#39;&#39;&#39;
        return self.rets

    def print(self, *args, **kwargs):
        &#39;&#39;&#39;Prints the results returned by ``get_analysis`` via a standard
        ``Writerfile`` object, which defaults to writing things to standard
        output
        &#39;&#39;&#39;
        writer = bt.WriterFile(*args, **kwargs)
        writer.start()
        pdct = dict()
        pdct[self.__class__.__name__] = self.get_analysis()
        writer.writedict(pdct)
        writer.stop()

    def pprint(self, *args, **kwargs):
        &#39;&#39;&#39;Prints the results returned by ``get_analysis`` using the pretty
        print Python module (*pprint*)
        &#39;&#39;&#39;
        pp.pprint(self.get_analysis(), *args, **kwargs)


class MetaTimeFrameAnalyzerBase(Analyzer.__class__):
    def __new__(meta, name, bases, dct):
        # Hack to support original method name
        if &#39;_on_dt_over&#39; in dct:
            dct[&#39;on_dt_over&#39;] = dct.pop(&#39;_on_dt_over&#39;)  # rename method

        return super(MetaTimeFrameAnalyzerBase, meta).__new__(meta, name,
                                                              bases, dct)


class TimeFrameAnalyzerBase(with_metaclass(MetaTimeFrameAnalyzerBase,
                                           Analyzer)):
    params = (
        (&#39;timeframe&#39;, None),
        (&#39;compression&#39;, None),
        (&#39;_doprenext&#39;, True),
    )

    def _start(self):
        # Override to add specific attributes
        self.timeframe = self.p.timeframe or self.data._timeframe
        self.compression = self.p.compression or self.data._compression

        self.dtcmp, self.dtkey = self._get_dt_cmpkey(datetime.datetime.min)
        super(TimeFrameAnalyzerBase, self)._start()

    def _prenext(self):
        for child in self._children:
            child._prenext()

        if self._dt_over():
            self.on_dt_over()

        if self.p._doprenext:
            self.prenext()

    def _nextstart(self):
        for child in self._children:
            child._nextstart()

        if self._dt_over() or not self.p._doprenext:  # exec if no prenext
            self.on_dt_over()

        self.nextstart()

    def _next(self):
        for child in self._children:
            child._next()

        if self._dt_over():
            self.on_dt_over()

        self.next()

    def on_dt_over(self):
        pass

    def _dt_over(self):
        if self.timeframe == TimeFrame.NoTimeFrame:
            dtcmp, dtkey = MAXINT, datetime.datetime.max
        else:
            # With &gt;= 1.9.x the system datetime is in the strategy
            dt = self.strategy.datetime.datetime()
            dtcmp, dtkey = self._get_dt_cmpkey(dt)

        if self.dtcmp is None or dtcmp &gt; self.dtcmp:
            self.dtkey, self.dtkey1 = dtkey, self.dtkey
            self.dtcmp, self.dtcmp1 = dtcmp, self.dtcmp
            return True

        return False

    def _get_dt_cmpkey(self, dt):
        if self.timeframe == TimeFrame.NoTimeFrame:
            return None, None

        if self.timeframe == TimeFrame.Years:
            dtcmp = dt.year
            dtkey = datetime.date(dt.year, 12, 31)

        elif self.timeframe == TimeFrame.Months:
            dtcmp = dt.year * 100 + dt.month
            _, lastday = calendar.monthrange(dt.year, dt.month)
            dtkey = datetime.datetime(dt.year, dt.month, lastday)

        elif self.timeframe == TimeFrame.Weeks:
            isoyear, isoweek, isoweekday = dt.isocalendar()
            dtcmp = isoyear * 100 + isoweek
            sunday = dt + datetime.timedelta(days=7 - isoweekday)
            dtkey = datetime.datetime(sunday.year, sunday.month, sunday.day)

        elif self.timeframe == TimeFrame.Days:
            dtcmp = dt.year * 10000 + dt.month * 100 + dt.day
            dtkey = datetime.datetime(dt.year, dt.month, dt.day)

        else:
            dtcmp, dtkey = self._get_subday_cmpkey(dt)

        return dtcmp, dtkey

    def _get_subday_cmpkey(self, dt):
        # Calculate intraday position
        point = dt.hour * 60 + dt.minute

        if self.timeframe &lt; TimeFrame.Minutes:
            point = point * 60 + dt.second

        if self.timeframe &lt; TimeFrame.Seconds:
            point = point * 1e6 + dt.microsecond

        # Apply compression to update point position (comp 5 -&gt; 200 // 5)
        point = point // self.compression

        # Move to next boundary
        point += 1

        # Restore point to the timeframe units by de-applying compression
        point *= self.compression

        # Get hours, minutes, seconds and microseconds
        if self.timeframe == TimeFrame.Minutes:
            ph, pm = divmod(point, 60)
            ps = 0
            pus = 0
        elif self.timeframe == TimeFrame.Seconds:
            ph, pm = divmod(point, 60 * 60)
            pm, ps = divmod(pm, 60)
            pus = 0
        elif self.timeframe == TimeFrame.MicroSeconds:
            ph, pm = divmod(point, 60 * 60 * 1e6)
            pm, psec = divmod(pm, 60 * 1e6)
            ps, pus = divmod(psec, 1e6)

        extradays = 0
        if ph &gt; 23:  # went over midnight:
            extradays = ph // 24
            ph %= 24

        # moving 1 minor unit to the left to be in the boundary
        # pm -= self.timeframe == TimeFrame.Minutes
        # ps -= self.timeframe == TimeFrame.Seconds
        # pus -= self.timeframe == TimeFrame.MicroSeconds

        tadjust = datetime.timedelta(
            minutes=self.timeframe == TimeFrame.Minutes,
            seconds=self.timeframe == TimeFrame.Seconds,
            microseconds=self.timeframe == TimeFrame.MicroSeconds)

        # Add extra day if present
        if extradays:
            dt += datetime.timedelta(days=extradays)

        # Replace intraday parts with the calculated ones and update it
        dtcmp = dt.replace(hour=ph, minute=pm, second=ps, microsecond=pus)
        dtcmp -= tadjust
        dtkey = dtcmp

        return dtcmp, dtkey</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.analyzer.Analyzer"><code class="flex name class">
<span>class <span class="ident">Analyzer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzer base class. All analyzers are subclass of this one</p>
<p>An Analyzer instance operates in the frame of a strategy and provides an
analysis for that strategy.</p>
<p>Automagically set member attributes:</p>
<ul>
<li>
<p><code>self.strategy</code> (giving access to the <em>strategy</em> and anything
accessible from it)</p>
</li>
<li>
<p><code>self.datas[x]</code> giving access to the array of data feeds present in
the the system, which could also be accessed via the strategy reference</p>
</li>
<li>
<p><code>self.data</code>, giving access to <code>self.datas[0]</code></p>
</li>
<li>
<p><code>self.dataX</code> -&gt; <code>self.datas[X]</code></p>
</li>
<li>
<p><code>self.dataX_Y</code> -&gt; <code>self.datas[X].lines[Y]</code></p>
</li>
<li>
<p><code>self.dataX_name</code> -&gt; <code>self.datas[X].name</code></p>
</li>
<li>
<p><code>self.data_name</code> -&gt; <code>self.datas[0].name</code></p>
</li>
<li>
<p><code>self.data_Y</code> -&gt; <code>self.datas[0].lines[Y]</code></p>
</li>
</ul>
<p>This is not a <em>Lines</em> object, but the methods and operation follow the same
design</p>
<ul>
<li>
<p><code>__init__</code> during instantiation and initial setup</p>
</li>
<li>
<p><code>start</code> / <code>stop</code> to signal the begin and end of operations</p>
</li>
<li>
<p><code>prenext</code> / <code>nextstart</code> / <code>next</code> family of methods that follow
the calls made to the same methods in the strategy</p>
</li>
<li>
<p><code>notify_trade</code> / <code>notify_order</code> / <code>notify_cashvalue</code> /
<code>notify_fund</code> which receive the same notifications as the equivalent
methods of the strategy</p>
</li>
</ul>
<p>The mode of operation is open and no pattern is preferred. As such the
analysis can be generated with the <code>next</code> calls, at the end of operations
during <code>stop</code> and even with a single method like <code>notify_trade</code></p>
<p>The important thing is to override <code>get_analysis</code> to return a <em>dict-like</em>
object containing the results of the analysis (the actual format is
implementation dependent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Analyzer(with_metaclass(MetaAnalyzer, object)):
    &#39;&#39;&#39;Analyzer base class. All analyzers are subclass of this one

    An Analyzer instance operates in the frame of a strategy and provides an
    analysis for that strategy.

    Automagically set member attributes:

      - ``self.strategy`` (giving access to the *strategy* and anything
        accessible from it)

      - ``self.datas[x]`` giving access to the array of data feeds present in
        the the system, which could also be accessed via the strategy reference

      - ``self.data``, giving access to ``self.datas[0]``

      - ``self.dataX`` -&gt; ``self.datas[X]``

      - ``self.dataX_Y`` -&gt; ``self.datas[X].lines[Y]``

      - ``self.dataX_name`` -&gt; ``self.datas[X].name``

      - ``self.data_name`` -&gt; ``self.datas[0].name``

      - ``self.data_Y`` -&gt; ``self.datas[0].lines[Y]``

    This is not a *Lines* object, but the methods and operation follow the same
    design

      - ``__init__`` during instantiation and initial setup

      - ``start`` / ``stop`` to signal the begin and end of operations

      - ``prenext`` / ``nextstart`` / ``next`` family of methods that follow
        the calls made to the same methods in the strategy

      - ``notify_trade`` / ``notify_order`` / ``notify_cashvalue`` /
        ``notify_fund`` which receive the same notifications as the equivalent
        methods of the strategy

    The mode of operation is open and no pattern is preferred. As such the
    analysis can be generated with the ``next`` calls, at the end of operations
    during ``stop`` and even with a single method like ``notify_trade``

    The important thing is to override ``get_analysis`` to return a *dict-like*
    object containing the results of the analysis (the actual format is
    implementation dependent)

    &#39;&#39;&#39;
    csv = True

    def __len__(self):
        &#39;&#39;&#39;Support for invoking ``len`` on analyzers by actually returning the
        current length of the strategy the analyzer operates on&#39;&#39;&#39;
        return len(self.strategy)

    def _register(self, child):
        self._children.append(child)

    def _prenext(self):
        for child in self._children:
            child._prenext()

        self.prenext()

    def _notify_cashvalue(self, cash, value):
        for child in self._children:
            child._notify_cashvalue(cash, value)

        self.notify_cashvalue(cash, value)

    def _notify_fund(self, cash, value, fundvalue, shares):
        for child in self._children:
            child._notify_fund(cash, value, fundvalue, shares)

        self.notify_fund(cash, value, fundvalue, shares)

    def _notify_trade(self, trade):
        for child in self._children:
            child._notify_trade(trade)

        self.notify_trade(trade)

    def _notify_order(self, order):
        for child in self._children:
            child._notify_order(order)

        self.notify_order(order)

    def _nextstart(self):
        for child in self._children:
            child._nextstart()

        self.nextstart()

    def _next(self):
        for child in self._children:
            child._next()

        self.next()

    def _start(self):
        for child in self._children:
            child._start()

        self.start()

    def _stop(self):
        for child in self._children:
            child._stop()

        self.stop()

    def notify_cashvalue(self, cash, value):
        &#39;&#39;&#39;Receives the cash/value notification before each next cycle&#39;&#39;&#39;
        pass

    def notify_fund(self, cash, value, fundvalue, shares):
        &#39;&#39;&#39;Receives the current cash, value, fundvalue and fund shares&#39;&#39;&#39;
        pass

    def notify_order(self, order):
        &#39;&#39;&#39;Receives order notifications before each next cycle&#39;&#39;&#39;
        pass

    def notify_trade(self, trade):
        &#39;&#39;&#39;Receives trade notifications before each next cycle&#39;&#39;&#39;
        pass

    def next(self):
        &#39;&#39;&#39;Invoked for each next invocation of the strategy, once the minum
        preiod of the strategy has been reached&#39;&#39;&#39;
        pass

    def prenext(self):
        &#39;&#39;&#39;Invoked for each prenext invocation of the strategy, until the minimum
        period of the strategy has been reached

        The default behavior for an analyzer is to invoke ``next``
        &#39;&#39;&#39;
        self.next()

    def nextstart(self):
        &#39;&#39;&#39;Invoked exactly once for the nextstart invocation of the strategy,
        when the minimum period has been first reached
        &#39;&#39;&#39;
        self.next()

    def start(self):
        &#39;&#39;&#39;Invoked to indicate the start of operations, giving the analyzer
        time to setup up needed things&#39;&#39;&#39;
        pass

    def stop(self):
        &#39;&#39;&#39;Invoked to indicate the end of operations, giving the analyzer
        time to shut down needed things&#39;&#39;&#39;
        pass

    def create_analysis(self):
        &#39;&#39;&#39;Meant to be overriden by subclasses. Gives a chance to create the
        structures that hold the analysis.

        The default behaviour is to create a ``OrderedDict`` named ``rets``
        &#39;&#39;&#39;
        self.rets = OrderedDict()

    def get_analysis(self):
        &#39;&#39;&#39;Returns a *dict-like* object with the results of the analysis

        The keys and format of analysis results in the dictionary is
        implementation dependent.

        It is not even enforced that the result is a *dict-like object*, just
        the convention

        The default implementation returns the default OrderedDict ``rets``
        created by the default ``create_analysis`` method

        &#39;&#39;&#39;
        return self.rets

    def print(self, *args, **kwargs):
        &#39;&#39;&#39;Prints the results returned by ``get_analysis`` via a standard
        ``Writerfile`` object, which defaults to writing things to standard
        output
        &#39;&#39;&#39;
        writer = bt.WriterFile(*args, **kwargs)
        writer.start()
        pdct = dict()
        pdct[self.__class__.__name__] = self.get_analysis()
        writer.writedict(pdct)
        writer.stop()

    def pprint(self, *args, **kwargs):
        &#39;&#39;&#39;Prints the results returned by ``get_analysis`` using the pretty
        print Python module (*pprint*)
        &#39;&#39;&#39;
        pp.pprint(self.get_analysis(), *args, **kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.analyzer.TimeFrameAnalyzerBase" href="#backtrader.analyzer.TimeFrameAnalyzerBase">TimeFrameAnalyzerBase</a></li>
<li><a title="backtrader.analyzers.annualreturn.AnnualReturn" href="analyzers/annualreturn.html#backtrader.analyzers.annualreturn.AnnualReturn">AnnualReturn</a></li>
<li><a title="backtrader.analyzers.drawdown.DrawDown" href="analyzers/drawdown.html#backtrader.analyzers.drawdown.DrawDown">DrawDown</a></li>
<li><a title="backtrader.analyzers.leverage.GrossLeverage" href="analyzers/leverage.html#backtrader.analyzers.leverage.GrossLeverage">GrossLeverage</a></li>
<li><a title="backtrader.analyzers.periodstats.PeriodStats" href="analyzers/periodstats.html#backtrader.analyzers.periodstats.PeriodStats">PeriodStats</a></li>
<li><a title="backtrader.analyzers.positions.PositionsValue" href="analyzers/positions.html#backtrader.analyzers.positions.PositionsValue">PositionsValue</a></li>
<li><a title="backtrader.analyzers.pyfolio.PyFolio" href="analyzers/pyfolio.html#backtrader.analyzers.pyfolio.PyFolio">PyFolio</a></li>
<li><a title="backtrader.analyzers.sharpe.SharpeRatio" href="analyzers/sharpe.html#backtrader.analyzers.sharpe.SharpeRatio">SharpeRatio</a></li>
<li><a title="backtrader.analyzers.sqn.SQN" href="analyzers/sqn.html#backtrader.analyzers.sqn.SQN">SQN</a></li>
<li><a title="backtrader.analyzers.tradeanalyzer.TradeAnalyzer" href="analyzers/tradeanalyzer.html#backtrader.analyzers.tradeanalyzer.TradeAnalyzer">TradeAnalyzer</a></li>
<li><a title="backtrader.analyzers.transactions.Transactions" href="analyzers/transactions.html#backtrader.analyzers.transactions.Transactions">Transactions</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.analyzer.Analyzer.csv"><code class="name">var <span class="ident">csv</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.analyzer.Analyzer.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.analyzer.Analyzer.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.analyzer.Analyzer.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.analyzer.Analyzer.create_analysis"><code class="name flex">
<span>def <span class="ident">create_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Meant to be overriden by subclasses. Gives a chance to create the
structures that hold the analysis.</p>
<p>The default behaviour is to create a <code>OrderedDict</code> named <code>rets</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_analysis(self):
    &#39;&#39;&#39;Meant to be overriden by subclasses. Gives a chance to create the
    structures that hold the analysis.

    The default behaviour is to create a ``OrderedDict`` named ``rets``
    &#39;&#39;&#39;
    self.rets = OrderedDict()</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.get_analysis"><code class="name flex">
<span>def <span class="ident">get_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <em>dict-like</em> object with the results of the analysis</p>
<p>The keys and format of analysis results in the dictionary is
implementation dependent.</p>
<p>It is not even enforced that the result is a <em>dict-like object</em>, just
the convention</p>
<p>The default implementation returns the default OrderedDict <code>rets</code>
created by the default <code>create_analysis</code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_analysis(self):
    &#39;&#39;&#39;Returns a *dict-like* object with the results of the analysis

    The keys and format of analysis results in the dictionary is
    implementation dependent.

    It is not even enforced that the result is a *dict-like object*, just
    the convention

    The default implementation returns the default OrderedDict ``rets``
    created by the default ``create_analysis`` method

    &#39;&#39;&#39;
    return self.rets</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoked for each next invocation of the strategy, once the minum
preiod of the strategy has been reached</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    &#39;&#39;&#39;Invoked for each next invocation of the strategy, once the minum
    preiod of the strategy has been reached&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.nextstart"><code class="name flex">
<span>def <span class="ident">nextstart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoked exactly once for the nextstart invocation of the strategy,
when the minimum period has been first reached</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextstart(self):
    &#39;&#39;&#39;Invoked exactly once for the nextstart invocation of the strategy,
    when the minimum period has been first reached
    &#39;&#39;&#39;
    self.next()</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.notify_cashvalue"><code class="name flex">
<span>def <span class="ident">notify_cashvalue</span></span>(<span>self, cash, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives the cash/value notification before each next cycle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_cashvalue(self, cash, value):
    &#39;&#39;&#39;Receives the cash/value notification before each next cycle&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.notify_fund"><code class="name flex">
<span>def <span class="ident">notify_fund</span></span>(<span>self, cash, value, fundvalue, shares)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives the current cash, value, fundvalue and fund shares</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_fund(self, cash, value, fundvalue, shares):
    &#39;&#39;&#39;Receives the current cash, value, fundvalue and fund shares&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.notify_order"><code class="name flex">
<span>def <span class="ident">notify_order</span></span>(<span>self, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives order notifications before each next cycle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_order(self, order):
    &#39;&#39;&#39;Receives order notifications before each next cycle&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.notify_trade"><code class="name flex">
<span>def <span class="ident">notify_trade</span></span>(<span>self, trade)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives trade notifications before each next cycle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_trade(self, trade):
    &#39;&#39;&#39;Receives trade notifications before each next cycle&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.pprint"><code class="name flex">
<span>def <span class="ident">pprint</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the results returned by <code>get_analysis</code> using the pretty
print Python module (<em>pprint</em>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint(self, *args, **kwargs):
    &#39;&#39;&#39;Prints the results returned by ``get_analysis`` using the pretty
    print Python module (*pprint*)
    &#39;&#39;&#39;
    pp.pprint(self.get_analysis(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.prenext"><code class="name flex">
<span>def <span class="ident">prenext</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoked for each prenext invocation of the strategy, until the minimum
period of the strategy has been reached</p>
<p>The default behavior for an analyzer is to invoke <code>next</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prenext(self):
    &#39;&#39;&#39;Invoked for each prenext invocation of the strategy, until the minimum
    period of the strategy has been reached

    The default behavior for an analyzer is to invoke ``next``
    &#39;&#39;&#39;
    self.next()</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the results returned by <code>get_analysis</code> via a standard
<code>Writerfile</code> object, which defaults to writing things to standard
output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *args, **kwargs):
    &#39;&#39;&#39;Prints the results returned by ``get_analysis`` via a standard
    ``Writerfile`` object, which defaults to writing things to standard
    output
    &#39;&#39;&#39;
    writer = bt.WriterFile(*args, **kwargs)
    writer.start()
    pdct = dict()
    pdct[self.__class__.__name__] = self.get_analysis()
    writer.writedict(pdct)
    writer.stop()</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoked to indicate the start of operations, giving the analyzer
time to setup up needed things</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#39;&#39;&#39;Invoked to indicate the start of operations, giving the analyzer
    time to setup up needed things&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.Analyzer.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Invoked to indicate the end of operations, giving the analyzer
time to shut down needed things</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#39;&#39;&#39;Invoked to indicate the end of operations, giving the analyzer
    time to shut down needed things&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.analyzer.MetaAnalyzer"><code class="flex name class">
<span>class <span class="ident">MetaAnalyzer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>type(object) -&gt; the object's type
type(name, bases, dict, **kwds) -&gt; a new type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaAnalyzer(bt.MetaParams):
    def donew(cls, *args, **kwargs):
        &#39;&#39;&#39;
        Intercept the strategy parameter
        &#39;&#39;&#39;
        # Create the object and set the params in place
        _obj, args, kwargs = super(MetaAnalyzer, cls).donew(*args, **kwargs)

        _obj._children = list()

        _obj.strategy = strategy = bt.metabase.findowner(_obj, bt.Strategy)
        _obj._parent = bt.metabase.findowner(_obj, Analyzer)

        # Register with a master observer if created inside one
        masterobs = bt.metabase.findowner(_obj, bt.Observer)
        if masterobs is not None:
            masterobs._register_analyzer(_obj)

        _obj.datas = strategy.datas

        # For each data add aliases: for first data: data and data0
        if _obj.datas:
            _obj.data = data = _obj.datas[0]

            for l, line in enumerate(data.lines):
                linealias = data._getlinealias(l)
                if linealias:
                    setattr(_obj, &#39;data_%s&#39; % linealias, line)
                setattr(_obj, &#39;data_%d&#39; % l, line)

            for d, data in enumerate(_obj.datas):
                setattr(_obj, &#39;data%d&#39; % d, data)

                for l, line in enumerate(data.lines):
                    linealias = data._getlinealias(l)
                    if linealias:
                        setattr(_obj, &#39;data%d_%s&#39; % (d, linealias), line)
                    setattr(_obj, &#39;data%d_%d&#39; % (d, l), line)

        _obj.create_analysis()

        # Return to the normal chain
        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaAnalyzer, cls).dopostinit(_obj, *args, **kwargs)

        if _obj._parent is not None:
            _obj._parent._register(_obj)

        # Return to the normal chain
        return _obj, args, kwargs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.analyzer.MetaTimeFrameAnalyzerBase" href="#backtrader.analyzer.MetaTimeFrameAnalyzerBase">MetaTimeFrameAnalyzerBase</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backtrader.analyzer.MetaAnalyzer.donew"><code class="name flex">
<span>def <span class="ident">donew</span></span>(<span>cls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Intercept the strategy parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def donew(cls, *args, **kwargs):
    &#39;&#39;&#39;
    Intercept the strategy parameter
    &#39;&#39;&#39;
    # Create the object and set the params in place
    _obj, args, kwargs = super(MetaAnalyzer, cls).donew(*args, **kwargs)

    _obj._children = list()

    _obj.strategy = strategy = bt.metabase.findowner(_obj, bt.Strategy)
    _obj._parent = bt.metabase.findowner(_obj, Analyzer)

    # Register with a master observer if created inside one
    masterobs = bt.metabase.findowner(_obj, bt.Observer)
    if masterobs is not None:
        masterobs._register_analyzer(_obj)

    _obj.datas = strategy.datas

    # For each data add aliases: for first data: data and data0
    if _obj.datas:
        _obj.data = data = _obj.datas[0]

        for l, line in enumerate(data.lines):
            linealias = data._getlinealias(l)
            if linealias:
                setattr(_obj, &#39;data_%s&#39; % linealias, line)
            setattr(_obj, &#39;data_%d&#39; % l, line)

        for d, data in enumerate(_obj.datas):
            setattr(_obj, &#39;data%d&#39; % d, data)

            for l, line in enumerate(data.lines):
                linealias = data._getlinealias(l)
                if linealias:
                    setattr(_obj, &#39;data%d_%s&#39; % (d, linealias), line)
                setattr(_obj, &#39;data%d_%d&#39; % (d, l), line)

    _obj.create_analysis()

    # Return to the normal chain
    return _obj, args, kwargs</code></pre>
</details>
</dd>
<dt id="backtrader.analyzer.MetaAnalyzer.dopostinit"><code class="name flex">
<span>def <span class="ident">dopostinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopostinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaAnalyzer, cls).dopostinit(_obj, *args, **kwargs)

    if _obj._parent is not None:
        _obj._parent._register(_obj)

    # Return to the normal chain
    return _obj, args, kwargs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.analyzer.MetaTimeFrameAnalyzerBase"><code class="flex name class">
<span>class <span class="ident">MetaTimeFrameAnalyzerBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>type(object) -&gt; the object's type
type(name, bases, dict, **kwds) -&gt; a new type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaTimeFrameAnalyzerBase(Analyzer.__class__):
    def __new__(meta, name, bases, dct):
        # Hack to support original method name
        if &#39;_on_dt_over&#39; in dct:
            dct[&#39;on_dt_over&#39;] = dct.pop(&#39;_on_dt_over&#39;)  # rename method

        return super(MetaTimeFrameAnalyzerBase, meta).__new__(meta, name,
                                                              bases, dct)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.analyzer.MetaAnalyzer" href="#backtrader.analyzer.MetaAnalyzer">MetaAnalyzer</a></li>
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.analyzer.MetaAnalyzer" href="#backtrader.analyzer.MetaAnalyzer">MetaAnalyzer</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.analyzer.MetaAnalyzer.donew" href="#backtrader.analyzer.MetaAnalyzer.donew">donew</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.analyzer.TimeFrameAnalyzerBase"><code class="flex name class">
<span>class <span class="ident">TimeFrameAnalyzerBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzer base class. All analyzers are subclass of this one</p>
<p>An Analyzer instance operates in the frame of a strategy and provides an
analysis for that strategy.</p>
<p>Automagically set member attributes:</p>
<ul>
<li>
<p><code>self.strategy</code> (giving access to the <em>strategy</em> and anything
accessible from it)</p>
</li>
<li>
<p><code>self.datas[x]</code> giving access to the array of data feeds present in
the the system, which could also be accessed via the strategy reference</p>
</li>
<li>
<p><code>self.data</code>, giving access to <code>self.datas[0]</code></p>
</li>
<li>
<p><code>self.dataX</code> -&gt; <code>self.datas[X]</code></p>
</li>
<li>
<p><code>self.dataX_Y</code> -&gt; <code>self.datas[X].lines[Y]</code></p>
</li>
<li>
<p><code>self.dataX_name</code> -&gt; <code>self.datas[X].name</code></p>
</li>
<li>
<p><code>self.data_name</code> -&gt; <code>self.datas[0].name</code></p>
</li>
<li>
<p><code>self.data_Y</code> -&gt; <code>self.datas[0].lines[Y]</code></p>
</li>
</ul>
<p>This is not a <em>Lines</em> object, but the methods and operation follow the same
design</p>
<ul>
<li>
<p><code>__init__</code> during instantiation and initial setup</p>
</li>
<li>
<p><code>start</code> / <code>stop</code> to signal the begin and end of operations</p>
</li>
<li>
<p><code>prenext</code> / <code>nextstart</code> / <code>next</code> family of methods that follow
the calls made to the same methods in the strategy</p>
</li>
<li>
<p><code>notify_trade</code> / <code>notify_order</code> / <code>notify_cashvalue</code> /
<code>notify_fund</code> which receive the same notifications as the equivalent
methods of the strategy</p>
</li>
</ul>
<p>The mode of operation is open and no pattern is preferred. As such the
analysis can be generated with the <code>next</code> calls, at the end of operations
during <code>stop</code> and even with a single method like <code>notify_trade</code></p>
<p>The important thing is to override <code>get_analysis</code> to return a <em>dict-like</em>
object containing the results of the analysis (the actual format is
implementation dependent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeFrameAnalyzerBase(with_metaclass(MetaTimeFrameAnalyzerBase,
                                           Analyzer)):
    params = (
        (&#39;timeframe&#39;, None),
        (&#39;compression&#39;, None),
        (&#39;_doprenext&#39;, True),
    )

    def _start(self):
        # Override to add specific attributes
        self.timeframe = self.p.timeframe or self.data._timeframe
        self.compression = self.p.compression or self.data._compression

        self.dtcmp, self.dtkey = self._get_dt_cmpkey(datetime.datetime.min)
        super(TimeFrameAnalyzerBase, self)._start()

    def _prenext(self):
        for child in self._children:
            child._prenext()

        if self._dt_over():
            self.on_dt_over()

        if self.p._doprenext:
            self.prenext()

    def _nextstart(self):
        for child in self._children:
            child._nextstart()

        if self._dt_over() or not self.p._doprenext:  # exec if no prenext
            self.on_dt_over()

        self.nextstart()

    def _next(self):
        for child in self._children:
            child._next()

        if self._dt_over():
            self.on_dt_over()

        self.next()

    def on_dt_over(self):
        pass

    def _dt_over(self):
        if self.timeframe == TimeFrame.NoTimeFrame:
            dtcmp, dtkey = MAXINT, datetime.datetime.max
        else:
            # With &gt;= 1.9.x the system datetime is in the strategy
            dt = self.strategy.datetime.datetime()
            dtcmp, dtkey = self._get_dt_cmpkey(dt)

        if self.dtcmp is None or dtcmp &gt; self.dtcmp:
            self.dtkey, self.dtkey1 = dtkey, self.dtkey
            self.dtcmp, self.dtcmp1 = dtcmp, self.dtcmp
            return True

        return False

    def _get_dt_cmpkey(self, dt):
        if self.timeframe == TimeFrame.NoTimeFrame:
            return None, None

        if self.timeframe == TimeFrame.Years:
            dtcmp = dt.year
            dtkey = datetime.date(dt.year, 12, 31)

        elif self.timeframe == TimeFrame.Months:
            dtcmp = dt.year * 100 + dt.month
            _, lastday = calendar.monthrange(dt.year, dt.month)
            dtkey = datetime.datetime(dt.year, dt.month, lastday)

        elif self.timeframe == TimeFrame.Weeks:
            isoyear, isoweek, isoweekday = dt.isocalendar()
            dtcmp = isoyear * 100 + isoweek
            sunday = dt + datetime.timedelta(days=7 - isoweekday)
            dtkey = datetime.datetime(sunday.year, sunday.month, sunday.day)

        elif self.timeframe == TimeFrame.Days:
            dtcmp = dt.year * 10000 + dt.month * 100 + dt.day
            dtkey = datetime.datetime(dt.year, dt.month, dt.day)

        else:
            dtcmp, dtkey = self._get_subday_cmpkey(dt)

        return dtcmp, dtkey

    def _get_subday_cmpkey(self, dt):
        # Calculate intraday position
        point = dt.hour * 60 + dt.minute

        if self.timeframe &lt; TimeFrame.Minutes:
            point = point * 60 + dt.second

        if self.timeframe &lt; TimeFrame.Seconds:
            point = point * 1e6 + dt.microsecond

        # Apply compression to update point position (comp 5 -&gt; 200 // 5)
        point = point // self.compression

        # Move to next boundary
        point += 1

        # Restore point to the timeframe units by de-applying compression
        point *= self.compression

        # Get hours, minutes, seconds and microseconds
        if self.timeframe == TimeFrame.Minutes:
            ph, pm = divmod(point, 60)
            ps = 0
            pus = 0
        elif self.timeframe == TimeFrame.Seconds:
            ph, pm = divmod(point, 60 * 60)
            pm, ps = divmod(pm, 60)
            pus = 0
        elif self.timeframe == TimeFrame.MicroSeconds:
            ph, pm = divmod(point, 60 * 60 * 1e6)
            pm, psec = divmod(pm, 60 * 1e6)
            ps, pus = divmod(psec, 1e6)

        extradays = 0
        if ph &gt; 23:  # went over midnight:
            extradays = ph // 24
            ph %= 24

        # moving 1 minor unit to the left to be in the boundary
        # pm -= self.timeframe == TimeFrame.Minutes
        # ps -= self.timeframe == TimeFrame.Seconds
        # pus -= self.timeframe == TimeFrame.MicroSeconds

        tadjust = datetime.timedelta(
            minutes=self.timeframe == TimeFrame.Minutes,
            seconds=self.timeframe == TimeFrame.Seconds,
            microseconds=self.timeframe == TimeFrame.MicroSeconds)

        # Add extra day if present
        if extradays:
            dt += datetime.timedelta(days=extradays)

        # Replace intraday parts with the calculated ones and update it
        dtcmp = dt.replace(hour=ph, minute=pm, second=ps, microsecond=pus)
        dtcmp -= tadjust
        dtkey = dtcmp

        return dtcmp, dtkey</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.analyzer.Analyzer" href="#backtrader.analyzer.Analyzer">Analyzer</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.analyzers.calmar.Calmar" href="analyzers/calmar.html#backtrader.analyzers.calmar.Calmar">Calmar</a></li>
<li><a title="backtrader.analyzers.drawdown.TimeDrawDown" href="analyzers/drawdown.html#backtrader.analyzers.drawdown.TimeDrawDown">TimeDrawDown</a></li>
<li><a title="backtrader.analyzers.logreturnsrolling.LogReturnsRolling" href="analyzers/logreturnsrolling.html#backtrader.analyzers.logreturnsrolling.LogReturnsRolling">LogReturnsRolling</a></li>
<li><a title="backtrader.analyzers.returns.Returns" href="analyzers/returns.html#backtrader.analyzers.returns.Returns">Returns</a></li>
<li><a title="backtrader.analyzers.timereturn.TimeReturn" href="analyzers/timereturn.html#backtrader.analyzers.timereturn.TimeReturn">TimeReturn</a></li>
<li><a title="backtrader.analyzers.vwr.VWR" href="analyzers/vwr.html#backtrader.analyzers.vwr.VWR">VWR</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.analyzer.TimeFrameAnalyzerBase.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.analyzer.TimeFrameAnalyzerBase.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.analyzer.TimeFrameAnalyzerBase.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.analyzer.TimeFrameAnalyzerBase.on_dt_over"><code class="name flex">
<span>def <span class="ident">on_dt_over</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_dt_over(self):
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.analyzer.Analyzer" href="#backtrader.analyzer.Analyzer">Analyzer</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.analyzer.Analyzer.create_analysis" href="#backtrader.analyzer.Analyzer.create_analysis">create_analysis</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.get_analysis" href="#backtrader.analyzer.Analyzer.get_analysis">get_analysis</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.next" href="#backtrader.analyzer.Analyzer.next">next</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.nextstart" href="#backtrader.analyzer.Analyzer.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_cashvalue" href="#backtrader.analyzer.Analyzer.notify_cashvalue">notify_cashvalue</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_fund" href="#backtrader.analyzer.Analyzer.notify_fund">notify_fund</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_order" href="#backtrader.analyzer.Analyzer.notify_order">notify_order</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_trade" href="#backtrader.analyzer.Analyzer.notify_trade">notify_trade</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.pprint" href="#backtrader.analyzer.Analyzer.pprint">pprint</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.prenext" href="#backtrader.analyzer.Analyzer.prenext">prenext</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.print" href="#backtrader.analyzer.Analyzer.print">print</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.start" href="#backtrader.analyzer.Analyzer.start">start</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.stop" href="#backtrader.analyzer.Analyzer.stop">stop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.analyzer.Analyzer" href="#backtrader.analyzer.Analyzer">Analyzer</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.analyzer.Analyzer.create_analysis" href="#backtrader.analyzer.Analyzer.create_analysis">create_analysis</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.csv" href="#backtrader.analyzer.Analyzer.csv">csv</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.frompackages" href="#backtrader.analyzer.Analyzer.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.get_analysis" href="#backtrader.analyzer.Analyzer.get_analysis">get_analysis</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.next" href="#backtrader.analyzer.Analyzer.next">next</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.nextstart" href="#backtrader.analyzer.Analyzer.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_cashvalue" href="#backtrader.analyzer.Analyzer.notify_cashvalue">notify_cashvalue</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_fund" href="#backtrader.analyzer.Analyzer.notify_fund">notify_fund</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_order" href="#backtrader.analyzer.Analyzer.notify_order">notify_order</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.notify_trade" href="#backtrader.analyzer.Analyzer.notify_trade">notify_trade</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.packages" href="#backtrader.analyzer.Analyzer.packages">packages</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.params" href="#backtrader.analyzer.Analyzer.params">params</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.pprint" href="#backtrader.analyzer.Analyzer.pprint">pprint</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.prenext" href="#backtrader.analyzer.Analyzer.prenext">prenext</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.print" href="#backtrader.analyzer.Analyzer.print">print</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.start" href="#backtrader.analyzer.Analyzer.start">start</a></code></li>
<li><code><a title="backtrader.analyzer.Analyzer.stop" href="#backtrader.analyzer.Analyzer.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.analyzer.MetaAnalyzer" href="#backtrader.analyzer.MetaAnalyzer">MetaAnalyzer</a></code></h4>
<ul class="">
<li><code><a title="backtrader.analyzer.MetaAnalyzer.donew" href="#backtrader.analyzer.MetaAnalyzer.donew">donew</a></code></li>
<li><code><a title="backtrader.analyzer.MetaAnalyzer.dopostinit" href="#backtrader.analyzer.MetaAnalyzer.dopostinit">dopostinit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.analyzer.MetaTimeFrameAnalyzerBase" href="#backtrader.analyzer.MetaTimeFrameAnalyzerBase">MetaTimeFrameAnalyzerBase</a></code></h4>
</li>
<li>
<h4><code><a title="backtrader.analyzer.TimeFrameAnalyzerBase" href="#backtrader.analyzer.TimeFrameAnalyzerBase">TimeFrameAnalyzerBase</a></code></h4>
<ul class="">
<li><code><a title="backtrader.analyzer.TimeFrameAnalyzerBase.frompackages" href="#backtrader.analyzer.TimeFrameAnalyzerBase.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.analyzer.TimeFrameAnalyzerBase.on_dt_over" href="#backtrader.analyzer.TimeFrameAnalyzerBase.on_dt_over">on_dt_over</a></code></li>
<li><code><a title="backtrader.analyzer.TimeFrameAnalyzerBase.packages" href="#backtrader.analyzer.TimeFrameAnalyzerBase.packages">packages</a></code></li>
<li><code><a title="backtrader.analyzer.TimeFrameAnalyzerBase.params" href="#backtrader.analyzer.TimeFrameAnalyzerBase.params">params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>