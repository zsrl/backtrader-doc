<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.stores.vcstore API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.stores.vcstore</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)


import collections
from datetime import date, datetime, time, timedelta
import os.path
import threading
import time as _timemod

import ctypes

from backtrader import TimeFrame, Position
from backtrader.feed import DataBase
from backtrader.metabase import MetaParams
from backtrader.utils.py3 import (MAXINT, range, queue, string_types,
                                  with_metaclass)
from backtrader.utils import AutoDict


class _SymInfo(object):
    # Replica of the SymbolInfo COM object to pass it over thread boundaries
    _fields = [&#39;Type&#39;, &#39;Description&#39;, &#39;Decimals&#39;, &#39;TimeOffset&#39;,
               &#39;PointValue&#39;, &#39;MinMovement&#39;]

    def __init__(self, syminfo):
        for f in self._fields:
            setattr(self, f, getattr(syminfo, f))

# This type is used inside &#39;PumpEvents&#39;, but if we create the type
# afresh each time &#39;PumpEvents&#39; is called we end up creating cyclic
# garbage for each call.  So we define it here instead.
_handles_type = ctypes.c_void_p * 1


def PumpEvents(timeout=-1, hevt=None, cb=None):
    &#34;&#34;&#34;This following code waits for &#39;timeout&#39; seconds in the way
    required for COM, internally doing the correct things depending
    on the COM appartment of the current thread.  It is possible to
    terminate the message loop by pressing CTRL+C, which will raise
    a KeyboardInterrupt.
    &#34;&#34;&#34;
    # XXX Should there be a way to pass additional event handles which
    # can terminate this function?

    # XXX XXX XXX
    #
    # It may be that I misunderstood the CoWaitForMultipleHandles
    # function.  Is a message loop required in a STA?  Seems so...
    #
    # MSDN says:
    #
    # If the caller resides in a single-thread apartment,
    # CoWaitForMultipleHandles enters the COM modal loop, and the
    # thread&#39;s message loop will continue to dispatch messages using
    # the thread&#39;s message filter. If no message filter is registered
    # for the thread, the default COM message processing is used.
    #
    # If the calling thread resides in a multithread apartment (MTA),
    # CoWaitForMultipleHandles calls the Win32 function
    # MsgWaitForMultipleObjects.

    # Timeout expected as float in seconds - *1000 to miliseconds
    # timeout = -1 -&gt; INFINITE 0xFFFFFFFF;
    # It can also be a callable which should return an amount in seconds

    if hevt is None:
        hevt = ctypes.windll.kernel32.CreateEventA(None, True, False, None)

    handles = _handles_type(hevt)
    RPC_S_CALLPENDING = -2147417835

    # @ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)
    def HandlerRoutine(dwCtrlType):
        if dwCtrlType == 0:  # CTRL+C
            ctypes.windll.kernel32.SetEvent(hevt)
            return 1
        return 0

    HandlerRoutine = (
        ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)(HandlerRoutine)
    )

    ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 1)
    while True:
        try:
            tmout = timeout()  # check if it&#39;s a callable
        except TypeError:
            tmout = timeout  # it seems to be a number

        if tmout &gt; 0:
            tmout *= 1000
        tmout = int(tmout)

        try:
            res = ctypes.oledll.ole32.CoWaitForMultipleHandles(
                0,  # COWAIT_FLAGS
                int(tmout),  # dwtimeout
                len(handles),  # number of handles in handles
                handles,  # handles array
                # pointer to indicate which handle was signaled
                ctypes.byref(ctypes.c_ulong())
            )

        except WindowsError as details:
            if details.args[0] == RPC_S_CALLPENDING:  # timeout expired
                if cb is not None:
                    cb()

                continue

            else:
                ctypes.windll.kernel32.CloseHandle(hevt)
                ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
                raise  # something else happened
        else:
            ctypes.windll.kernel32.CloseHandle(hevt)
            ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
            raise KeyboardInterrupt

        # finally:
        # if False:
            # ctypes.windll.kernel32.CloseHandle(hevt)
            # ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
            # break


class RTEventSink(object):
    def __init__(self, store):
        self.store = store
        self.vcrtmod = store.vcrtmod
        self.lastconn = None

    def OnNewTicks(self, ArrayTicks):
        pass

    def OnServerShutDown(self):
        self.store._vcrt_connection(self.store._RT_SHUTDOWN)

    def OnInternalEvent(self, p1, p2, p3):
        if p1 != 1:  # Apparently &#34;Connection Event&#34;
            return

        if p2 == self.lastconn:
            return  # do not notify twice

        self.lastconn = p2  # keep new notification code

        # p2 should be 0 (disconn), 1 (conn)
        self.store._vcrt_connection(self.store._RT_BASEMSG - p2)


class MetaSingleton(MetaParams):
    &#39;&#39;&#39;Metaclass to make a metaclassed class a singleton&#39;&#39;&#39;
    def __init__(cls, name, bases, dct):
        super(MetaSingleton, cls).__init__(name, bases, dct)
        cls._singleton = None

    def __call__(cls, *args, **kwargs):
        if cls._singleton is None:
            cls._singleton = (
                super(MetaSingleton, cls).__call__(*args, **kwargs))

        return cls._singleton


class VCStore(with_metaclass(MetaSingleton, object)):
    &#39;&#39;&#39;Singleton class wrapping an ibpy ibConnection instance.

    The parameters can also be specified in the classes which use this store,
    like ``VCData`` and ``VCBroker``

    &#39;&#39;&#39;
    BrokerCls = None  # broker class will autoregister
    DataCls = None  # data class will auto register

    # 32 bit max unsigned int for openinterest correction
    MAXUINT = 0xffffffff // 2

    # to remove at least 1 sec or else there seem to be internal conv problems
    MAXDATE1 = datetime.max - timedelta(days=1, seconds=1)
    MAXDATE2 = datetime.max - timedelta(seconds=1)

    _RT_SHUTDOWN = -0xffff
    _RT_BASEMSG = -0xfff0
    _RT_DISCONNECTED = -0xfff0
    _RT_CONNECTED = -0xfff1
    _RT_LIVE = -0xfff2
    _RT_DELAYED = -0xfff3
    _RT_TYPELIB = -0xffe0
    _RT_TYPEOBJ = -0xffe1
    _RT_COMTYPES = -0xffe2

    @classmethod
    def getdata(cls, *args, **kwargs):
        &#39;&#39;&#39;Returns ``DataCls`` with args, kwargs&#39;&#39;&#39;
        return cls.DataCls(*args, **kwargs)

    @classmethod
    def getbroker(cls, *args, **kwargs):
        &#39;&#39;&#39;Returns broker with *args, **kwargs from registered ``BrokerCls``&#39;&#39;&#39;
        return cls.BrokerCls(*args, **kwargs)

    # DLLs to parse if found for TypeLibs
    VC64_DLLS = (&#39;VCDataSource64.dll&#39;, &#39;VCRealTimeLib64.dll&#39;,
                 &#39;COMTraderInterfaces64.dll&#39;,)

    VC_DLLS = (&#39;VCDataSource.dll&#39;, &#39;VCRealTimeLib.dll&#39;,
               &#39;COMTraderInterfaces.dll&#39;,)

    # Well known CLSDI
    VC_TLIBS = (
        [&#39;{EB2A77DC-A317-4160-8833-DECF16275A05}&#39;, 1, 0],  # vcdatasource64
        [&#39;{86F1DB04-2591-4866-A361-BB053D77FA18}&#39;, 1, 0],  # vcrealtime64
        [&#39;{20F8873C-35BE-4DB4-8C2A-0A8D40F8AEC3}&#39;, 1, 0],  # raderinterface64
    )

    VC_KEYNAME = r&#39;SOFTWARE\VCG\Visual Chart 6\Config&#39;
    VC_KEYVAL = &#39;Directory&#39;
    VC_BINPATH = &#39;bin&#39;

    def find_vchart(self):
        # Tries to locate VisualChart in the registry to get the installation
        # directory
        # If not found returns well-known typelibs clsid
        # Else it will scan the directory to locate the 64/32 bit dlls and
        # return the paths
        import _winreg  # keep import local to avoid breaking test cases

        vcdir = None

        # Search for Directory in the usual root keys
        for rkey in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE,):
            try:
                vckey = _winreg.OpenKey(rkey, self.VC_KEYNAME)
            except WindowsError as e:
                continue

            # Try to get the key value
            try:
                vcdir, _ = _winreg.QueryValueEx(vckey, self.VC_KEYVAL)
            except WindowsError as e:
                continue
            else:
                break  # found vcdir

        if vcdir is None:
            return self.VC_TLIBS  # no dir found, last resort

        # DLLs are in the bin directory
        vcbin = os.path.join(vcdir, self.VC_BINPATH)

        # Search for the 3 libraries (64/32 bits) in the found dir
        for dlls in (self.VC64_DLLS, self.VC_DLLS,):
            dfound = []
            for dll in dlls:
                fpath = os.path.join(vcbin, dll)
                if not os.path.isfile(fpath):
                    break
                dfound.append(fpath)

            if len(dfound) == len(dlls):
                return dfound

        # not all dlls were found, last resort
        return self.VC_TLIBS

    def _load_comtypes(self):
        # Keep comtypes imports local to avoid breaking testcases
        try:
            import comtypes
            self.comtypes = comtypes

            from comtypes.client import CreateObject, GetEvents, GetModule
            self.CreateObject = CreateObject
            self.GetEvents = GetEvents
            self.GetModule = GetModule
        except ImportError:
            return False

        return True  # notifiy comtypes was loaded

    def __init__(self):
        self._connected = False  # modules/objects created

        self.notifs = collections.deque()  # hold notifications to deliver

        self.t_vcconn = None  # control connection status

        # hold deques to market data symbols
        self._dqs = collections.deque()
        self._qdatas = dict()
        self._tftable = dict()

        if not self._load_comtypes():
            txt = &#39;Failed to import comtypes&#39;
            msg = self._RT_COMTYPES, txt
            self.put_notification(msg, *msg)
            return

        vctypelibs = self.find_vchart()
        # Try to load the modules
        try:
            self.vcdsmod = self.GetModule(vctypelibs[0])
            self.vcrtmod = self.GetModule(vctypelibs[1])
            self.vcctmod = self.GetModule(vctypelibs[2])
        except WindowsError as e:
            self.vcdsmod = None
            self.vcrtmod = None
            self.vcctmod = None
            txt = &#39;Failed to Load COM TypeLib Modules {}&#39;.format(e)
            msg = self._RT_TYPELIB, txt
            self.put_notification(msg, *msg)
            return

        # Try to load the main objects
        try:
            self.vcds = self.CreateObject(self.vcdsmod.DataSourceManager)
            # self.vcrt = self.CreateObject(self.vcrtmod.RealTime)
            self.vcct = self.CreateObject(self.vcctmod.Trader)
        except WindowsError as e:
            txt = (&#39;Failed to Load COM TypeLib Objects but the COM TypeLibs &#39;
                   &#39;have been loaded. If VisualChart has been recently &#39;
                   &#39;installed/updated, restarting Windows may be necessary &#39;
                   &#39;to register the Objects: {}&#39;.format(e))
            msg = self._RT_TYPELIB, txt
            self.put_notification(msg, *msg)
            self.vcds = None
            self.vcrt = None
            self.vcct = None
            return

        self._connected = True

        # Build a table of VCRT Field_XX mappings for debugging purposes
        self.vcrtfields = dict()
        for name in dir(self.vcrtmod):
            if name.startswith(&#39;Field&#39;):
                self.vcrtfields[getattr(self.vcrtmod, name)] = name

        # Modules and objects can be created
        self._tftable = {
            TimeFrame.Ticks: (self.vcdsmod.CT_Ticks, 1),
            TimeFrame.MicroSeconds: (self.vcdsmod.CT_Ticks, 1),  # To Resample
            TimeFrame.Seconds: (self.vcdsmod.CT_Ticks, 1),  # To Resample
            TimeFrame.Minutes: (self.vcdsmod.CT_Minutes, 1),
            TimeFrame.Days: (self.vcdsmod.CT_Days, 1),
            TimeFrame.Weeks: (self.vcdsmod.CT_Weeks, 1),
            TimeFrame.Months: (self.vcdsmod.CT_Months, 1),
            TimeFrame.Years: (self.vcdsmod.CT_Months, 12),
        }

    def put_notification(self, msg, *args, **kwargs):
        self.notifs.append((msg, args, kwargs))

    def get_notifications(self):
        &#39;&#39;&#39;Return the pending &#34;store&#34; notifications&#39;&#39;&#39;
        self.notifs.append(None)  # Mark current end of notifs
        return [x for x in iter(self.notifs.popleft, None)]  # popleft til None

    def start(self, data=None, broker=None):
        if not self._connected:
            return

        if self.t_vcconn is None:
            # Kickstart connection thread check
            self.t_vcconn = t = threading.Thread(target=self._start_vcrt)
            t.daemon = True  # Do not stop a general exit
            t.start()

        if broker is not None:
            t = threading.Thread(target=self._t_broker, args=(broker,))
            t.daemon = True
            t.start()

    def stop(self):
        pass  # nothing to do

    def connected(self):
        return self._connected

    def _start_vcrt(self):
        # Use VCRealTime to monitor the connection status
        self.comtypes.CoInitialize()  # running in another thread
        vcrt = self.CreateObject(self.vcrtmod.RealTime)
        sink = RTEventSink(self)
        conn = self.GetEvents(vcrt, sink)
        PumpEvents()
        self.comtypes.CoUninitialize()

    def _vcrt_connection(self, status):
        if status == -0xffff:
            txt = &#39;VisualChart shutting down&#39;,
        # p2: 0 -&gt; Disconnected /  p2: 1 -&gt; Reconnected
        elif status == -0xfff0:
            txt = &#39;VisualChart is Disconnected&#39;
        elif status == -0xfff1:
            txt = &#39;VisualChart is Connected&#39;
        else:
            txt = &#39;VisualChart unknown connection status &#39;

        msg = txt, status
        self.put_notification(msg, *msg)

        for q in self._dqs:
            q.put(status)

    def _tf2ct(self, timeframe, compression):
        # Translates timeframes to known compression types in VisualChart
        timeframe, extracomp = self._tftable[timeframe]
        return timeframe, compression * extracomp

    def _ticking(self, timeframe):
        # Translates timeframes to known compression types in VisualChart
        vctimeframe, _ = self._tftable[timeframe]
        return vctimeframe == self.vcdsmod.CT_Ticks

    def _getq(self, data):
        q = queue.Queue()
        self._dqs.append(q)
        self._qdatas[q] = data
        return q

    def _delq(self, q):
        self._dqs.remove(q)
        self._qdatas.pop(q)

    def _rtdata(self, data, symbol):
        kwargs = dict(data=data, symbol=symbol)
        t = threading.Thread(target=self._t_rtdata, kwargs=kwargs)
        t.daemon = True
        t.start()

    # Broker functions
    def _t_rtdata(self, data, symbol):
        self.comtypes.CoInitialize()  # running in another thread
        vcrt = self.CreateObject(self.vcrtmod.RealTime)
        conn = self.GetEvents(vcrt, data)
        data._vcrt = vcrt
        vcrt.RequestSymbolFeed(symbol, False)  # no limits
        PumpEvents()
        del conn  # ensure events go away
        self.comtypes.CoUninitialize()

    def _symboldata(self, symbol):

        # Assumption -&gt; we are connected and the symbol has been found
        self.vcds.ActiveEvents = 0
        # self.vcds.EventsType = self.vcdsmod.EF_Always

        serie = self.vcds.NewDataSerie(symbol,
                                       self.vcdsmod.CT_Days, 1,
                                       self.MAXDATE1, self.MAXDATE2)

        syminfo = _SymInfo(serie.GetSymbolInfo())
        self.vcds.DeleteDataSource(serie)
        return syminfo

    def _canceldirectdata(self, q):
        self._delq(q)

    def _directdata(self, data,
                    symbol, timeframe, compression, d1, d2=None,
                    historical=False):

        # Assume the data has checked the existence of the symbol
        timeframe, compression = self._tf2ct(timeframe, compression)
        kwargs = locals().copy()  # make a copy of the args
        kwargs.pop(&#39;self&#39;)
        kwargs[&#39;q&#39;] = q = self._getq(data)

        t = threading.Thread(target=self._t_directdata, kwargs=kwargs)
        t.daemon = True
        t.start()

        # use the queue to synchronize until symbolinfo has been gotten
        return q  # tell the caller where to expect the hist data

    def _t_directdata(self, data,
                      symbol, timeframe, compression, d1, d2, q,
                      historical):

        self.comtypes.CoInitialize()  # start com threading
        vcds = self.CreateObject(self.vcdsmod.DataSourceManager)

        historical = historical or d2 is not None
        if not historical:
            vcds.ActiveEvents = 1
            vcds.EventsType = self.vcdsmod.EF_Always
        else:
            vcds.ActiveEvents = 0

        if d2 is not None:
            serie = vcds.NewDataSerie(symbol, timeframe, compression, d1, d2)
        else:
            serie = vcds.NewDataSerie(symbol, timeframe, compression, d1)

        data._setserie(serie)

        # processing of bars can continue
        data.OnNewDataSerieBar(serie, forcepush=historical)
        if historical:  # push the last bar
            q.put(None)        # Signal end of transmission
            dsconn = None
        else:
            dsconn = self.GetEvents(vcds, data)  # finally connect the events
            pass

        # pump events in this thread - call ping
        PumpEvents(timeout=data._getpingtmout, cb=data.ping)
        if dsconn is not None:
            del dsconn  # Docs recommend deleting the connection

        # Delete the series before coming out of the thread
        vcds.DeleteDataSource(serie)
        self.comtypes.CoUninitialize()  # Terminate com threading

    # Broker functions
    def _t_broker(self, broker):
        self.comtypes.CoInitialize()  # running in another thread
        trader = self.CreateObject(self.vcctmod.Trader)
        conn = self.GetEvents(trader, broker(trader))
        PumpEvents()
        del conn  # ensure events go away
        self.comtypes.CoUninitialize()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backtrader.stores.vcstore.PumpEvents"><code class="name flex">
<span>def <span class="ident">PumpEvents</span></span>(<span>timeout=-1, hevt=None, cb=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This following code waits for 'timeout' seconds in the way
required for COM, internally doing the correct things depending
on the COM appartment of the current thread.
It is possible to
terminate the message loop by pressing CTRL+C, which will raise
a KeyboardInterrupt.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PumpEvents(timeout=-1, hevt=None, cb=None):
    &#34;&#34;&#34;This following code waits for &#39;timeout&#39; seconds in the way
    required for COM, internally doing the correct things depending
    on the COM appartment of the current thread.  It is possible to
    terminate the message loop by pressing CTRL+C, which will raise
    a KeyboardInterrupt.
    &#34;&#34;&#34;
    # XXX Should there be a way to pass additional event handles which
    # can terminate this function?

    # XXX XXX XXX
    #
    # It may be that I misunderstood the CoWaitForMultipleHandles
    # function.  Is a message loop required in a STA?  Seems so...
    #
    # MSDN says:
    #
    # If the caller resides in a single-thread apartment,
    # CoWaitForMultipleHandles enters the COM modal loop, and the
    # thread&#39;s message loop will continue to dispatch messages using
    # the thread&#39;s message filter. If no message filter is registered
    # for the thread, the default COM message processing is used.
    #
    # If the calling thread resides in a multithread apartment (MTA),
    # CoWaitForMultipleHandles calls the Win32 function
    # MsgWaitForMultipleObjects.

    # Timeout expected as float in seconds - *1000 to miliseconds
    # timeout = -1 -&gt; INFINITE 0xFFFFFFFF;
    # It can also be a callable which should return an amount in seconds

    if hevt is None:
        hevt = ctypes.windll.kernel32.CreateEventA(None, True, False, None)

    handles = _handles_type(hevt)
    RPC_S_CALLPENDING = -2147417835

    # @ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)
    def HandlerRoutine(dwCtrlType):
        if dwCtrlType == 0:  # CTRL+C
            ctypes.windll.kernel32.SetEvent(hevt)
            return 1
        return 0

    HandlerRoutine = (
        ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)(HandlerRoutine)
    )

    ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 1)
    while True:
        try:
            tmout = timeout()  # check if it&#39;s a callable
        except TypeError:
            tmout = timeout  # it seems to be a number

        if tmout &gt; 0:
            tmout *= 1000
        tmout = int(tmout)

        try:
            res = ctypes.oledll.ole32.CoWaitForMultipleHandles(
                0,  # COWAIT_FLAGS
                int(tmout),  # dwtimeout
                len(handles),  # number of handles in handles
                handles,  # handles array
                # pointer to indicate which handle was signaled
                ctypes.byref(ctypes.c_ulong())
            )

        except WindowsError as details:
            if details.args[0] == RPC_S_CALLPENDING:  # timeout expired
                if cb is not None:
                    cb()

                continue

            else:
                ctypes.windll.kernel32.CloseHandle(hevt)
                ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
                raise  # something else happened
        else:
            ctypes.windll.kernel32.CloseHandle(hevt)
            ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
            raise KeyboardInterrupt

        # finally:
        # if False:
            # ctypes.windll.kernel32.CloseHandle(hevt)
            # ctypes.windll.kernel32.SetConsoleCtrlHandler(HandlerRoutine, 0)
            # break</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.stores.vcstore.MetaSingleton"><code class="flex name class">
<span>class <span class="ident">MetaSingleton</span></span>
<span>(</span><span>name, bases, dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Metaclass to make a metaclassed class a singleton</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaSingleton(MetaParams):
    &#39;&#39;&#39;Metaclass to make a metaclassed class a singleton&#39;&#39;&#39;
    def __init__(cls, name, bases, dct):
        super(MetaSingleton, cls).__init__(name, bases, dct)
        cls._singleton = None

    def __call__(cls, *args, **kwargs):
        if cls._singleton is None:
            cls._singleton = (
                super(MetaSingleton, cls).__call__(*args, **kwargs))

        return cls._singleton</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.metabase.MetaParams" href="../metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="../metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
</dd>
<dt id="backtrader.stores.vcstore.RTEventSink"><code class="flex name class">
<span>class <span class="ident">RTEventSink</span></span>
<span>(</span><span>store)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RTEventSink(object):
    def __init__(self, store):
        self.store = store
        self.vcrtmod = store.vcrtmod
        self.lastconn = None

    def OnNewTicks(self, ArrayTicks):
        pass

    def OnServerShutDown(self):
        self.store._vcrt_connection(self.store._RT_SHUTDOWN)

    def OnInternalEvent(self, p1, p2, p3):
        if p1 != 1:  # Apparently &#34;Connection Event&#34;
            return

        if p2 == self.lastconn:
            return  # do not notify twice

        self.lastconn = p2  # keep new notification code

        # p2 should be 0 (disconn), 1 (conn)
        self.store._vcrt_connection(self.store._RT_BASEMSG - p2)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="backtrader.stores.vcstore.RTEventSink.OnInternalEvent"><code class="name flex">
<span>def <span class="ident">OnInternalEvent</span></span>(<span>self, p1, p2, p3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnInternalEvent(self, p1, p2, p3):
    if p1 != 1:  # Apparently &#34;Connection Event&#34;
        return

    if p2 == self.lastconn:
        return  # do not notify twice

    self.lastconn = p2  # keep new notification code

    # p2 should be 0 (disconn), 1 (conn)
    self.store._vcrt_connection(self.store._RT_BASEMSG - p2)</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.RTEventSink.OnNewTicks"><code class="name flex">
<span>def <span class="ident">OnNewTicks</span></span>(<span>self, ArrayTicks)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnNewTicks(self, ArrayTicks):
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.RTEventSink.OnServerShutDown"><code class="name flex">
<span>def <span class="ident">OnServerShutDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OnServerShutDown(self):
    self.store._vcrt_connection(self.store._RT_SHUTDOWN)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.stores.vcstore.VCStore"><code class="flex name class">
<span>class <span class="ident">VCStore</span></span>
</code></dt>
<dd>
<div class="desc"><p>Singleton class wrapping an ibpy ibConnection instance.</p>
<p>The parameters can also be specified in the classes which use this store,
like <code>VCData</code> and <code>VCBroker</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VCStore(with_metaclass(MetaSingleton, object)):
    &#39;&#39;&#39;Singleton class wrapping an ibpy ibConnection instance.

    The parameters can also be specified in the classes which use this store,
    like ``VCData`` and ``VCBroker``

    &#39;&#39;&#39;
    BrokerCls = None  # broker class will autoregister
    DataCls = None  # data class will auto register

    # 32 bit max unsigned int for openinterest correction
    MAXUINT = 0xffffffff // 2

    # to remove at least 1 sec or else there seem to be internal conv problems
    MAXDATE1 = datetime.max - timedelta(days=1, seconds=1)
    MAXDATE2 = datetime.max - timedelta(seconds=1)

    _RT_SHUTDOWN = -0xffff
    _RT_BASEMSG = -0xfff0
    _RT_DISCONNECTED = -0xfff0
    _RT_CONNECTED = -0xfff1
    _RT_LIVE = -0xfff2
    _RT_DELAYED = -0xfff3
    _RT_TYPELIB = -0xffe0
    _RT_TYPEOBJ = -0xffe1
    _RT_COMTYPES = -0xffe2

    @classmethod
    def getdata(cls, *args, **kwargs):
        &#39;&#39;&#39;Returns ``DataCls`` with args, kwargs&#39;&#39;&#39;
        return cls.DataCls(*args, **kwargs)

    @classmethod
    def getbroker(cls, *args, **kwargs):
        &#39;&#39;&#39;Returns broker with *args, **kwargs from registered ``BrokerCls``&#39;&#39;&#39;
        return cls.BrokerCls(*args, **kwargs)

    # DLLs to parse if found for TypeLibs
    VC64_DLLS = (&#39;VCDataSource64.dll&#39;, &#39;VCRealTimeLib64.dll&#39;,
                 &#39;COMTraderInterfaces64.dll&#39;,)

    VC_DLLS = (&#39;VCDataSource.dll&#39;, &#39;VCRealTimeLib.dll&#39;,
               &#39;COMTraderInterfaces.dll&#39;,)

    # Well known CLSDI
    VC_TLIBS = (
        [&#39;{EB2A77DC-A317-4160-8833-DECF16275A05}&#39;, 1, 0],  # vcdatasource64
        [&#39;{86F1DB04-2591-4866-A361-BB053D77FA18}&#39;, 1, 0],  # vcrealtime64
        [&#39;{20F8873C-35BE-4DB4-8C2A-0A8D40F8AEC3}&#39;, 1, 0],  # raderinterface64
    )

    VC_KEYNAME = r&#39;SOFTWARE\VCG\Visual Chart 6\Config&#39;
    VC_KEYVAL = &#39;Directory&#39;
    VC_BINPATH = &#39;bin&#39;

    def find_vchart(self):
        # Tries to locate VisualChart in the registry to get the installation
        # directory
        # If not found returns well-known typelibs clsid
        # Else it will scan the directory to locate the 64/32 bit dlls and
        # return the paths
        import _winreg  # keep import local to avoid breaking test cases

        vcdir = None

        # Search for Directory in the usual root keys
        for rkey in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE,):
            try:
                vckey = _winreg.OpenKey(rkey, self.VC_KEYNAME)
            except WindowsError as e:
                continue

            # Try to get the key value
            try:
                vcdir, _ = _winreg.QueryValueEx(vckey, self.VC_KEYVAL)
            except WindowsError as e:
                continue
            else:
                break  # found vcdir

        if vcdir is None:
            return self.VC_TLIBS  # no dir found, last resort

        # DLLs are in the bin directory
        vcbin = os.path.join(vcdir, self.VC_BINPATH)

        # Search for the 3 libraries (64/32 bits) in the found dir
        for dlls in (self.VC64_DLLS, self.VC_DLLS,):
            dfound = []
            for dll in dlls:
                fpath = os.path.join(vcbin, dll)
                if not os.path.isfile(fpath):
                    break
                dfound.append(fpath)

            if len(dfound) == len(dlls):
                return dfound

        # not all dlls were found, last resort
        return self.VC_TLIBS

    def _load_comtypes(self):
        # Keep comtypes imports local to avoid breaking testcases
        try:
            import comtypes
            self.comtypes = comtypes

            from comtypes.client import CreateObject, GetEvents, GetModule
            self.CreateObject = CreateObject
            self.GetEvents = GetEvents
            self.GetModule = GetModule
        except ImportError:
            return False

        return True  # notifiy comtypes was loaded

    def __init__(self):
        self._connected = False  # modules/objects created

        self.notifs = collections.deque()  # hold notifications to deliver

        self.t_vcconn = None  # control connection status

        # hold deques to market data symbols
        self._dqs = collections.deque()
        self._qdatas = dict()
        self._tftable = dict()

        if not self._load_comtypes():
            txt = &#39;Failed to import comtypes&#39;
            msg = self._RT_COMTYPES, txt
            self.put_notification(msg, *msg)
            return

        vctypelibs = self.find_vchart()
        # Try to load the modules
        try:
            self.vcdsmod = self.GetModule(vctypelibs[0])
            self.vcrtmod = self.GetModule(vctypelibs[1])
            self.vcctmod = self.GetModule(vctypelibs[2])
        except WindowsError as e:
            self.vcdsmod = None
            self.vcrtmod = None
            self.vcctmod = None
            txt = &#39;Failed to Load COM TypeLib Modules {}&#39;.format(e)
            msg = self._RT_TYPELIB, txt
            self.put_notification(msg, *msg)
            return

        # Try to load the main objects
        try:
            self.vcds = self.CreateObject(self.vcdsmod.DataSourceManager)
            # self.vcrt = self.CreateObject(self.vcrtmod.RealTime)
            self.vcct = self.CreateObject(self.vcctmod.Trader)
        except WindowsError as e:
            txt = (&#39;Failed to Load COM TypeLib Objects but the COM TypeLibs &#39;
                   &#39;have been loaded. If VisualChart has been recently &#39;
                   &#39;installed/updated, restarting Windows may be necessary &#39;
                   &#39;to register the Objects: {}&#39;.format(e))
            msg = self._RT_TYPELIB, txt
            self.put_notification(msg, *msg)
            self.vcds = None
            self.vcrt = None
            self.vcct = None
            return

        self._connected = True

        # Build a table of VCRT Field_XX mappings for debugging purposes
        self.vcrtfields = dict()
        for name in dir(self.vcrtmod):
            if name.startswith(&#39;Field&#39;):
                self.vcrtfields[getattr(self.vcrtmod, name)] = name

        # Modules and objects can be created
        self._tftable = {
            TimeFrame.Ticks: (self.vcdsmod.CT_Ticks, 1),
            TimeFrame.MicroSeconds: (self.vcdsmod.CT_Ticks, 1),  # To Resample
            TimeFrame.Seconds: (self.vcdsmod.CT_Ticks, 1),  # To Resample
            TimeFrame.Minutes: (self.vcdsmod.CT_Minutes, 1),
            TimeFrame.Days: (self.vcdsmod.CT_Days, 1),
            TimeFrame.Weeks: (self.vcdsmod.CT_Weeks, 1),
            TimeFrame.Months: (self.vcdsmod.CT_Months, 1),
            TimeFrame.Years: (self.vcdsmod.CT_Months, 12),
        }

    def put_notification(self, msg, *args, **kwargs):
        self.notifs.append((msg, args, kwargs))

    def get_notifications(self):
        &#39;&#39;&#39;Return the pending &#34;store&#34; notifications&#39;&#39;&#39;
        self.notifs.append(None)  # Mark current end of notifs
        return [x for x in iter(self.notifs.popleft, None)]  # popleft til None

    def start(self, data=None, broker=None):
        if not self._connected:
            return

        if self.t_vcconn is None:
            # Kickstart connection thread check
            self.t_vcconn = t = threading.Thread(target=self._start_vcrt)
            t.daemon = True  # Do not stop a general exit
            t.start()

        if broker is not None:
            t = threading.Thread(target=self._t_broker, args=(broker,))
            t.daemon = True
            t.start()

    def stop(self):
        pass  # nothing to do

    def connected(self):
        return self._connected

    def _start_vcrt(self):
        # Use VCRealTime to monitor the connection status
        self.comtypes.CoInitialize()  # running in another thread
        vcrt = self.CreateObject(self.vcrtmod.RealTime)
        sink = RTEventSink(self)
        conn = self.GetEvents(vcrt, sink)
        PumpEvents()
        self.comtypes.CoUninitialize()

    def _vcrt_connection(self, status):
        if status == -0xffff:
            txt = &#39;VisualChart shutting down&#39;,
        # p2: 0 -&gt; Disconnected /  p2: 1 -&gt; Reconnected
        elif status == -0xfff0:
            txt = &#39;VisualChart is Disconnected&#39;
        elif status == -0xfff1:
            txt = &#39;VisualChart is Connected&#39;
        else:
            txt = &#39;VisualChart unknown connection status &#39;

        msg = txt, status
        self.put_notification(msg, *msg)

        for q in self._dqs:
            q.put(status)

    def _tf2ct(self, timeframe, compression):
        # Translates timeframes to known compression types in VisualChart
        timeframe, extracomp = self._tftable[timeframe]
        return timeframe, compression * extracomp

    def _ticking(self, timeframe):
        # Translates timeframes to known compression types in VisualChart
        vctimeframe, _ = self._tftable[timeframe]
        return vctimeframe == self.vcdsmod.CT_Ticks

    def _getq(self, data):
        q = queue.Queue()
        self._dqs.append(q)
        self._qdatas[q] = data
        return q

    def _delq(self, q):
        self._dqs.remove(q)
        self._qdatas.pop(q)

    def _rtdata(self, data, symbol):
        kwargs = dict(data=data, symbol=symbol)
        t = threading.Thread(target=self._t_rtdata, kwargs=kwargs)
        t.daemon = True
        t.start()

    # Broker functions
    def _t_rtdata(self, data, symbol):
        self.comtypes.CoInitialize()  # running in another thread
        vcrt = self.CreateObject(self.vcrtmod.RealTime)
        conn = self.GetEvents(vcrt, data)
        data._vcrt = vcrt
        vcrt.RequestSymbolFeed(symbol, False)  # no limits
        PumpEvents()
        del conn  # ensure events go away
        self.comtypes.CoUninitialize()

    def _symboldata(self, symbol):

        # Assumption -&gt; we are connected and the symbol has been found
        self.vcds.ActiveEvents = 0
        # self.vcds.EventsType = self.vcdsmod.EF_Always

        serie = self.vcds.NewDataSerie(symbol,
                                       self.vcdsmod.CT_Days, 1,
                                       self.MAXDATE1, self.MAXDATE2)

        syminfo = _SymInfo(serie.GetSymbolInfo())
        self.vcds.DeleteDataSource(serie)
        return syminfo

    def _canceldirectdata(self, q):
        self._delq(q)

    def _directdata(self, data,
                    symbol, timeframe, compression, d1, d2=None,
                    historical=False):

        # Assume the data has checked the existence of the symbol
        timeframe, compression = self._tf2ct(timeframe, compression)
        kwargs = locals().copy()  # make a copy of the args
        kwargs.pop(&#39;self&#39;)
        kwargs[&#39;q&#39;] = q = self._getq(data)

        t = threading.Thread(target=self._t_directdata, kwargs=kwargs)
        t.daemon = True
        t.start()

        # use the queue to synchronize until symbolinfo has been gotten
        return q  # tell the caller where to expect the hist data

    def _t_directdata(self, data,
                      symbol, timeframe, compression, d1, d2, q,
                      historical):

        self.comtypes.CoInitialize()  # start com threading
        vcds = self.CreateObject(self.vcdsmod.DataSourceManager)

        historical = historical or d2 is not None
        if not historical:
            vcds.ActiveEvents = 1
            vcds.EventsType = self.vcdsmod.EF_Always
        else:
            vcds.ActiveEvents = 0

        if d2 is not None:
            serie = vcds.NewDataSerie(symbol, timeframe, compression, d1, d2)
        else:
            serie = vcds.NewDataSerie(symbol, timeframe, compression, d1)

        data._setserie(serie)

        # processing of bars can continue
        data.OnNewDataSerieBar(serie, forcepush=historical)
        if historical:  # push the last bar
            q.put(None)        # Signal end of transmission
            dsconn = None
        else:
            dsconn = self.GetEvents(vcds, data)  # finally connect the events
            pass

        # pump events in this thread - call ping
        PumpEvents(timeout=data._getpingtmout, cb=data.ping)
        if dsconn is not None:
            del dsconn  # Docs recommend deleting the connection

        # Delete the series before coming out of the thread
        vcds.DeleteDataSource(serie)
        self.comtypes.CoUninitialize()  # Terminate com threading

    # Broker functions
    def _t_broker(self, broker):
        self.comtypes.CoInitialize()  # running in another thread
        trader = self.CreateObject(self.vcctmod.Trader)
        conn = self.GetEvents(trader, broker(trader))
        PumpEvents()
        del conn  # ensure events go away
        self.comtypes.CoUninitialize()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.stores.vcstore.VCStore.BrokerCls"><code class="name">var <span class="ident">BrokerCls</span></code></dt>
<dd>
<div class="desc"><p>Broker implementation for VisualChart.</p>
<p>This class maps the orders/positions from VisualChart to the
internal API of <code><a title="backtrader" href="../index.html">backtrader</a></code>.</p>
<h2 id="params">Params</h2>
<ul>
<li><code>account</code> (default: None)</li>
</ul>
<p>VisualChart supports several accounts simultaneously on the broker. If
the default <code>None</code> is in place the 1st account in the ComTrader
<code>Accounts</code> collection will be used.</p>
<p>If an account name is provided, the <code>Accounts</code> collection will be
checked and used if present</p>
<ul>
<li><code>commission</code> (default: None)</li>
</ul>
<p>An object will be autogenerated if no commission-scheme is passed as
parameter</p>
<p>See the notes below for further explanations</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Position</li>
</ul>
<p>VisualChart reports "OpenPositions" updates through the ComTrader
interface but only when the position has a "size". An update to
indicate a position has moved to ZERO is reported by the absence of
such position. This forces to keep accounting of the positions by
looking at the execution events, just like the simulation broker does</p>
<ul>
<li>Commission</li>
</ul>
<p>The ComTrader interface of VisualChart does not report commissions and
as such the auto-generated CommissionInfo object cannot use
non-existent commissions to properly account for them. In order to
support commissions a <code>commission</code> parameter has to be passed with
the appropriate commission schemes.</p>
<p>The documentation on Commission Schemes details how to do this</p>
<ul>
<li>Expiration Timing</li>
</ul>
<p>The ComTrader interface (or is it the comtypes module?) discards
<code>time</code> information from <code>datetime</code> objects and expiration dates are
always full dates.</p>
<ul>
<li>Expiration Reporting</li>
</ul>
<p>At the moment no heuristic is in place to determine when a cancelled
order has been cancelled due to expiration. And therefore expired
orders are reported as cancelled.</p></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.DataCls"><code class="name">var <span class="ident">DataCls</span></code></dt>
<dd>
<div class="desc"><p>VisualChart Data Feed.</p>
<h2 id="params">Params</h2>
<ul>
<li><code>qcheck</code> (default: <code>0.5</code>)
Default timeout for waking up to let a resampler/replayer that the
current bar can be check for due delivery</li>
</ul>
<p>The value is only used if a resampling/replaying filter has been
inserted in the data</p>
<ul>
<li><code>historical</code> (default: <code>False</code>)
If no <code>todate</code> parameter is supplied (defined in the base class),
this will force a historical only download if set to <code>True</code></li>
</ul>
<p>If <code>todate</code> is supplied the same effect is achieved</p>
<ul>
<li><code>milliseconds</code> (default: <code>True</code>)
The bars constructed by <em>Visual Chart</em> have this aspect:
HH:MM:59.999000</li>
</ul>
<p>If this parameter is <code>True</code> a millisecond will be added to this time
to make it look like: HH::MM + 1:00.000000</p>
<ul>
<li>
<p><code>tradename</code> (default: <code>None</code>)
Continous futures cannot be traded but are ideal for data tracking. If
this parameter is supplied it will be the name of the current future
which will be the trading asset. Example:</p>
</li>
<li>
<p>001ES -&gt; ES-Mini continuous supplied as <code>dataname</code></p>
</li>
<li>
<p>ESU16 -&gt; ES-Mini 2016-09. If this is supplied in <code>tradename</code> it
will be the trading asset.</p>
</li>
<li>
<p><code>usetimezones</code> (default: <code>True</code>)
For most markets the time offset information provided by <em>Visual Chart</em>
allows for datetime to be converted to market time (<em>backtrader</em> choice
for representation)</p>
</li>
</ul>
<p>Some markets are special (<code>096</code>) and need special internal coverage
and timezone support to display in the user expected market time.</p>
<p>If this parameter is set to <code>True</code> importing <code>pytz</code> will be
attempted to use timezones (default)</p>
<p>Disabling it will remove timezone usage (may help if the load is
excesive)</p></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.MAXDATE1"><code class="name">var <span class="ident">MAXDATE1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.MAXDATE2"><code class="name">var <span class="ident">MAXDATE2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.MAXUINT"><code class="name">var <span class="ident">MAXUINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC64_DLLS"><code class="name">var <span class="ident">VC64_DLLS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC_BINPATH"><code class="name">var <span class="ident">VC_BINPATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC_DLLS"><code class="name">var <span class="ident">VC_DLLS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC_KEYNAME"><code class="name">var <span class="ident">VC_KEYNAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC_KEYVAL"><code class="name">var <span class="ident">VC_KEYVAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.VC_TLIBS"><code class="name">var <span class="ident">VC_TLIBS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="backtrader.stores.vcstore.VCStore.getbroker"><code class="name flex">
<span>def <span class="ident">getbroker</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns broker with <em>args, </em>*kwargs from registered <code>BrokerCls</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def getbroker(cls, *args, **kwargs):
    &#39;&#39;&#39;Returns broker with *args, **kwargs from registered ``BrokerCls``&#39;&#39;&#39;
    return cls.BrokerCls(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.getdata"><code class="name flex">
<span>def <span class="ident">getdata</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>DataCls</code> with args, kwargs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def getdata(cls, *args, **kwargs):
    &#39;&#39;&#39;Returns ``DataCls`` with args, kwargs&#39;&#39;&#39;
    return cls.DataCls(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.stores.vcstore.VCStore.connected"><code class="name flex">
<span>def <span class="ident">connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connected(self):
    return self._connected</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.find_vchart"><code class="name flex">
<span>def <span class="ident">find_vchart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_vchart(self):
    # Tries to locate VisualChart in the registry to get the installation
    # directory
    # If not found returns well-known typelibs clsid
    # Else it will scan the directory to locate the 64/32 bit dlls and
    # return the paths
    import _winreg  # keep import local to avoid breaking test cases

    vcdir = None

    # Search for Directory in the usual root keys
    for rkey in (_winreg.HKEY_CURRENT_USER, _winreg.HKEY_LOCAL_MACHINE,):
        try:
            vckey = _winreg.OpenKey(rkey, self.VC_KEYNAME)
        except WindowsError as e:
            continue

        # Try to get the key value
        try:
            vcdir, _ = _winreg.QueryValueEx(vckey, self.VC_KEYVAL)
        except WindowsError as e:
            continue
        else:
            break  # found vcdir

    if vcdir is None:
        return self.VC_TLIBS  # no dir found, last resort

    # DLLs are in the bin directory
    vcbin = os.path.join(vcdir, self.VC_BINPATH)

    # Search for the 3 libraries (64/32 bits) in the found dir
    for dlls in (self.VC64_DLLS, self.VC_DLLS,):
        dfound = []
        for dll in dlls:
            fpath = os.path.join(vcbin, dll)
            if not os.path.isfile(fpath):
                break
            dfound.append(fpath)

        if len(dfound) == len(dlls):
            return dfound

    # not all dlls were found, last resort
    return self.VC_TLIBS</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.get_notifications"><code class="name flex">
<span>def <span class="ident">get_notifications</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the pending "store" notifications</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_notifications(self):
    &#39;&#39;&#39;Return the pending &#34;store&#34; notifications&#39;&#39;&#39;
    self.notifs.append(None)  # Mark current end of notifs
    return [x for x in iter(self.notifs.popleft, None)]  # popleft til None</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.put_notification"><code class="name flex">
<span>def <span class="ident">put_notification</span></span>(<span>self, msg, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_notification(self, msg, *args, **kwargs):
    self.notifs.append((msg, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, data=None, broker=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self, data=None, broker=None):
    if not self._connected:
        return

    if self.t_vcconn is None:
        # Kickstart connection thread check
        self.t_vcconn = t = threading.Thread(target=self._start_vcrt)
        t.daemon = True  # Do not stop a general exit
        t.start()

    if broker is not None:
        t = threading.Thread(target=self._t_broker, args=(broker,))
        t.daemon = True
        t.start()</code></pre>
</details>
</dd>
<dt id="backtrader.stores.vcstore.VCStore.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    pass  # nothing to do</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader.stores" href="index.html">backtrader.stores</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backtrader.stores.vcstore.PumpEvents" href="#backtrader.stores.vcstore.PumpEvents">PumpEvents</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.stores.vcstore.MetaSingleton" href="#backtrader.stores.vcstore.MetaSingleton">MetaSingleton</a></code></h4>
</li>
<li>
<h4><code><a title="backtrader.stores.vcstore.RTEventSink" href="#backtrader.stores.vcstore.RTEventSink">RTEventSink</a></code></h4>
<ul class="">
<li><code><a title="backtrader.stores.vcstore.RTEventSink.OnInternalEvent" href="#backtrader.stores.vcstore.RTEventSink.OnInternalEvent">OnInternalEvent</a></code></li>
<li><code><a title="backtrader.stores.vcstore.RTEventSink.OnNewTicks" href="#backtrader.stores.vcstore.RTEventSink.OnNewTicks">OnNewTicks</a></code></li>
<li><code><a title="backtrader.stores.vcstore.RTEventSink.OnServerShutDown" href="#backtrader.stores.vcstore.RTEventSink.OnServerShutDown">OnServerShutDown</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.stores.vcstore.VCStore" href="#backtrader.stores.vcstore.VCStore">VCStore</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.stores.vcstore.VCStore.BrokerCls" href="#backtrader.stores.vcstore.VCStore.BrokerCls">BrokerCls</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.DataCls" href="#backtrader.stores.vcstore.VCStore.DataCls">DataCls</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.MAXDATE1" href="#backtrader.stores.vcstore.VCStore.MAXDATE1">MAXDATE1</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.MAXDATE2" href="#backtrader.stores.vcstore.VCStore.MAXDATE2">MAXDATE2</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.MAXUINT" href="#backtrader.stores.vcstore.VCStore.MAXUINT">MAXUINT</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC64_DLLS" href="#backtrader.stores.vcstore.VCStore.VC64_DLLS">VC64_DLLS</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC_BINPATH" href="#backtrader.stores.vcstore.VCStore.VC_BINPATH">VC_BINPATH</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC_DLLS" href="#backtrader.stores.vcstore.VCStore.VC_DLLS">VC_DLLS</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC_KEYNAME" href="#backtrader.stores.vcstore.VCStore.VC_KEYNAME">VC_KEYNAME</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC_KEYVAL" href="#backtrader.stores.vcstore.VCStore.VC_KEYVAL">VC_KEYVAL</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.VC_TLIBS" href="#backtrader.stores.vcstore.VCStore.VC_TLIBS">VC_TLIBS</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.connected" href="#backtrader.stores.vcstore.VCStore.connected">connected</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.find_vchart" href="#backtrader.stores.vcstore.VCStore.find_vchart">find_vchart</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.frompackages" href="#backtrader.stores.vcstore.VCStore.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.get_notifications" href="#backtrader.stores.vcstore.VCStore.get_notifications">get_notifications</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.getbroker" href="#backtrader.stores.vcstore.VCStore.getbroker">getbroker</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.getdata" href="#backtrader.stores.vcstore.VCStore.getdata">getdata</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.packages" href="#backtrader.stores.vcstore.VCStore.packages">packages</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.params" href="#backtrader.stores.vcstore.VCStore.params">params</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.put_notification" href="#backtrader.stores.vcstore.VCStore.put_notification">put_notification</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.start" href="#backtrader.stores.vcstore.VCStore.start">start</a></code></li>
<li><code><a title="backtrader.stores.vcstore.VCStore.stop" href="#backtrader.stores.vcstore.VCStore.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>