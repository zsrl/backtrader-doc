<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.lineiterator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.lineiterator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import collections
import operator
import sys

from .utils.py3 import map, range, zip, with_metaclass, string_types
from .utils import DotDict

from .lineroot import LineRoot, LineSingle
from .linebuffer import LineActions, LineNum
from .lineseries import LineSeries, LineSeriesMaker
from .dataseries import DataSeries
from . import metabase


class MetaLineIterator(LineSeries.__class__):
    def donew(cls, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).donew(*args, **kwargs)

        # Prepare to hold children that need to be calculated and
        # influence minperiod - Moved here to support LineNum below
        _obj._lineiterators = collections.defaultdict(list)

        # Scan args for datas ... if none are found,
        # use the _owner (to have a clock)
        mindatas = _obj._mindatas
        lastarg = 0
        _obj.datas = []
        for arg in args:
            if isinstance(arg, LineRoot):
                _obj.datas.append(LineSeriesMaker(arg))

            elif not mindatas:
                break  # found not data and must not be collected
            else:
                try:
                    _obj.datas.append(LineSeriesMaker(LineNum(arg)))
                except:
                    # Not a LineNum and is not a LineSeries - bail out
                    break

            mindatas = max(0, mindatas - 1)
            lastarg += 1

        newargs = args[lastarg:]

        # If no datas have been passed to an indicator ... use the
        # main datas of the owner, easing up adding &#34;self.data&#34; ...
        if not _obj.datas and isinstance(_obj, (IndicatorBase, ObserverBase)):
            _obj.datas = _obj._owner.datas[0:mindatas]

        # Create a dictionary to be able to check for presence
        # lists in python use &#34;==&#34; operator when testing for presence with &#34;in&#34;
        # which doesn&#39;t really check for presence but for equality
        _obj.ddatas = {x: None for x in _obj.datas}

        # For each found data add access member -
        # for the first data 2 (data and data0)
        if _obj.datas:
            _obj.data = data = _obj.datas[0]

            for l, line in enumerate(data.lines):
                linealias = data._getlinealias(l)
                if linealias:
                    setattr(_obj, &#39;data_%s&#39; % linealias, line)
                setattr(_obj, &#39;data_%d&#39; % l, line)

            for d, data in enumerate(_obj.datas):
                setattr(_obj, &#39;data%d&#39; % d, data)

                for l, line in enumerate(data.lines):
                    linealias = data._getlinealias(l)
                    if linealias:
                        setattr(_obj, &#39;data%d_%s&#39; % (d, linealias), line)
                    setattr(_obj, &#39;data%d_%d&#39; % (d, l), line)

        # Parameter values have now been set before __init__
        _obj.dnames = DotDict([(d._name, d)
                               for d in _obj.datas if getattr(d, &#39;_name&#39;, &#39;&#39;)])

        return _obj, newargs, kwargs

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).dopreinit(_obj, *args, **kwargs)

        # if no datas were found use, use the _owner (to have a clock)
        _obj.datas = _obj.datas or [_obj._owner]

        # 1st data source is our ticking clock
        _obj._clock = _obj.datas[0]

        # To automatically set the period Start by scanning the found datas
        # No calculation can take place until all datas have yielded &#34;data&#34;
        # A data could be an indicator and it could take x bars until
        # something is produced
        _obj._minperiod = \
            max([x._minperiod for x in _obj.datas] or [_obj._minperiod])

        # The lines carry at least the same minperiod as
        # that provided by the datas
        for line in _obj.lines:
            line.addminperiod(_obj._minperiod)

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).dopostinit(_obj, *args, **kwargs)

        # my minperiod is as large as the minperiod of my lines
        _obj._minperiod = max([x._minperiod for x in _obj.lines])

        # Recalc the period
        _obj._periodrecalc()

        # Register (my)self as indicator to owner once
        # _minperiod has been calculated
        if _obj._owner is not None:
            _obj._owner.addindicator(_obj)

        return _obj, args, kwargs


class LineIterator(with_metaclass(MetaLineIterator, LineSeries)):
    _nextforce = False  # force cerebro to run in next mode (runonce=False)

    _mindatas = 1
    _ltype = LineSeries.IndType

    plotinfo = dict(plot=True,
                    subplot=True,
                    plotname=&#39;&#39;,
                    plotskip=False,
                    plotabove=False,
                    plotlinelabels=False,
                    plotlinevalues=True,
                    plotvaluetags=True,
                    plotymargin=0.0,
                    plotyhlines=[],
                    plotyticks=[],
                    plothlines=[],
                    plotforce=False,
                    plotmaster=None,)

    def _periodrecalc(self):
        # last check in case not all lineiterators were assigned to
        # lines (directly or indirectly after some operations)
        # An example is Kaufman&#39;s Adaptive Moving Average
        indicators = self._lineiterators[LineIterator.IndType]
        indperiods = [ind._minperiod for ind in indicators]
        indminperiod = max(indperiods or [self._minperiod])
        self.updateminperiod(indminperiod)

    def _stage2(self):
        super(LineIterator, self)._stage2()

        for data in self.datas:
            data._stage2()

        for lineiterators in self._lineiterators.values():
            for lineiterator in lineiterators:
                lineiterator._stage2()

    def _stage1(self):
        super(LineIterator, self)._stage1()

        for data in self.datas:
            data._stage1()

        for lineiterators in self._lineiterators.values():
            for lineiterator in lineiterators:
                lineiterator._stage1()

    def getindicators(self):
        return self._lineiterators[LineIterator.IndType]

    def getindicators_lines(self):
        return [x for x in self._lineiterators[LineIterator.IndType]
                if hasattr(x.lines, &#39;getlinealiases&#39;)]

    def getobservers(self):
        return self._lineiterators[LineIterator.ObsType]

    def addindicator(self, indicator):
        # store in right queue
        self._lineiterators[indicator._ltype].append(indicator)

        # use getattr because line buffers don&#39;t have this attribute
        if getattr(indicator, &#39;_nextforce&#39;, False):
            # the indicator needs runonce=False
            o = self
            while o is not None:
                if o._ltype == LineIterator.StratType:
                    o.cerebro._disable_runonce()
                    break

                o = o._owner  # move up the hierarchy

    def bindlines(self, owner=None, own=None):
        if not owner:
            owner = 0

        if isinstance(owner, string_types):
            owner = [owner]
        elif not isinstance(owner, collections.Iterable):
            owner = [owner]

        if not own:
            own = range(len(owner))

        if isinstance(own, string_types):
            own = [own]
        elif not isinstance(own, collections.Iterable):
            own = [own]

        for lineowner, lineown in zip(owner, own):
            if isinstance(lineowner, string_types):
                lownerref = getattr(self._owner.lines, lineowner)
            else:
                lownerref = self._owner.lines[lineowner]

            if isinstance(lineown, string_types):
                lownref = getattr(self.lines, lineown)
            else:
                lownref = self.lines[lineown]

            lownref.addbinding(lownerref)

        return self

    # Alias which may be more readable
    bind2lines = bindlines
    bind2line = bind2lines

    def _next(self):
        clock_len = self._clk_update()

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator._next()

        self._notify()

        if self._ltype == LineIterator.StratType:
            # supporting datas with different lengths
            minperstatus = self._getminperstatus()
            if minperstatus &lt; 0:
                self.next()
            elif minperstatus == 0:
                self.nextstart()  # only called for the 1st value
            else:
                self.prenext()
        else:
            # assume indicators and others operate on same length datas
            # although the above operation can be generalized
            if clock_len &gt; self._minperiod:
                self.next()
            elif clock_len == self._minperiod:
                self.nextstart()  # only called for the 1st value
            elif clock_len:
                self.prenext()

    def _clk_update(self):
        clock_len = len(self._clock)
        if clock_len != len(self):
            self.forward()

        return clock_len

    def _once(self):
        self.forward(size=self._clock.buflen())

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator._once()

        for observer in self._lineiterators[LineIterator.ObsType]:
            observer.forward(size=self.buflen())

        for data in self.datas:
            data.home()

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator.home()

        for observer in self._lineiterators[LineIterator.ObsType]:
            observer.home()

        self.home()

        # These 3 remain empty for a strategy and therefore play no role
        # because a strategy will always be executed on a next basis
        # indicators are each called with its min period
        self.preonce(0, self._minperiod - 1)
        self.oncestart(self._minperiod - 1, self._minperiod)
        self.once(self._minperiod, self.buflen())

        for line in self.lines:
            line.oncebinding()

    def preonce(self, start, end):
        pass

    def oncestart(self, start, end):
        self.once(start, end)

    def once(self, start, end):
        pass

    def prenext(self):
        &#39;&#39;&#39;
        This method will be called before the minimum period of all
        datas/indicators have been meet for the strategy to start executing
        &#39;&#39;&#39;
        pass

    def nextstart(self):
        &#39;&#39;&#39;
        This method will be called once, exactly when the minimum period for
        all datas/indicators have been meet. The default behavior is to call
        next
        &#39;&#39;&#39;

        # Called once for 1st full calculation - defaults to regular next
        self.next()

    def next(self):
        &#39;&#39;&#39;
        This method will be called for all remaining data points when the
        minimum period for all datas/indicators have been meet.
        &#39;&#39;&#39;
        pass

    def _addnotification(self, *args, **kwargs):
        pass

    def _notify(self):
        pass

    def _plotinit(self):
        pass

    def qbuffer(self, savemem=0):
        if savemem:
            for line in self.lines:
                line.qbuffer()

        # If called, anything under it, must save
        for obj in self._lineiterators[self.IndType]:
            obj.qbuffer(savemem=1)

        # Tell datas to adjust buffer to minimum period
        for data in self.datas:
            data.minbuffer(self._minperiod)


# This 3 subclasses can be used for identification purposes within LineIterator
# or even outside (like in LineObservers)
# for the 3 subbranches without generating circular import references

class DataAccessor(LineIterator):
    PriceClose = DataSeries.Close
    PriceLow = DataSeries.Low
    PriceHigh = DataSeries.High
    PriceOpen = DataSeries.Open
    PriceVolume = DataSeries.Volume
    PriceOpenInteres = DataSeries.OpenInterest
    PriceDateTime = DataSeries.DateTime


class IndicatorBase(DataAccessor):
    pass


class ObserverBase(DataAccessor):
    pass


class StrategyBase(DataAccessor):
    pass


# Utility class to couple lines/lineiterators which may have different lengths
# Will only work when runonce=False is passed to Cerebro

class SingleCoupler(LineActions):
    def __init__(self, cdata, clock=None):
        super(SingleCoupler, self).__init__()
        self._clock = clock if clock is not None else self._owner

        self.cdata = cdata
        self.dlen = 0
        self.val = float(&#39;NaN&#39;)

    def next(self):
        if len(self.cdata) &gt; self.dlen:
            self.val = self.cdata[0]
            self.dlen += 1

        self[0] = self.val


class MultiCoupler(LineIterator):
    _ltype = LineIterator.IndType

    def __init__(self):
        super(MultiCoupler, self).__init__()
        self.dlen = 0
        self.dsize = self.fullsize()  # shorcut for number of lines
        self.dvals = [float(&#39;NaN&#39;)] * self.dsize

    def next(self):
        if len(self.data) &gt; self.dlen:
            self.dlen += 1

            for i in range(self.dsize):
                self.dvals[i] = self.data.lines[i][0]

        for i in range(self.dsize):
            self.lines[i][0] = self.dvals[i]


def LinesCoupler(cdata, clock=None, **kwargs):
    if isinstance(cdata, LineSingle):
        return SingleCoupler(cdata, clock)  # return for single line

    cdatacls = cdata.__class__  # copy important structures before creation
    try:
        LinesCoupler.counter += 1  # counter for unique class name
    except AttributeError:
        LinesCoupler.counter = 0

    # Prepare a MultiCoupler subclass
    nclsname = str(&#39;LinesCoupler_%d&#39; % LinesCoupler.counter)
    ncls = type(nclsname, (MultiCoupler,), {})
    thismod = sys.modules[LinesCoupler.__module__]
    setattr(thismod, ncls.__name__, ncls)
    # Replace lines et al., to get a sensible clone
    ncls.lines = cdatacls.lines
    ncls.params = cdatacls.params
    ncls.plotinfo = cdatacls.plotinfo
    ncls.plotlines = cdatacls.plotlines

    obj = ncls(cdata, **kwargs)  # instantiate
    # The clock is set here to avoid it being interpreted as a data by the
    # LineIterator background scanning code
    if clock is None:
        clock = getattr(cdata, &#39;_clock&#39;, None)
        if clock is not None:
            nclock = getattr(clock, &#39;_clock&#39;, None)
            if nclock is not None:
                clock = nclock
            else:
                nclock = getattr(clock, &#39;data&#39;, None)
                if nclock is not None:
                    clock = nclock

        if clock is None:
            clock = obj._owner

    obj._clock = clock
    return obj


# Add an alias (which seems a lot more sensible for &#34;Single Line&#34; lines
LineCoupler = LinesCoupler</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="backtrader.lineiterator.LineCoupler"><code class="name flex">
<span>def <span class="ident">LineCoupler</span></span>(<span>cdata, clock=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LinesCoupler(cdata, clock=None, **kwargs):
    if isinstance(cdata, LineSingle):
        return SingleCoupler(cdata, clock)  # return for single line

    cdatacls = cdata.__class__  # copy important structures before creation
    try:
        LinesCoupler.counter += 1  # counter for unique class name
    except AttributeError:
        LinesCoupler.counter = 0

    # Prepare a MultiCoupler subclass
    nclsname = str(&#39;LinesCoupler_%d&#39; % LinesCoupler.counter)
    ncls = type(nclsname, (MultiCoupler,), {})
    thismod = sys.modules[LinesCoupler.__module__]
    setattr(thismod, ncls.__name__, ncls)
    # Replace lines et al., to get a sensible clone
    ncls.lines = cdatacls.lines
    ncls.params = cdatacls.params
    ncls.plotinfo = cdatacls.plotinfo
    ncls.plotlines = cdatacls.plotlines

    obj = ncls(cdata, **kwargs)  # instantiate
    # The clock is set here to avoid it being interpreted as a data by the
    # LineIterator background scanning code
    if clock is None:
        clock = getattr(cdata, &#39;_clock&#39;, None)
        if clock is not None:
            nclock = getattr(clock, &#39;_clock&#39;, None)
            if nclock is not None:
                clock = nclock
            else:
                nclock = getattr(clock, &#39;data&#39;, None)
                if nclock is not None:
                    clock = nclock

        if clock is None:
            clock = obj._owner

    obj._clock = clock
    return obj</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LinesCoupler"><code class="name flex">
<span>def <span class="ident">LinesCoupler</span></span>(<span>cdata, clock=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LinesCoupler(cdata, clock=None, **kwargs):
    if isinstance(cdata, LineSingle):
        return SingleCoupler(cdata, clock)  # return for single line

    cdatacls = cdata.__class__  # copy important structures before creation
    try:
        LinesCoupler.counter += 1  # counter for unique class name
    except AttributeError:
        LinesCoupler.counter = 0

    # Prepare a MultiCoupler subclass
    nclsname = str(&#39;LinesCoupler_%d&#39; % LinesCoupler.counter)
    ncls = type(nclsname, (MultiCoupler,), {})
    thismod = sys.modules[LinesCoupler.__module__]
    setattr(thismod, ncls.__name__, ncls)
    # Replace lines et al., to get a sensible clone
    ncls.lines = cdatacls.lines
    ncls.params = cdatacls.params
    ncls.plotinfo = cdatacls.plotinfo
    ncls.plotlines = cdatacls.plotlines

    obj = ncls(cdata, **kwargs)  # instantiate
    # The clock is set here to avoid it being interpreted as a data by the
    # LineIterator background scanning code
    if clock is None:
        clock = getattr(cdata, &#39;_clock&#39;, None)
        if clock is not None:
            nclock = getattr(clock, &#39;_clock&#39;, None)
            if nclock is not None:
                clock = nclock
            else:
                nclock = getattr(clock, &#39;data&#39;, None)
                if nclock is not None:
                    clock = nclock

        if clock is None:
            clock = obj._owner

    obj._clock = clock
    return obj</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.lineiterator.DataAccessor"><code class="flex name class">
<span>class <span class="ident">DataAccessor</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataAccessor(LineIterator):
    PriceClose = DataSeries.Close
    PriceLow = DataSeries.Low
    PriceHigh = DataSeries.High
    PriceOpen = DataSeries.Open
    PriceVolume = DataSeries.Volume
    PriceOpenInteres = DataSeries.OpenInterest
    PriceDateTime = DataSeries.DateTime</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.IndicatorBase" href="#backtrader.lineiterator.IndicatorBase">IndicatorBase</a></li>
<li><a title="backtrader.lineiterator.ObserverBase" href="#backtrader.lineiterator.ObserverBase">ObserverBase</a></li>
<li><a title="backtrader.lineiterator.StrategyBase" href="#backtrader.lineiterator.StrategyBase">StrategyBase</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.DataAccessor.PriceClose"><code class="name">var <span class="ident">PriceClose</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceDateTime"><code class="name">var <span class="ident">PriceDateTime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceHigh"><code class="name">var <span class="ident">PriceHigh</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceLow"><code class="name">var <span class="ident">PriceLow</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceOpen"><code class="name">var <span class="ident">PriceOpen</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceOpenInteres"><code class="name">var <span class="ident">PriceOpenInteres</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.PriceVolume"><code class="name">var <span class="ident">PriceVolume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.DataAccessor.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.LineIterator.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase"><code class="flex name class">
<span>class <span class="ident">IndicatorBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndicatorBase(DataAccessor):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.indicator.Indicator" href="indicator.html#backtrader.indicator.Indicator">Indicator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.IndicatorBase.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.IndicatorBase.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.DataAccessor.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.LineIterator"><code class="flex name class">
<span>class <span class="ident">LineIterator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LineIterator(with_metaclass(MetaLineIterator, LineSeries)):
    _nextforce = False  # force cerebro to run in next mode (runonce=False)

    _mindatas = 1
    _ltype = LineSeries.IndType

    plotinfo = dict(plot=True,
                    subplot=True,
                    plotname=&#39;&#39;,
                    plotskip=False,
                    plotabove=False,
                    plotlinelabels=False,
                    plotlinevalues=True,
                    plotvaluetags=True,
                    plotymargin=0.0,
                    plotyhlines=[],
                    plotyticks=[],
                    plothlines=[],
                    plotforce=False,
                    plotmaster=None,)

    def _periodrecalc(self):
        # last check in case not all lineiterators were assigned to
        # lines (directly or indirectly after some operations)
        # An example is Kaufman&#39;s Adaptive Moving Average
        indicators = self._lineiterators[LineIterator.IndType]
        indperiods = [ind._minperiod for ind in indicators]
        indminperiod = max(indperiods or [self._minperiod])
        self.updateminperiod(indminperiod)

    def _stage2(self):
        super(LineIterator, self)._stage2()

        for data in self.datas:
            data._stage2()

        for lineiterators in self._lineiterators.values():
            for lineiterator in lineiterators:
                lineiterator._stage2()

    def _stage1(self):
        super(LineIterator, self)._stage1()

        for data in self.datas:
            data._stage1()

        for lineiterators in self._lineiterators.values():
            for lineiterator in lineiterators:
                lineiterator._stage1()

    def getindicators(self):
        return self._lineiterators[LineIterator.IndType]

    def getindicators_lines(self):
        return [x for x in self._lineiterators[LineIterator.IndType]
                if hasattr(x.lines, &#39;getlinealiases&#39;)]

    def getobservers(self):
        return self._lineiterators[LineIterator.ObsType]

    def addindicator(self, indicator):
        # store in right queue
        self._lineiterators[indicator._ltype].append(indicator)

        # use getattr because line buffers don&#39;t have this attribute
        if getattr(indicator, &#39;_nextforce&#39;, False):
            # the indicator needs runonce=False
            o = self
            while o is not None:
                if o._ltype == LineIterator.StratType:
                    o.cerebro._disable_runonce()
                    break

                o = o._owner  # move up the hierarchy

    def bindlines(self, owner=None, own=None):
        if not owner:
            owner = 0

        if isinstance(owner, string_types):
            owner = [owner]
        elif not isinstance(owner, collections.Iterable):
            owner = [owner]

        if not own:
            own = range(len(owner))

        if isinstance(own, string_types):
            own = [own]
        elif not isinstance(own, collections.Iterable):
            own = [own]

        for lineowner, lineown in zip(owner, own):
            if isinstance(lineowner, string_types):
                lownerref = getattr(self._owner.lines, lineowner)
            else:
                lownerref = self._owner.lines[lineowner]

            if isinstance(lineown, string_types):
                lownref = getattr(self.lines, lineown)
            else:
                lownref = self.lines[lineown]

            lownref.addbinding(lownerref)

        return self

    # Alias which may be more readable
    bind2lines = bindlines
    bind2line = bind2lines

    def _next(self):
        clock_len = self._clk_update()

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator._next()

        self._notify()

        if self._ltype == LineIterator.StratType:
            # supporting datas with different lengths
            minperstatus = self._getminperstatus()
            if minperstatus &lt; 0:
                self.next()
            elif minperstatus == 0:
                self.nextstart()  # only called for the 1st value
            else:
                self.prenext()
        else:
            # assume indicators and others operate on same length datas
            # although the above operation can be generalized
            if clock_len &gt; self._minperiod:
                self.next()
            elif clock_len == self._minperiod:
                self.nextstart()  # only called for the 1st value
            elif clock_len:
                self.prenext()

    def _clk_update(self):
        clock_len = len(self._clock)
        if clock_len != len(self):
            self.forward()

        return clock_len

    def _once(self):
        self.forward(size=self._clock.buflen())

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator._once()

        for observer in self._lineiterators[LineIterator.ObsType]:
            observer.forward(size=self.buflen())

        for data in self.datas:
            data.home()

        for indicator in self._lineiterators[LineIterator.IndType]:
            indicator.home()

        for observer in self._lineiterators[LineIterator.ObsType]:
            observer.home()

        self.home()

        # These 3 remain empty for a strategy and therefore play no role
        # because a strategy will always be executed on a next basis
        # indicators are each called with its min period
        self.preonce(0, self._minperiod - 1)
        self.oncestart(self._minperiod - 1, self._minperiod)
        self.once(self._minperiod, self.buflen())

        for line in self.lines:
            line.oncebinding()

    def preonce(self, start, end):
        pass

    def oncestart(self, start, end):
        self.once(start, end)

    def once(self, start, end):
        pass

    def prenext(self):
        &#39;&#39;&#39;
        This method will be called before the minimum period of all
        datas/indicators have been meet for the strategy to start executing
        &#39;&#39;&#39;
        pass

    def nextstart(self):
        &#39;&#39;&#39;
        This method will be called once, exactly when the minimum period for
        all datas/indicators have been meet. The default behavior is to call
        next
        &#39;&#39;&#39;

        # Called once for 1st full calculation - defaults to regular next
        self.next()

    def next(self):
        &#39;&#39;&#39;
        This method will be called for all remaining data points when the
        minimum period for all datas/indicators have been meet.
        &#39;&#39;&#39;
        pass

    def _addnotification(self, *args, **kwargs):
        pass

    def _notify(self):
        pass

    def _plotinit(self):
        pass

    def qbuffer(self, savemem=0):
        if savemem:
            for line in self.lines:
                line.qbuffer()

        # If called, anything under it, must save
        for obj in self._lineiterators[self.IndType]:
            obj.qbuffer(savemem=1)

        # Tell datas to adjust buffer to minimum period
        for data in self.datas:
            data.minbuffer(self._minperiod)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.MultiCoupler" href="#backtrader.lineiterator.MultiCoupler">MultiCoupler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.LineIterator.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.LineIterator.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.lineiterator.LineIterator.addindicator"><code class="name flex">
<span>def <span class="ident">addindicator</span></span>(<span>self, indicator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addindicator(self, indicator):
    # store in right queue
    self._lineiterators[indicator._ltype].append(indicator)

    # use getattr because line buffers don&#39;t have this attribute
    if getattr(indicator, &#39;_nextforce&#39;, False):
        # the indicator needs runonce=False
        o = self
        while o is not None:
            if o._ltype == LineIterator.StratType:
                o.cerebro._disable_runonce()
                break

            o = o._owner  # move up the hierarchy</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.bind2line"><code class="name flex">
<span>def <span class="ident">bind2line</span></span>(<span>self, owner=None, own=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindlines(self, owner=None, own=None):
    if not owner:
        owner = 0

    if isinstance(owner, string_types):
        owner = [owner]
    elif not isinstance(owner, collections.Iterable):
        owner = [owner]

    if not own:
        own = range(len(owner))

    if isinstance(own, string_types):
        own = [own]
    elif not isinstance(own, collections.Iterable):
        own = [own]

    for lineowner, lineown in zip(owner, own):
        if isinstance(lineowner, string_types):
            lownerref = getattr(self._owner.lines, lineowner)
        else:
            lownerref = self._owner.lines[lineowner]

        if isinstance(lineown, string_types):
            lownref = getattr(self.lines, lineown)
        else:
            lownref = self.lines[lineown]

        lownref.addbinding(lownerref)

    return self</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.bind2lines"><code class="name flex">
<span>def <span class="ident">bind2lines</span></span>(<span>self, owner=None, own=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindlines(self, owner=None, own=None):
    if not owner:
        owner = 0

    if isinstance(owner, string_types):
        owner = [owner]
    elif not isinstance(owner, collections.Iterable):
        owner = [owner]

    if not own:
        own = range(len(owner))

    if isinstance(own, string_types):
        own = [own]
    elif not isinstance(own, collections.Iterable):
        own = [own]

    for lineowner, lineown in zip(owner, own):
        if isinstance(lineowner, string_types):
            lownerref = getattr(self._owner.lines, lineowner)
        else:
            lownerref = self._owner.lines[lineowner]

        if isinstance(lineown, string_types):
            lownref = getattr(self.lines, lineown)
        else:
            lownref = self.lines[lineown]

        lownref.addbinding(lownerref)

    return self</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.bindlines"><code class="name flex">
<span>def <span class="ident">bindlines</span></span>(<span>self, owner=None, own=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bindlines(self, owner=None, own=None):
    if not owner:
        owner = 0

    if isinstance(owner, string_types):
        owner = [owner]
    elif not isinstance(owner, collections.Iterable):
        owner = [owner]

    if not own:
        own = range(len(owner))

    if isinstance(own, string_types):
        own = [own]
    elif not isinstance(own, collections.Iterable):
        own = [own]

    for lineowner, lineown in zip(owner, own):
        if isinstance(lineowner, string_types):
            lownerref = getattr(self._owner.lines, lineowner)
        else:
            lownerref = self._owner.lines[lineowner]

        if isinstance(lineown, string_types):
            lownref = getattr(self.lines, lineown)
        else:
            lownref = self.lines[lineown]

        lownref.addbinding(lownerref)

    return self</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.getindicators"><code class="name flex">
<span>def <span class="ident">getindicators</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getindicators(self):
    return self._lineiterators[LineIterator.IndType]</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.getindicators_lines"><code class="name flex">
<span>def <span class="ident">getindicators_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getindicators_lines(self):
    return [x for x in self._lineiterators[LineIterator.IndType]
            if hasattr(x.lines, &#39;getlinealiases&#39;)]</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.getobservers"><code class="name flex">
<span>def <span class="ident">getobservers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getobservers(self):
    return self._lineiterators[LineIterator.ObsType]</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.next"><code class="name flex">
<span>def <span class="ident">next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will be called for all remaining data points when the
minimum period for all datas/indicators have been meet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next(self):
    &#39;&#39;&#39;
    This method will be called for all remaining data points when the
    minimum period for all datas/indicators have been meet.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.nextstart"><code class="name flex">
<span>def <span class="ident">nextstart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will be called once, exactly when the minimum period for
all datas/indicators have been meet. The default behavior is to call
next</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextstart(self):
    &#39;&#39;&#39;
    This method will be called once, exactly when the minimum period for
    all datas/indicators have been meet. The default behavior is to call
    next
    &#39;&#39;&#39;

    # Called once for 1st full calculation - defaults to regular next
    self.next()</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.LineIterator.prenext"><code class="name flex">
<span>def <span class="ident">prenext</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will be called before the minimum period of all
datas/indicators have been meet for the strategy to start executing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prenext(self):
    &#39;&#39;&#39;
    This method will be called before the minimum period of all
    datas/indicators have been meet for the strategy to start executing
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineseries.LineSeries.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineseries.LineSeries.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.MetaLineIterator"><code class="flex name class">
<span>class <span class="ident">MetaLineIterator</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Dirty job manager for a LineSeries</p>
<ul>
<li>
<p>During <strong>new</strong> (class creation), it reads "lines", "plotinfo",
"plotlines" class variable definitions and turns them into
Classes of type Lines or AutoClassInfo (plotinfo/plotlines)</p>
</li>
<li>
<p>During "new" (instance creation) the lines/plotinfo/plotlines
classes are substituted in the instance with instances of the
aforementioned classes and aliases are added for the "lines" held
in the "lines" instance</p>
<p>Additionally and for remaining kwargs, these are matched against
args in plotinfo and if existent are set there and removed from kwargs</p>
<p>Remember that this Metaclass has a MetaParams (from metabase)
as root class and therefore "params" defined for the class have been
removed from kwargs at an earlier state</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaLineIterator(LineSeries.__class__):
    def donew(cls, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).donew(*args, **kwargs)

        # Prepare to hold children that need to be calculated and
        # influence minperiod - Moved here to support LineNum below
        _obj._lineiterators = collections.defaultdict(list)

        # Scan args for datas ... if none are found,
        # use the _owner (to have a clock)
        mindatas = _obj._mindatas
        lastarg = 0
        _obj.datas = []
        for arg in args:
            if isinstance(arg, LineRoot):
                _obj.datas.append(LineSeriesMaker(arg))

            elif not mindatas:
                break  # found not data and must not be collected
            else:
                try:
                    _obj.datas.append(LineSeriesMaker(LineNum(arg)))
                except:
                    # Not a LineNum and is not a LineSeries - bail out
                    break

            mindatas = max(0, mindatas - 1)
            lastarg += 1

        newargs = args[lastarg:]

        # If no datas have been passed to an indicator ... use the
        # main datas of the owner, easing up adding &#34;self.data&#34; ...
        if not _obj.datas and isinstance(_obj, (IndicatorBase, ObserverBase)):
            _obj.datas = _obj._owner.datas[0:mindatas]

        # Create a dictionary to be able to check for presence
        # lists in python use &#34;==&#34; operator when testing for presence with &#34;in&#34;
        # which doesn&#39;t really check for presence but for equality
        _obj.ddatas = {x: None for x in _obj.datas}

        # For each found data add access member -
        # for the first data 2 (data and data0)
        if _obj.datas:
            _obj.data = data = _obj.datas[0]

            for l, line in enumerate(data.lines):
                linealias = data._getlinealias(l)
                if linealias:
                    setattr(_obj, &#39;data_%s&#39; % linealias, line)
                setattr(_obj, &#39;data_%d&#39; % l, line)

            for d, data in enumerate(_obj.datas):
                setattr(_obj, &#39;data%d&#39; % d, data)

                for l, line in enumerate(data.lines):
                    linealias = data._getlinealias(l)
                    if linealias:
                        setattr(_obj, &#39;data%d_%s&#39; % (d, linealias), line)
                    setattr(_obj, &#39;data%d_%d&#39; % (d, l), line)

        # Parameter values have now been set before __init__
        _obj.dnames = DotDict([(d._name, d)
                               for d in _obj.datas if getattr(d, &#39;_name&#39;, &#39;&#39;)])

        return _obj, newargs, kwargs

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).dopreinit(_obj, *args, **kwargs)

        # if no datas were found use, use the _owner (to have a clock)
        _obj.datas = _obj.datas or [_obj._owner]

        # 1st data source is our ticking clock
        _obj._clock = _obj.datas[0]

        # To automatically set the period Start by scanning the found datas
        # No calculation can take place until all datas have yielded &#34;data&#34;
        # A data could be an indicator and it could take x bars until
        # something is produced
        _obj._minperiod = \
            max([x._minperiod for x in _obj.datas] or [_obj._minperiod])

        # The lines carry at least the same minperiod as
        # that provided by the datas
        for line in _obj.lines:
            line.addminperiod(_obj._minperiod)

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaLineIterator, cls).dopostinit(_obj, *args, **kwargs)

        # my minperiod is as large as the minperiod of my lines
        _obj._minperiod = max([x._minperiod for x in _obj.lines])

        # Recalc the period
        _obj._periodrecalc()

        # Register (my)self as indicator to owner once
        # _minperiod has been calculated
        if _obj._owner is not None:
            _obj._owner.addindicator(_obj)

        return _obj, args, kwargs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineseries.MetaLineSeries" href="lineseries.html#backtrader.lineseries.MetaLineSeries">MetaLineSeries</a></li>
<li><a title="backtrader.lineroot.MetaLineRoot" href="lineroot.html#backtrader.lineroot.MetaLineRoot">MetaLineRoot</a></li>
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.indicator.MetaIndicator" href="indicator.html#backtrader.indicator.MetaIndicator">MetaIndicator</a></li>
<li><a title="backtrader.observer.MetaObserver" href="observer.html#backtrader.observer.MetaObserver">MetaObserver</a></li>
<li><a title="backtrader.strategy.MetaStrategy" href="strategy.html#backtrader.strategy.MetaStrategy">MetaStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backtrader.lineiterator.MetaLineIterator.dopostinit"><code class="name flex">
<span>def <span class="ident">dopostinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopostinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaLineIterator, cls).dopostinit(_obj, *args, **kwargs)

    # my minperiod is as large as the minperiod of my lines
    _obj._minperiod = max([x._minperiod for x in _obj.lines])

    # Recalc the period
    _obj._periodrecalc()

    # Register (my)self as indicator to owner once
    # _minperiod has been calculated
    if _obj._owner is not None:
        _obj._owner.addindicator(_obj)

    return _obj, args, kwargs</code></pre>
</details>
</dd>
<dt id="backtrader.lineiterator.MetaLineIterator.dopreinit"><code class="name flex">
<span>def <span class="ident">dopreinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopreinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaLineIterator, cls).dopreinit(_obj, *args, **kwargs)

    # if no datas were found use, use the _owner (to have a clock)
    _obj.datas = _obj.datas or [_obj._owner]

    # 1st data source is our ticking clock
    _obj._clock = _obj.datas[0]

    # To automatically set the period Start by scanning the found datas
    # No calculation can take place until all datas have yielded &#34;data&#34;
    # A data could be an indicator and it could take x bars until
    # something is produced
    _obj._minperiod = \
        max([x._minperiod for x in _obj.datas] or [_obj._minperiod])

    # The lines carry at least the same minperiod as
    # that provided by the datas
    for line in _obj.lines:
        line.addminperiod(_obj._minperiod)

    return _obj, args, kwargs</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineseries.MetaLineSeries" href="lineseries.html#backtrader.lineseries.MetaLineSeries">MetaLineSeries</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineseries.MetaLineSeries.donew" href="lineseries.html#backtrader.lineseries.MetaLineSeries.donew">donew</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler"><code class="flex name class">
<span>class <span class="ident">MultiCoupler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiCoupler(LineIterator):
    _ltype = LineIterator.IndType

    def __init__(self):
        super(MultiCoupler, self).__init__()
        self.dlen = 0
        self.dsize = self.fullsize()  # shorcut for number of lines
        self.dvals = [float(&#39;NaN&#39;)] * self.dsize

    def next(self):
        if len(self.data) &gt; self.dlen:
            self.dlen += 1

            for i in range(self.dsize):
                self.dvals[i] = self.data.lines[i][0]

        for i in range(self.dsize):
            self.lines[i][0] = self.dvals[i]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.MultiCoupler.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.MultiCoupler.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.LineIterator.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.ObserverBase"><code class="flex name class">
<span>class <span class="ident">ObserverBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ObserverBase(DataAccessor):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.observer.Observer" href="observer.html#backtrader.observer.Observer">Observer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.ObserverBase.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.ObserverBase.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.DataAccessor.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.SingleCoupler"><code class="flex name class">
<span>class <span class="ident">SingleCoupler</span></span>
<span>(</span><span>cdata, clock=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class derived from LineBuffer intented to defined the
minimum interface to make it compatible with a LineIterator by
providing operational _next and _once interfaces.</p>
<p>The metaclass does the dirty job of calculating minperiods and registering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleCoupler(LineActions):
    def __init__(self, cdata, clock=None):
        super(SingleCoupler, self).__init__()
        self._clock = clock if clock is not None else self._owner

        self.cdata = cdata
        self.dlen = 0
        self.val = float(&#39;NaN&#39;)

    def next(self):
        if len(self.cdata) &gt; self.dlen:
            self.val = self.cdata[0]
            self.dlen += 1

        self[0] = self.val</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.linebuffer.LineActions" href="linebuffer.html#backtrader.linebuffer.LineActions">LineActions</a></li>
<li><a title="backtrader.linebuffer.LineBuffer" href="linebuffer.html#backtrader.linebuffer.LineBuffer">LineBuffer</a></li>
<li><a title="backtrader.lineroot.LineSingle" href="lineroot.html#backtrader.lineroot.LineSingle">LineSingle</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.SingleCoupler.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.SingleCoupler.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.SingleCoupler.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.linebuffer.LineActions" href="linebuffer.html#backtrader.linebuffer.LineActions">LineActions</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.linebuffer.LineActions.addbinding" href="linebuffer.html#backtrader.linebuffer.LineBuffer.addbinding">addbinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.addminperiod" href="lineroot.html#backtrader.lineroot.LineSingle.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.advance" href="linebuffer.html#backtrader.linebuffer.LineBuffer.advance">advance</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.backwards" href="linebuffer.html#backtrader.linebuffer.LineBuffer.backwards">backwards</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2line" href="linebuffer.html#backtrader.linebuffer.LineBuffer.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.bind2lines" href="linebuffer.html#backtrader.linebuffer.LineBuffer.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.buflen" href="linebuffer.html#backtrader.linebuffer.LineBuffer.buflen">buflen</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.dt" href="linebuffer.html#backtrader.linebuffer.LineBuffer.dt">dt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.extend" href="linebuffer.html#backtrader.linebuffer.LineBuffer.extend">extend</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.forward" href="linebuffer.html#backtrader.linebuffer.LineBuffer.forward">forward</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.get" href="linebuffer.html#backtrader.linebuffer.LineBuffer.get">get</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzero" href="linebuffer.html#backtrader.linebuffer.LineBuffer.getzero">getzero</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.getzeroval" href="linebuffer.html#backtrader.linebuffer.LineBuffer.getzeroval">getzeroval</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.home" href="linebuffer.html#backtrader.linebuffer.LineBuffer.home">home</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.incminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.minbuffer" href="linebuffer.html#backtrader.linebuffer.LineBuffer.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.next" href="lineroot.html#backtrader.lineroot.LineRoot.next">next</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.nextstart" href="lineroot.html#backtrader.lineroot.LineRoot.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncebinding" href="linebuffer.html#backtrader.linebuffer.LineBuffer.oncebinding">oncebinding</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.plot" href="linebuffer.html#backtrader.linebuffer.LineBuffer.plot">plot</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.prenext" href="lineroot.html#backtrader.lineroot.LineRoot.prenext">prenext</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.reset" href="linebuffer.html#backtrader.linebuffer.LineBuffer.reset">reset</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.set" href="linebuffer.html#backtrader.linebuffer.LineBuffer.set">set</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm">tm</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2datetime" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm2datetime">tm2datetime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm2dtime" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm2dtime">tm2dtime</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_eq" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_eq">tm_eq</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_ge" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_ge">tm_ge</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_gt" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_gt">tm_gt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_le" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_le">tm_le</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_lt" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_lt">tm_lt</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.tm_raw" href="linebuffer.html#backtrader.linebuffer.LineBuffer.tm_raw">tm_raw</a></code></li>
<li><code><a title="backtrader.linebuffer.LineActions.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.lineiterator.StrategyBase"><code class="flex name class">
<span>class <span class="ident">StrategyBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for LineXXX instances that hold more than one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrategyBase(DataAccessor):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.strategy.Strategy" href="strategy.html#backtrader.strategy.Strategy">Strategy</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.lineiterator.StrategyBase.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.lineiterator.StrategyBase.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.DataAccessor.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.qbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="backtrader.lineiterator.LineCoupler" href="#backtrader.lineiterator.LineCoupler">LineCoupler</a></code></li>
<li><code><a title="backtrader.lineiterator.LinesCoupler" href="#backtrader.lineiterator.LinesCoupler">LinesCoupler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.lineiterator.DataAccessor" href="#backtrader.lineiterator.DataAccessor">DataAccessor</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceClose" href="#backtrader.lineiterator.DataAccessor.PriceClose">PriceClose</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceDateTime" href="#backtrader.lineiterator.DataAccessor.PriceDateTime">PriceDateTime</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceHigh" href="#backtrader.lineiterator.DataAccessor.PriceHigh">PriceHigh</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceLow" href="#backtrader.lineiterator.DataAccessor.PriceLow">PriceLow</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceOpen" href="#backtrader.lineiterator.DataAccessor.PriceOpen">PriceOpen</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceOpenInteres" href="#backtrader.lineiterator.DataAccessor.PriceOpenInteres">PriceOpenInteres</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.PriceVolume" href="#backtrader.lineiterator.DataAccessor.PriceVolume">PriceVolume</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.alias" href="#backtrader.lineiterator.DataAccessor.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.aliased" href="#backtrader.lineiterator.DataAccessor.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.frompackages" href="#backtrader.lineiterator.DataAccessor.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.linealias" href="#backtrader.lineiterator.DataAccessor.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.packages" href="#backtrader.lineiterator.DataAccessor.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.params" href="#backtrader.lineiterator.DataAccessor.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.plotinfo" href="#backtrader.lineiterator.DataAccessor.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.DataAccessor.plotlines" href="#backtrader.lineiterator.DataAccessor.plotlines">plotlines</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.IndicatorBase" href="#backtrader.lineiterator.IndicatorBase">IndicatorBase</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.IndicatorBase.alias" href="#backtrader.lineiterator.IndicatorBase.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.aliased" href="#backtrader.lineiterator.IndicatorBase.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.frompackages" href="#backtrader.lineiterator.IndicatorBase.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.linealias" href="#backtrader.lineiterator.IndicatorBase.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.packages" href="#backtrader.lineiterator.IndicatorBase.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.params" href="#backtrader.lineiterator.IndicatorBase.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.plotinfo" href="#backtrader.lineiterator.IndicatorBase.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.IndicatorBase.plotlines" href="#backtrader.lineiterator.IndicatorBase.plotlines">plotlines</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.LineIterator" href="#backtrader.lineiterator.LineIterator">LineIterator</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.LineIterator.addindicator" href="#backtrader.lineiterator.LineIterator.addindicator">addindicator</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.alias" href="#backtrader.lineiterator.LineIterator.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.aliased" href="#backtrader.lineiterator.LineIterator.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.bind2line" href="#backtrader.lineiterator.LineIterator.bind2line">bind2line</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.bind2lines" href="#backtrader.lineiterator.LineIterator.bind2lines">bind2lines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.bindlines" href="#backtrader.lineiterator.LineIterator.bindlines">bindlines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.frompackages" href="#backtrader.lineiterator.LineIterator.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.getindicators" href="#backtrader.lineiterator.LineIterator.getindicators">getindicators</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.getindicators_lines" href="#backtrader.lineiterator.LineIterator.getindicators_lines">getindicators_lines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.getobservers" href="#backtrader.lineiterator.LineIterator.getobservers">getobservers</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.linealias" href="#backtrader.lineiterator.LineIterator.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.next" href="#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.nextstart" href="#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.packages" href="#backtrader.lineiterator.LineIterator.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.params" href="#backtrader.lineiterator.LineIterator.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.plotinfo" href="#backtrader.lineiterator.LineIterator.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.plotlines" href="#backtrader.lineiterator.LineIterator.plotlines">plotlines</a></code></li>
<li><code><a title="backtrader.lineiterator.LineIterator.prenext" href="#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.MetaLineIterator" href="#backtrader.lineiterator.MetaLineIterator">MetaLineIterator</a></code></h4>
<ul class="">
<li><code><a title="backtrader.lineiterator.MetaLineIterator.dopostinit" href="#backtrader.lineiterator.MetaLineIterator.dopostinit">dopostinit</a></code></li>
<li><code><a title="backtrader.lineiterator.MetaLineIterator.dopreinit" href="#backtrader.lineiterator.MetaLineIterator.dopreinit">dopreinit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.MultiCoupler" href="#backtrader.lineiterator.MultiCoupler">MultiCoupler</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.MultiCoupler.alias" href="#backtrader.lineiterator.MultiCoupler.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.aliased" href="#backtrader.lineiterator.MultiCoupler.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.frompackages" href="#backtrader.lineiterator.MultiCoupler.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.linealias" href="#backtrader.lineiterator.MultiCoupler.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.packages" href="#backtrader.lineiterator.MultiCoupler.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.params" href="#backtrader.lineiterator.MultiCoupler.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.plotinfo" href="#backtrader.lineiterator.MultiCoupler.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.MultiCoupler.plotlines" href="#backtrader.lineiterator.MultiCoupler.plotlines">plotlines</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.ObserverBase" href="#backtrader.lineiterator.ObserverBase">ObserverBase</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.ObserverBase.alias" href="#backtrader.lineiterator.ObserverBase.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.aliased" href="#backtrader.lineiterator.ObserverBase.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.frompackages" href="#backtrader.lineiterator.ObserverBase.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.linealias" href="#backtrader.lineiterator.ObserverBase.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.packages" href="#backtrader.lineiterator.ObserverBase.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.params" href="#backtrader.lineiterator.ObserverBase.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.plotinfo" href="#backtrader.lineiterator.ObserverBase.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.ObserverBase.plotlines" href="#backtrader.lineiterator.ObserverBase.plotlines">plotlines</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.SingleCoupler" href="#backtrader.lineiterator.SingleCoupler">SingleCoupler</a></code></h4>
<ul class="">
<li><code><a title="backtrader.lineiterator.SingleCoupler.frompackages" href="#backtrader.lineiterator.SingleCoupler.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.SingleCoupler.packages" href="#backtrader.lineiterator.SingleCoupler.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.SingleCoupler.params" href="#backtrader.lineiterator.SingleCoupler.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.lineiterator.StrategyBase" href="#backtrader.lineiterator.StrategyBase">StrategyBase</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.lineiterator.StrategyBase.alias" href="#backtrader.lineiterator.StrategyBase.alias">alias</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.aliased" href="#backtrader.lineiterator.StrategyBase.aliased">aliased</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.frompackages" href="#backtrader.lineiterator.StrategyBase.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.linealias" href="#backtrader.lineiterator.StrategyBase.linealias">linealias</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.packages" href="#backtrader.lineiterator.StrategyBase.packages">packages</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.params" href="#backtrader.lineiterator.StrategyBase.params">params</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.plotinfo" href="#backtrader.lineiterator.StrategyBase.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.plotlines" href="#backtrader.lineiterator.StrategyBase.plotlines">plotlines</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>