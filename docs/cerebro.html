<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.cerebro API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.cerebro</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime
import collections
import itertools
import multiprocessing

try:  # For new Python versions
    collectionsAbc = collections.abc  # collections.Iterable -&gt; collections.abc.Iterable
except AttributeError:  # For old Python versions
    collectionsAbc = collections  # Используем collections.Iterable

import backtrader as bt
from .utils.py3 import (map, range, zip, with_metaclass, string_types,
                        integer_types)

from . import linebuffer
from . import indicator
from .brokers import BackBroker
from .metabase import MetaParams
from . import observers
from .writer import WriterFile
from .utils import OrderedDict, tzparse, num2date, date2num
from .strategy import Strategy, SignalStrategy
from .tradingcal import (TradingCalendarBase, TradingCalendar,
                         PandasMarketCalendar)
from .timer import Timer

# Defined here to make it pickable. Ideally it could be defined inside Cerebro


class OptReturn(object):
    def __init__(self, params, **kwargs):
        self.p = self.params = params
        for k, v in kwargs.items():
            setattr(self, k, v)


class Cerebro(with_metaclass(MetaParams, object)):
    &#39;&#39;&#39;
    Params

      - ``preload`` (default: ``True``)

        Whether to preload the different ``data feeds`` passed to cerebro for
        the Strategies

      - ``runonce`` (default: ``True``)

        Run ``Indicators`` in vectorized mode to speed up the entire system.
        Strategies and Observers will always be run on an event based basis

      - ``live`` (default: ``False``)

        If no data has reported itself as *live* (via the data&#39;s ``islive``
        method but the end user still want to run in ``live`` mode, this
        parameter can be set to true

        This will simultaneously deactivate ``preload`` and ``runonce``. It
        will have no effect on memory saving schemes.

        Run ``Indicators`` in vectorized mode to speed up the entire system.
        Strategies and Observers will always be run on an event based basis

      - ``maxcpus`` (default: None -&gt; all available cores)

        How many cores to use simultaneously for optimization

      - ``stdstats`` (default: ``True``)

        If True default Observers will be added: Broker (Cash and Value),
        Trades and BuySell

      - ``oldbuysell`` (default: ``False``)

        If ``stdstats`` is ``True`` and observers are getting automatically
        added, this switch controls the main behavior of the ``BuySell``
        observer

        - ``False``: use the modern behavior in which the buy / sell signals
          are plotted below / above the low / high prices respectively to avoid
          cluttering the plot

        - ``True``: use the deprecated behavior in which the buy / sell signals
          are plotted where the average price of the order executions for the
          given moment in time is. This will of course be on top of an OHLC bar
          or on a Line on Cloe bar, difficulting the recognition of the plot.
        - ``oldtrades`` (default: ``False``)

        If ``stdstats`` is ``True`` and observers are getting automatically
        added, this switch controls the main behavior of the ``Trades``
        observer

          - ``False``: use the modern behavior in which trades for all datas are
          plotted with different markers

          - ``True``: use the old Trades observer which plots the trades with the
          same markers, differentiating only if they are positive or negative

      - ``exactbars`` (default: ``False``)

        With the default value each and every value stored in a line is kept in
        memory

        Possible values

          - ``True`` or ``1``: all &#34;lines&#34; objects reduce memory usage to the
            automatically calculated minimum period.

            If a Simple Moving Average has a period of 30, the underlying data
            will have always a running buffer of 30 bars to allow the
            calculation of the Simple Moving Average

            - This setting will deactivate ``preload`` and ``runonce``
            - Using this setting also deactivates **plotting**

          - ``-1``: datafreeds and indicators/operations at strategy level will
            keep all data in memory.

            For example: a ``RSI`` internally uses the indicator ``UpDay`` to
            make calculations. This subindicator will not keep all data in
            memory

              - This allows to keep ``plotting`` and ``preloading`` active.

              - ``runonce`` will be deactivated

          - ``-2``: data feeds and indicators kept as attributes of the
            strategy will keep all points in memory.

            For example: a ``RSI`` internally uses the indicator ``UpDay`` to
            make calculations. This subindicator will not keep all data in
            memory

            If in the ``__init__`` something like
            ``a = self.data.close - self.data.high`` is defined, then ``a``
            will not keep all data in memory

            - This allows to keep ``plotting`` and ``preloading`` active.

            - ``runonce`` will be deactivated

      - ``objcache`` (default: ``False``)

        Experimental option to implement a cache of lines objects and reduce
        the amount of them. Example from UltimateOscillator::

          bp = self.data.close - TrueLow(self.data)
          tr = TrueRange(self.data)  # -&gt; creates another TrueLow(self.data)

        If this is ``True`` the 2nd ``TrueLow(self.data)`` inside ``TrueRange``
        matches the signature of the one in the ``bp`` calculation. It will be
        reused.

        Corner cases may happen in which this drives a line object off its
        minimum period and breaks things and it is therefore disabled.

      - ``writer`` (default: ``False``)

        If set to ``True`` a default WriterFile will be created which will
        print to stdout. It will be added to the strategy (in addition to any
        other writers added by the user code)

      - ``tradehistory`` (default: ``False``)

        If set to ``True``, it will activate update event logging in each trade
        for all strategies. This can also be accomplished on a per strategy
        basis with the strategy method ``set_tradehistory``

      - ``optdatas`` (default: ``True``)

        If ``True`` and optimizing (and the system can ``preload`` and use
        ``runonce``, data preloading will be done only once in the main process
        to save time and resources.

        The tests show an approximate ``20%`` speed-up moving from a sample
        execution in ``83`` seconds to ``66``

      - ``optreturn`` (default: ``True``)

        If ``True`` the optimization results will not be full ``Strategy``
        objects (and all *datas*, *indicators*, *observers* ...) but and object
        with the following attributes (same as in ``Strategy``):

          - ``params`` (or ``p``) the strategy had for the execution
          - ``analyzers`` the strategy has executed

        In most occassions, only the *analyzers* and with which *params* are
        the things needed to evaluate a the performance of a strategy. If
        detailed analysis of the generated values for (for example)
        *indicators* is needed, turn this off

        The tests show a ``13% - 15%`` improvement in execution time. Combined
        with ``optdatas`` the total gain increases to a total speed-up of
        ``32%`` in an optimization run.

      - ``oldsync`` (default: ``False``)

        Starting with release 1.9.0.99 the synchronization of multiple datas
        (same or different timeframes) has been changed to allow datas of
        different lengths.

        If the old behavior with data0 as the master of the system is wished,
        set this parameter to true

      - ``tz`` (default: ``None``)

        Adds a global timezone for strategies. The argument ``tz`` can be

          - ``None``: in this case the datetime displayed by strategies will be
            in UTC, which has been always the standard behavior

          - ``pytz`` instance. It will be used as such to convert UTC times to
            the chosen timezone

          - ``string``. Instantiating a ``pytz`` instance will be attempted.

          - ``integer``. Use, for the strategy, the same timezone as the
            corresponding ``data`` in the ``self.datas`` iterable (``0`` would
            use the timezone from ``data0``)

      - ``cheat_on_open`` (default: ``False``)

        The ``next_open`` method of strategies will be called. This happens
        before ``next`` and before the broker has had a chance to evaluate
        orders. The indicators have not yet been recalculated. This allows
        issuing an orde which takes into account the indicators of the previous
        day but uses the ``open`` price for stake calculations

        For cheat_on_open order execution, it is also necessary to make the
        call ``cerebro.broker.set_coo(True)`` or instantite a broker with
        ``BackBroker(coo=True)`` (where *coo* stands for cheat-on-open) or set
        the ``broker_coo`` parameter to ``True``. Cerebro will do it
        automatically unless disabled below.

      - ``broker_coo`` (default: ``True``)

        This will automatically invoke the ``set_coo`` method of the broker
        with ``True`` to activate ``cheat_on_open`` execution. Will only do it
        if ``cheat_on_open`` is also ``True``

      - ``quicknotify`` (default: ``False``)

        Broker notifications are delivered right before the delivery of the
        *next* prices. For backtesting this has no implications, but with live
        brokers a notification can take place long before the bar is
        delivered. When set to ``True`` notifications will be delivered as soon
        as possible (see ``qcheck`` in live feeds)

        Set to ``False`` for compatibility. May be changed to ``True``

    &#39;&#39;&#39;

    params = (
        (&#39;preload&#39;, True),
        (&#39;runonce&#39;, True),
        (&#39;maxcpus&#39;, None),
        (&#39;stdstats&#39;, True),
        (&#39;oldbuysell&#39;, False),
        (&#39;oldtrades&#39;, False),
        (&#39;lookahead&#39;, 0),
        (&#39;exactbars&#39;, False),
        (&#39;optdatas&#39;, True),
        (&#39;optreturn&#39;, True),
        (&#39;objcache&#39;, False),
        (&#39;live&#39;, False),
        (&#39;writer&#39;, False),
        (&#39;tradehistory&#39;, False),
        (&#39;oldsync&#39;, False),
        (&#39;tz&#39;, None),
        (&#39;cheat_on_open&#39;, False),
        (&#39;broker_coo&#39;, True),
        (&#39;quicknotify&#39;, False),
    )

    def __init__(self):
        self._dolive = False
        self._doreplay = False
        self._dooptimize = False
        self.stores = list()
        self.feeds = list()
        self.datas = list()
        self.datasbyname = collections.OrderedDict()
        self.strats = list()
        self.optcbs = list()  # holds a list of callbacks for opt strategies
        self.observers = list()
        self.analyzers = list()
        self.indicators = list()
        self.sizers = dict()
        self.writers = list()
        self.storecbs = list()
        self.datacbs = list()
        self.signals = list()
        self._signal_strat = (None, None, None)
        self._signal_concurrent = False
        self._signal_accumulate = False

        self._dataid = itertools.count(1)

        self._broker = BackBroker()
        self._broker.cerebro = self

        self._tradingcal = None  # TradingCalendar()

        self._pretimers = list()
        self._ohistory = list()
        self._fhistory = None

    @staticmethod
    def iterize(iterable):
        &#39;&#39;&#39;Handy function which turns things into things that can be iterated upon
        including iterables
        &#39;&#39;&#39;
        niterable = list()
        for elem in iterable:
            if isinstance(elem, string_types):
                elem = (elem,)
            elif not isinstance(elem, collectionsAbc.Iterable):  # Different functions will be called for different Python versions
                elem = (elem,)

            niterable.append(elem)

        return niterable

    def set_fund_history(self, fund):
        &#39;&#39;&#39;
        Add a history of orders to be directly executed in the broker for
        performance evaluation

          - ``fund``: is an iterable (ex: list, tuple, iterator, generator)
            in which each element will be also an iterable (with length) with
            the following sub-elements (2 formats are possible)

            ``[datetime, share_value, net asset value]``

            **Note**: it must be sorted (or produce sorted elements) by
              datetime ascending

            where:

              - ``datetime`` is a python ``date/datetime`` instance or a string
                with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
                brackets are optional
              - ``share_value`` is an float/integer
              - ``net_asset_value`` is a float/integer
        &#39;&#39;&#39;
        self._fhistory = fund

    def add_order_history(self, orders, notify=True):
        &#39;&#39;&#39;
        Add a history of orders to be directly executed in the broker for
        performance evaluation

          - ``orders``: is an iterable (ex: list, tuple, iterator, generator)
            in which each element will be also an iterable (with length) with
            the following sub-elements (2 formats are possible)

            ``[datetime, size, price]`` or ``[datetime, size, price, data]``

            **Note**: it must be sorted (or produce sorted elements) by
              datetime ascending

            where:

              - ``datetime`` is a python ``date/datetime`` instance or a string
                with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
                brackets are optional
              - ``size`` is an integer (positive to *buy*, negative to *sell*)
              - ``price`` is a float/integer
              - ``data`` if present can take any of the following values

                - *None* - The 1st data feed will be used as target
                - *integer* - The data with that index (insertion order in
                  **Cerebro**) will be used
                - *string* - a data with that name, assigned for example with
                  ``cerebro.addata(data, name=value)``, will be the target

          - ``notify`` (default: *True*)

            If ``True`` the 1st strategy inserted in the system will be
            notified of the artificial orders created following the information
            from each order in ``orders``

        **Note**: Implicit in the description is the need to add a data feed
          which is the target of the orders. This is for example needed by
          analyzers which track for example the returns
        &#39;&#39;&#39;
        self._ohistory.append((orders, notify))

    def notify_timer(self, timer, when, *args, **kwargs):
        &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
        returned by ``add_timer``, and ``when`` is the calling time. ``args``
        and ``kwargs`` are any additional arguments passed to ``add_timer``

        The actual ``when`` time can be later, but the system may have not be
        able to call the timer before. This value is the timer value and no the
        system time.
        &#39;&#39;&#39;
        pass

    def _add_timer(self, owner, when,
                   offset=datetime.timedelta(), repeat=datetime.timedelta(),
                   weekdays=[], weekcarry=False,
                   monthdays=[], monthcarry=True,
                   allow=None,
                   tzdata=None, strats=False, cheat=False,
                   *args, **kwargs):
        &#39;&#39;&#39;Internal method to really create the timer (not started yet) which
        can be called by cerebro instances or other objects which can access
        cerebro&#39;&#39;&#39;

        timer = Timer(
            tid=len(self._pretimers),
            owner=owner, strats=strats,
            when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, cheat=cheat,
            *args, **kwargs
        )

        self._pretimers.append(timer)
        return timer

    def add_timer(self, when,
                  offset=datetime.timedelta(), repeat=datetime.timedelta(),
                  weekdays=[], weekcarry=False,
                  monthdays=[], monthcarry=True,
                  allow=None,
                  tzdata=None, strats=False, cheat=False,
                  *args, **kwargs):
        &#39;&#39;&#39;
        Schedules a timer to invoke ``notify_timer``

        Arguments:

          - ``when``: can be

            - ``datetime.time`` instance (see below ``tzdata``)
            - ``bt.timer.SESSION_START`` to reference a session start
            - ``bt.timer.SESSION_END`` to reference a session end

         - ``offset`` which must be a ``datetime.timedelta`` instance

           Used to offset the value ``when``. It has a meaningful use in
           combination with ``SESSION_START`` and ``SESSION_END``, to indicated
           things like a timer being called ``15 minutes`` after the session
           start.

          - ``repeat`` which must be a ``datetime.timedelta`` instance

            Indicates if after a 1st call, further calls will be scheduled
            within the same session at the scheduled ``repeat`` delta

            Once the timer goes over the end of the session it is reset to the
            original value for ``when``

          - ``weekdays``: a **sorted** iterable with integers indicating on
            which days (iso codes, Monday is 1, Sunday is 7) the timers can
            be actually invoked

            If not specified, the timer will be active on all days

          - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
            not seen (ex: trading holiday), the timer will be executed on the
            next day (even if in a new week)

          - ``monthdays``: a **sorted** iterable with integers indicating on
            which days of the month a timer has to be executed. For example
            always on day *15* of the month

            If not specified, the timer will be active on all days

          - ``monthcarry`` (default: ``True``). If the day was not seen
            (weekend, trading holiday), the timer will be executed on the next
            available day.

          - ``allow`` (default: ``None``). A callback which receives a
            `datetime.date`` instance and returns ``True`` if the date is
            allowed for timers or else returns ``False``

          - ``tzdata`` which can be either ``None`` (default), a ``pytz``
            instance or a ``data feed`` instance.

            ``None``: ``when`` is interpreted at face value (which translates
            to handling it as if it where UTC even if it&#39;s not)

            ``pytz`` instance: ``when`` will be interpreted as being specified
            in the local time specified by the timezone instance.

            ``data feed`` instance: ``when`` will be interpreted as being
            specified in the local time specified by the ``tz`` parameter of
            the data feed instance.

            **Note**: If ``when`` is either ``SESSION_START`` or
              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
              in the system (aka ``self.data0``) will be used as the reference
              to find out the session times.

          - ``strats`` (default: ``False``) call also the ``notify_timer`` of
            strategies

          - ``cheat`` (default ``False``) if ``True`` the timer will be called
            before the broker has a chance to evaluate the orders. This opens
            the chance to issue orders based on opening price for example right
            before the session starts
          - ``*args``: any extra args will be passed to ``notify_timer``

          - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

        Return Value:

          - The created timer

        &#39;&#39;&#39;
        return self._add_timer(
            owner=self, when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, strats=strats, cheat=cheat,
            *args, **kwargs)

    def addtz(self, tz):
        &#39;&#39;&#39;
        This can also be done with the parameter ``tz``

        Adds a global timezone for strategies. The argument ``tz`` can be

          - ``None``: in this case the datetime displayed by strategies will be
            in UTC, which has been always the standard behavior

          - ``pytz`` instance. It will be used as such to convert UTC times to
            the chosen timezone

          - ``string``. Instantiating a ``pytz`` instance will be attempted.

          - ``integer``. Use, for the strategy, the same timezone as the
            corresponding ``data`` in the ``self.datas`` iterable (``0`` would
            use the timezone from ``data0``)

        &#39;&#39;&#39;
        self.p.tz = tz

    def addcalendar(self, cal):
        &#39;&#39;&#39;Adds a global trading calendar to the system. Individual data feeds
        may have separate calendars which override the global one

        ``cal`` can be an instance of ``TradingCalendar`` a string or an
        instance of ``pandas_market_calendars``. A string will be will be
        instantiated as a ``PandasMarketCalendar`` (which needs the module
        ``pandas_market_calendar`` installed in the system.

        If a subclass of `TradingCalendarBase` is passed (not an instance) it
        will be instantiated
        &#39;&#39;&#39;
        if isinstance(cal, string_types):
            cal = PandasMarketCalendar(calendar=cal)
        elif hasattr(cal, &#39;valid_days&#39;):
            cal = PandasMarketCalendar(calendar=cal)

        else:
            try:
                if issubclass(cal, TradingCalendarBase):
                    cal = cal()
            except TypeError:  # already an instance
                pass

        self._tradingcal = cal

    def add_signal(self, sigtype, sigcls, *sigargs, **sigkwargs):
        &#39;&#39;&#39;Adds a signal to the system which will be later added to a
        ``SignalStrategy``&#39;&#39;&#39;
        self.signals.append((sigtype, sigcls, sigargs, sigkwargs))

    def signal_strategy(self, stratcls, *args, **kwargs):
        &#39;&#39;&#39;Adds a SignalStrategy subclass which can accept signals&#39;&#39;&#39;
        self._signal_strat = (stratcls, args, kwargs)

    def signal_concurrent(self, onoff):
        &#39;&#39;&#39;If signals are added to the system and the ``concurrent`` value is
        set to True, concurrent orders will be allowed&#39;&#39;&#39;
        self._signal_concurrent = onoff

    def signal_accumulate(self, onoff):
        &#39;&#39;&#39;If signals are added to the system and the ``accumulate`` value is
        set to True, entering the market when already in the market, will be
        allowed to increase a position&#39;&#39;&#39;
        self._signal_accumulate = onoff

    def addstore(self, store):
        &#39;&#39;&#39;Adds an ``Store`` instance to the if not already present&#39;&#39;&#39;
        if store not in self.stores:
            self.stores.append(store)

    def addwriter(self, wrtcls, *args, **kwargs):
        &#39;&#39;&#39;Adds an ``Writer`` class to the mix. Instantiation will be done at
        ``run`` time in cerebro
        &#39;&#39;&#39;
        self.writers.append((wrtcls, args, kwargs))

    def addsizer(self, sizercls, *args, **kwargs):
        &#39;&#39;&#39;Adds a ``Sizer`` class (and args) which is the default sizer for any
        strategy added to cerebro
        &#39;&#39;&#39;
        self.sizers[None] = (sizercls, args, kwargs)

    def addsizer_byidx(self, idx, sizercls, *args, **kwargs):
        &#39;&#39;&#39;Adds a ``Sizer`` class by idx. This idx is a reference compatible to
        the one returned by ``addstrategy``. Only the strategy referenced by
        ``idx`` will receive this size
        &#39;&#39;&#39;
        self.sizers[idx] = (sizercls, args, kwargs)

    def addindicator(self, indcls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Indicator`` class to the mix. Instantiation will be done at
        ``run`` time in the passed strategies
        &#39;&#39;&#39;
        self.indicators.append((indcls, args, kwargs))

    def addanalyzer(self, ancls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Analyzer`` class to the mix. Instantiation will be done at
        ``run`` time
        &#39;&#39;&#39;
        self.analyzers.append((ancls, args, kwargs))

    def addobserver(self, obscls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Observer`` class to the mix. Instantiation will be done at
        ``run`` time
        &#39;&#39;&#39;
        self.observers.append((False, obscls, args, kwargs))

    def addobservermulti(self, obscls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Observer`` class to the mix. Instantiation will be done at
        ``run`` time

        It will be added once per &#34;data&#34; in the system. A use case is a
        buy/sell observer which observes individual datas.

        A counter-example is the CashValue, which observes system-wide values
        &#39;&#39;&#39;
        self.observers.append((True, obscls, args, kwargs))

    def addstorecb(self, callback):
        &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
        notify_store method

        The signature of the callback must support the following:

          - callback(msg, \*args, \*\*kwargs)

        The actual ``msg``, ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        self.storecbs.append(callback)

    def _notify_store(self, msg, *args, **kwargs):
        for callback in self.storecbs:
            callback(msg, *args, **kwargs)

        self.notify_store(msg, *args, **kwargs)

    def notify_store(self, msg, *args, **kwargs):
        &#39;&#39;&#39;Receive store notifications in cerebro

        This method can be overridden in ``Cerebro`` subclasses

        The actual ``msg``, ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        pass

    def _storenotify(self):
        for store in self.stores:
            for notif in store.get_notifications():
                msg, args, kwargs = notif

                self._notify_store(msg, *args, **kwargs)
                for strat in self.runningstrats:
                    strat.notify_store(msg, *args, **kwargs)

    def adddatacb(self, callback):
        &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
        notify_data method

        The signature of the callback must support the following:

          - callback(data, status, \*args, \*\*kwargs)

        The actual ``*args`` and ``**kwargs`` received are implementation
        defined (depend entirely on the *data/broker/store*) but in general one
        should expect them to be *printable* to allow for reception and
        experimentation.
        &#39;&#39;&#39;
        self.datacbs.append(callback)

    def _datanotify(self):
        for data in self.datas:
            for notif in data.get_notifications():
                status, args, kwargs = notif
                self._notify_data(data, status, *args, **kwargs)
                for strat in self.runningstrats:
                    strat.notify_data(data, status, *args, **kwargs)

    def _notify_data(self, data, status, *args, **kwargs):
        for callback in self.datacbs:
            callback(data, status, *args, **kwargs)

        self.notify_data(data, status, *args, **kwargs)

    def notify_data(self, data, status, *args, **kwargs):
        &#39;&#39;&#39;Receive data notifications in cerebro

        This method can be overridden in ``Cerebro`` subclasses

        The actual ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        pass

    def adddata(self, data, name=None):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` instance to the mix.

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.
        &#39;&#39;&#39;
        if name is not None:
            data._name = name

        data._id = next(self._dataid)
        data.setenvironment(self)

        self.datas.append(data)
        self.datasbyname[data._name] = data
        feed = data.getfeed()
        if feed and feed not in self.feeds:
            self.feeds.append(feed)

        if data.islive():
            self._dolive = True

        return data

    def chaindata(self, *args, **kwargs):
        &#39;&#39;&#39;
        Chains several data feeds into one

        If ``name`` is passed as named argument and is not None it will be put
        into ``data._name`` which is meant for decoration/plotting purposes.

        If ``None``, then the name of the 1st data will be used
        &#39;&#39;&#39;
        dname = kwargs.pop(&#39;name&#39;, None)
        if dname is None:
            dname = args[0]._dataname
        d = bt.feeds.Chainer(dataname=dname, *args)
        self.adddata(d, name=dname)

        return d

    def rolloverdata(self, *args, **kwargs):
        &#39;&#39;&#39;Chains several data feeds into one

        If ``name`` is passed as named argument and is not None it will be put
        into ``data._name`` which is meant for decoration/plotting purposes.

        If ``None``, then the name of the 1st data will be used

        Any other kwargs will be passed to the RollOver class

        &#39;&#39;&#39;
        dname = kwargs.pop(&#39;name&#39;, None)
        if dname is None:
            dname = args[0]._dataname
        d = bt.feeds.RollOver(dataname=dname, *args, **kwargs)
        self.adddata(d, name=dname)

        return d

    def replaydata(self, dataname, name=None, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` to be replayed by the system

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.

        Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
        are supported by the replay filter will be passed transparently
        &#39;&#39;&#39;
        if any(dataname is x for x in self.datas):
            dataname = dataname.clone()

        dataname.replay(**kwargs)
        self.adddata(dataname, name=name)
        self._doreplay = True

        return dataname

    def resampledata(self, dataname, name=None, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` to be resample by the system

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.

        Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
        are supported by the resample filter will be passed transparently
        &#39;&#39;&#39;
        if any(dataname is x for x in self.datas):
            dataname = dataname.clone()

        dataname.resample(**kwargs)
        self.adddata(dataname, name=name)
        self._doreplay = True

        return dataname

    def optcallback(self, cb):
        &#39;&#39;&#39;
        Adds a *callback* to the list of callbacks that will be called with the
        optimizations when each of the strategies has been run

        The signature: cb(strategy)
        &#39;&#39;&#39;
        self.optcbs.append(cb)

    def optstrategy(self, strategy, *args, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Strategy`` class to the mix for optimization. Instantiation
        will happen during ``run`` time.

        args and kwargs MUST BE iterables which hold the values to check.

        Example: if a Strategy accepts a parameter ``period``, for optimization
        purposes the call to ``optstrategy`` looks like:

          - cerebro.optstrategy(MyStrategy, period=(15, 25))

        This will execute an optimization for values 15 and 25. Whereas

          - cerebro.optstrategy(MyStrategy, period=range(15, 25))

        will execute MyStrategy with ``period`` values 15 -&gt; 25 (25 not
        included, because ranges are semi-open in Python)

        If a parameter is passed but shall not be optimized the call looks
        like:

          - cerebro.optstrategy(MyStrategy, period=(15,))

        Notice that ``period`` is still passed as an iterable ... of just 1
        element

        ``backtrader`` will anyhow try to identify situations like:

          - cerebro.optstrategy(MyStrategy, period=15)

        and will create an internal pseudo-iterable if possible
        &#39;&#39;&#39;
        self._dooptimize = True
        args = self.iterize(args)
        optargs = itertools.product(*args)

        optkeys = list(kwargs)

        vals = self.iterize(kwargs.values())
        optvals = itertools.product(*vals)

        okwargs1 = map(zip, itertools.repeat(optkeys), optvals)

        optkwargs = map(dict, okwargs1)

        it = itertools.product([strategy], optargs, optkwargs)
        self.strats.append(it)

    def addstrategy(self, strategy, *args, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Strategy`` class to the mix for a single pass run.
        Instantiation will happen during ``run`` time.

        args and kwargs will be passed to the strategy as they are during
        instantiation.

        Returns the index with which addition of other objects (like sizers)
        can be referenced
        &#39;&#39;&#39;
        self.strats.append([(strategy, args, kwargs)])
        return len(self.strats) - 1

    def setbroker(self, broker):
        &#39;&#39;&#39;
        Sets a specific ``broker`` instance for this strategy, replacing the
        one inherited from cerebro.
        &#39;&#39;&#39;
        self._broker = broker
        broker.cerebro = self
        return broker

    def getbroker(self):
        &#39;&#39;&#39;
        Returns the broker instance.

        This is also available as a ``property`` by the name ``broker``
        &#39;&#39;&#39;
        return self._broker

    broker = property(getbroker, setbroker)

    def plot(self, plotter=None, numfigs=1, iplot=True, start=None, end=None,
             width=16, height=9, dpi=300, tight=True, use=None,
             **kwargs):
        &#39;&#39;&#39;
        Plots the strategies inside cerebro

        If ``plotter`` is None a default ``Plot`` instance is created and
        ``kwargs`` are passed to it during instantiation.

        ``numfigs`` split the plot in the indicated number of charts reducing
        chart density if wished

        ``iplot``: if ``True`` and running in a ``notebook`` the charts will be
        displayed inline

        ``use``: set it to the name of the desired matplotlib backend. It will
        take precedence over ``iplot``

        ``start``: An index to the datetime line array of the strategy or a
        ``datetime.date``, ``datetime.datetime`` instance indicating the start
        of the plot

        ``end``: An index to the datetime line array of the strategy or a
        ``datetime.date``, ``datetime.datetime`` instance indicating the end
        of the plot

        ``width``: in inches of the saved figure

        ``height``: in inches of the saved figure

        ``dpi``: quality in dots per inches of the saved figure

        ``tight``: only save actual content and not the frame of the figure
        &#39;&#39;&#39;
        if self._exactbars &gt; 0:
            return

        if not plotter:
            from . import plot
            if self.p.oldsync:
                plotter = plot.Plot_OldSync(**kwargs)
            else:
                plotter = plot.Plot(**kwargs)

        # pfillers = {self.datas[i]: self._plotfillers[i]
        # for i, x in enumerate(self._plotfillers)}

        # pfillers2 = {self.datas[i]: self._plotfillers2[i]
        # for i, x in enumerate(self._plotfillers2)}

        figs = []
        for stratlist in self.runstrats:
            for si, strat in enumerate(stratlist):
                rfig = plotter.plot(strat, figid=si * 100,
                                    numfigs=numfigs, iplot=iplot,
                                    start=start, end=end, use=use)
                # pfillers=pfillers2)

                figs.append(rfig)

            plotter.show()

        return figs

    def __call__(self, iterstrat):
        &#39;&#39;&#39;
        Used during optimization to pass the cerebro over the multiprocesing
        module without complains
        &#39;&#39;&#39;

        predata = self.p.optdatas and self._dopreload and self._dorunonce
        return self.runstrategies(iterstrat, predata=predata)

    def __getstate__(self):
        &#39;&#39;&#39;
        Used during optimization to prevent optimization result `runstrats`
        from being pickled to subprocesses
        &#39;&#39;&#39;

        rv = vars(self).copy()
        if &#39;runstrats&#39; in rv:
            del(rv[&#39;runstrats&#39;])
        return rv

    def runstop(self):
        &#39;&#39;&#39;If invoked from inside a strategy or anywhere else, including other
        threads the execution will stop as soon as possible.&#39;&#39;&#39;
        self._event_stop = True  # signal a stop has been requested

    def run(self, **kwargs):
        &#39;&#39;&#39;The core method to perform backtesting. Any ``kwargs`` passed to it
        will affect the value of the standard parameters ``Cerebro`` was
        instantiated with.

        If ``cerebro`` has not datas the method will immediately bail out.

        It has different return values:

          - For No Optimization: a list contanining instances of the Strategy
            classes added with ``addstrategy``

          - For Optimization: a list of lists which contain instances of the
            Strategy classes added with ``addstrategy``
        &#39;&#39;&#39;
        self._event_stop = False  # Stop is requested

        if not self.datas:
            return []  # nothing can be run

        pkeys = self.params._getkeys()
        for key, val in kwargs.items():
            if key in pkeys:
                setattr(self.params, key, val)

        # Manage activate/deactivate object cache
        linebuffer.LineActions.cleancache()  # clean cache
        indicator.Indicator.cleancache()  # clean cache

        linebuffer.LineActions.usecache(self.p.objcache)
        indicator.Indicator.usecache(self.p.objcache)

        self._dorunonce = self.p.runonce
        self._dopreload = self.p.preload
        self._exactbars = int(self.p.exactbars)

        if self._exactbars:
            self._dorunonce = False  # something is saving memory, no runonce
            self._dopreload = self._dopreload and self._exactbars &lt; 1

        self._doreplay = self._doreplay or any(x.replaying for x in self.datas)
        if self._doreplay:
            # preloading is not supported with replay. full timeframe bars
            # are constructed in realtime
            self._dopreload = False

        if self._dolive or self.p.live:
            # in this case both preload and runonce must be off
            self._dorunonce = False
            self._dopreload = False

        self.runwriters = list()

        # Add the system default writer if requested
        if self.p.writer is True:
            wr = WriterFile()
            self.runwriters.append(wr)

        # Instantiate any other writers
        for wrcls, wrargs, wrkwargs in self.writers:
            wr = wrcls(*wrargs, **wrkwargs)
            self.runwriters.append(wr)

        # Write down if any writer wants the full csv output
        self.writers_csv = any(map(lambda x: x.p.csv, self.runwriters))

        self.runstrats = list()

        if self.signals:  # allow processing of signals
            signalst, sargs, skwargs = self._signal_strat
            if signalst is None:
                # Try to see if the 1st regular strategy is a signal strategy
                try:
                    signalst, sargs, skwargs = self.strats.pop(0)
                except IndexError:
                    pass  # Nothing there
                else:
                    if not isinstance(signalst, SignalStrategy):
                        # no signal ... reinsert at the beginning
                        self.strats.insert(0, (signalst, sargs, skwargs))
                        signalst = None  # flag as not presetn

            if signalst is None:  # recheck
                # Still None, create a default one
                signalst, sargs, skwargs = SignalStrategy, tuple(), dict()

            # Add the signal strategy
            self.addstrategy(signalst,
                             _accumulate=self._signal_accumulate,
                             _concurrent=self._signal_concurrent,
                             signals=self.signals,
                             *sargs,
                             **skwargs)

        if not self.strats:  # Datas are present, add a strategy
            self.addstrategy(Strategy)

        iterstrats = itertools.product(*self.strats)
        if not self._dooptimize or self.p.maxcpus == 1:
            # If no optimmization is wished ... or 1 core is to be used
            # let&#39;s skip process &#34;spawning&#34;
            for iterstrat in iterstrats:
                runstrat = self.runstrategies(iterstrat)
                self.runstrats.append(runstrat)
                if self._dooptimize:
                    for cb in self.optcbs:
                        cb(runstrat)  # callback receives finished strategy
        else:
            if self.p.optdatas and self._dopreload and self._dorunonce:
                for data in self.datas:
                    data.reset()
                    if self._exactbars &lt; 1:  # datas can be full length
                        data.extend(size=self.params.lookahead)
                    data._start()
                    if self._dopreload:
                        data.preload()

            pool = multiprocessing.Pool(self.p.maxcpus or None)
            for r in pool.imap(self, iterstrats):
                self.runstrats.append(r)
                for cb in self.optcbs:
                    cb(r)  # callback receives finished strategy

            pool.close()

            if self.p.optdatas and self._dopreload and self._dorunonce:
                for data in self.datas:
                    data.stop()

        if not self._dooptimize:
            # avoid a list of list for regular cases
            return self.runstrats[0]

        return self.runstrats

    def _init_stcount(self):
        self.stcount = itertools.count(0)

    def _next_stid(self):
        return next(self.stcount)

    def runstrategies(self, iterstrat, predata=False):
        &#39;&#39;&#39;
        Internal method invoked by ``run``` to run a set of strategies
        &#39;&#39;&#39;
        self._init_stcount()

        self.runningstrats = runstrats = list()
        for store in self.stores:
            store.start()

        if self.p.cheat_on_open and self.p.broker_coo:
            # try to activate in broker
            if hasattr(self._broker, &#39;set_coo&#39;):
                self._broker.set_coo(True)

        if self._fhistory is not None:
            self._broker.set_fund_history(self._fhistory)

        for orders, onotify in self._ohistory:
            self._broker.add_order_history(orders, onotify)

        self._broker.start()

        for feed in self.feeds:
            feed.start()

        if self.writers_csv:
            wheaders = list()
            for data in self.datas:
                if data.csv:
                    wheaders.extend(data.getwriterheaders())

            for writer in self.runwriters:
                if writer.p.csv:
                    writer.addheaders(wheaders)

        # self._plotfillers = [list() for d in self.datas]
        # self._plotfillers2 = [list() for d in self.datas]

        if not predata:
            for data in self.datas:
                data.reset()
                if self._exactbars &lt; 1:  # datas can be full length
                    data.extend(size=self.params.lookahead)
                data._start()
                if self._dopreload:
                    data.preload()

        for stratcls, sargs, skwargs in iterstrat:
            sargs = self.datas + list(sargs)
            try:
                strat = stratcls(*sargs, **skwargs)
            except bt.errors.StrategySkipError:
                continue  # do not add strategy to the mix

            if self.p.oldsync:
                strat._oldsync = True  # tell strategy to use old clock update
            if self.p.tradehistory:
                strat.set_tradehistory()
            runstrats.append(strat)

        tz = self.p.tz
        if isinstance(tz, integer_types):
            tz = self.datas[tz]._tz
        else:
            tz = tzparse(tz)

        if runstrats:
            # loop separated for clarity
            defaultsizer = self.sizers.get(None, (None, None, None))
            for idx, strat in enumerate(runstrats):
                if self.p.stdstats:
                    strat._addobserver(False, observers.Broker)
                    if self.p.oldbuysell:
                        strat._addobserver(True, observers.BuySell)
                    else:
                        strat._addobserver(True, observers.BuySell,
                                           barplot=True)

                    if self.p.oldtrades or len(self.datas) == 1:
                        strat._addobserver(False, observers.Trades)
                    else:
                        strat._addobserver(False, observers.DataTrades)

                for multi, obscls, obsargs, obskwargs in self.observers:
                    strat._addobserver(multi, obscls, *obsargs, **obskwargs)

                for indcls, indargs, indkwargs in self.indicators:
                    strat._addindicator(indcls, *indargs, **indkwargs)

                for ancls, anargs, ankwargs in self.analyzers:
                    strat._addanalyzer(ancls, *anargs, **ankwargs)

                sizer, sargs, skwargs = self.sizers.get(idx, defaultsizer)
                if sizer is not None:
                    strat._addsizer(sizer, *sargs, **skwargs)

                strat._settz(tz)
                strat._start()

                for writer in self.runwriters:
                    if writer.p.csv:
                        writer.addheaders(strat.getwriterheaders())

            if not predata:
                for strat in runstrats:
                    strat.qbuffer(self._exactbars, replaying=self._doreplay)

            for writer in self.runwriters:
                writer.start()

            # Prepare timers
            self._timers = []
            self._timerscheat = []
            for timer in self._pretimers:
                # preprocess tzdata if needed
                timer.start(self.datas[0])

                if timer.params.cheat:
                    self._timerscheat.append(timer)
                else:
                    self._timers.append(timer)

            if self._dopreload and self._dorunonce:
                if self.p.oldsync:
                    self._runonce_old(runstrats)
                else:
                    self._runonce(runstrats)
            else:
                if self.p.oldsync:
                    self._runnext_old(runstrats)
                else:
                    self._runnext(runstrats)

            for strat in runstrats:
                strat._stop()

        self._broker.stop()

        if not predata:
            for data in self.datas:
                data.stop()

        for feed in self.feeds:
            feed.stop()

        for store in self.stores:
            store.stop()

        self.stop_writers(runstrats)

        if self._dooptimize and self.p.optreturn:
            # Results can be optimized
            results = list()
            for strat in runstrats:
                for a in strat.analyzers:
                    a.strategy = None
                    a._parent = None
                    for attrname in dir(a):
                        if attrname.startswith(&#39;data&#39;):
                            setattr(a, attrname, None)

                oreturn = OptReturn(strat.params, analyzers=strat.analyzers, strategycls=type(strat))
                results.append(oreturn)

            return results

        return runstrats

    def stop_writers(self, runstrats):
        cerebroinfo = OrderedDict()
        datainfos = OrderedDict()

        for i, data in enumerate(self.datas):
            datainfos[&#39;Data%d&#39; % i] = data.getwriterinfo()

        cerebroinfo[&#39;Datas&#39;] = datainfos

        stratinfos = dict()
        for strat in runstrats:
            stname = strat.__class__.__name__
            stratinfos[stname] = strat.getwriterinfo()

        cerebroinfo[&#39;Strategies&#39;] = stratinfos

        for writer in self.runwriters:
            writer.writedict(dict(Cerebro=cerebroinfo))
            writer.stop()

    def _brokernotify(self):
        &#39;&#39;&#39;
        Internal method which kicks the broker and delivers any broker
        notification to the strategy
        &#39;&#39;&#39;
        self._broker.next()
        while True:
            order = self._broker.get_notification()
            if order is None:
                break

            owner = order.owner
            if owner is None:
                owner = self.runningstrats[0]  # default

            owner._addnotification(order, quicknotify=self.p.quicknotify)

    def _runnext_old(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in full next mode. All objects have its
        ``next`` method invoke on each data arrival
        &#39;&#39;&#39;
        data0 = self.datas[0]
        d0ret = True
        while d0ret or d0ret is None:
            lastret = False
            # Notify anything from the store even before moving datas
            # because datas may not move due to an error reported by the store
            self._storenotify()
            if self._event_stop:  # stop if requested
                return
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            d0ret = data0.next()
            if d0ret:
                for data in self.datas[1:]:
                    if not data.next(datamaster=data0):  # no delivery
                        data._check(forcedata=data0)  # check forcing output
                        data.next(datamaster=data0)  # retry

            elif d0ret is None:
                # meant for things like live feeds which may not produce a bar
                # at the moment but need the loop to run for notifications and
                # getting resample and others to produce timely bars
                data0._check()
                for data in self.datas[1:]:
                    data._check()
            else:
                lastret = data0._last()
                for data in self.datas[1:]:
                    lastret += data._last(datamaster=data0)

                if not lastret:
                    # Only go extra round if something was changed by &#34;lasts&#34;
                    break

            # Datas may have generated a new notification after next
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # bars produced by data or filters
                for strat in runstrats:
                    strat._next()
                    if self._event_stop:  # stop if requested
                        return

                    self._next_writers(runstrats)

        # Last notification chance before stopping
        self._datanotify()
        if self._event_stop:  # stop if requested
            return
        self._storenotify()
        if self._event_stop:  # stop if requested
            return

    def _runonce_old(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in vector mode.
        Strategies are still invoked on a pseudo-event mode in which ``next``
        is called for each data arrival
        &#39;&#39;&#39;
        for strat in runstrats:
            strat._once()

        # The default once for strategies does nothing and therefore
        # has not moved forward all datas/indicators/observers that
        # were homed before calling once, Hence no &#34;need&#34; to do it
        # here again, because pointers are at 0
        data0 = self.datas[0]
        datas = self.datas[1:]
        for i in range(data0.buflen()):
            data0.advance()
            for data in datas:
                data.advance(datamaster=data0)

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            for strat in runstrats:
                # data0.datetime[0] for compat. w/ new strategy&#39;s oncepost
                strat._oncepost(data0.datetime[0])
                if self._event_stop:  # stop if requested
                    return

                self._next_writers(runstrats)

    def _next_writers(self, runstrats):
        if not self.runwriters:
            return

        if self.writers_csv:
            wvalues = list()
            for data in self.datas:
                if data.csv:
                    wvalues.extend(data.getwritervalues())

            for strat in runstrats:
                wvalues.extend(strat.getwritervalues())

            for writer in self.runwriters:
                if writer.p.csv:
                    writer.addvalues(wvalues)

                    writer.next()

    def _disable_runonce(self):
        &#39;&#39;&#39;API for lineiterators to disable runonce (see HeikinAshi)&#39;&#39;&#39;
        self._dorunonce = False

    def _runnext(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in full next mode. All objects have its
        ``next`` method invoke on each data arrival
        &#39;&#39;&#39;
        datas = sorted(self.datas,
                       key=lambda x: (x._timeframe, x._compression))
        datas1 = datas[1:]
        data0 = datas[0]
        d0ret = True

        rs = [i for i, x in enumerate(datas) if x.resampling]
        rp = [i for i, x in enumerate(datas) if x.replaying]
        rsonly = [i for i, x in enumerate(datas)
                  if x.resampling and not x.replaying]
        onlyresample = len(datas) == len(rsonly)
        noresample = not rsonly

        clonecount = sum(d._clone for d in datas)
        ldatas = len(datas)
        ldatas_noclones = ldatas - clonecount
        lastqcheck = False
        dt0 = date2num(datetime.datetime.max) - 2  # default at max
        while d0ret or d0ret is None:
            # if any has live data in the buffer, no data will wait anything
            newqcheck = not any(d.haslivedata() for d in datas)
            if not newqcheck:
                # If no data has reached the live status or all, wait for
                # the next incoming data
                livecount = sum(d._laststatus == d.LIVE for d in datas)
                newqcheck = not livecount or livecount == ldatas_noclones

            lastret = False
            # Notify anything from the store even before moving datas
            # because datas may not move due to an error reported by the store
            self._storenotify()
            if self._event_stop:  # stop if requested
                return
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            # record starting time and tell feeds to discount the elapsed time
            # from the qcheck value
            drets = []
            qstart = datetime.datetime.utcnow()
            for d in datas:
                qlapse = datetime.datetime.utcnow() - qstart
                d.do_qcheck(newqcheck, qlapse.total_seconds())
                drets.append(d.next(ticks=False))

            d0ret = any((dret for dret in drets))
            if not d0ret and any((dret is None for dret in drets)):
                d0ret = None

            if d0ret:
                dts = []
                for i, ret in enumerate(drets):
                    dts.append(datas[i].datetime[0] if ret else None)

                # Get index to minimum datetime
                if onlyresample or noresample:
                    dt0 = min((d for d in dts if d is not None))
                else:
                    dt0 = min((d for i, d in enumerate(dts)
                               if d is not None and i not in rsonly))

                dmaster = datas[dts.index(dt0)]  # and timemaster
                self._dtmaster = dmaster.num2date(dt0)
                self._udtmaster = num2date(dt0)

                # slen = len(runstrats[0])
                # Try to get something for those that didn&#39;t return
                for i, ret in enumerate(drets):
                    if ret:  # dts already contains a valid datetime for this i
                        continue

                    # try to get a data by checking with a master
                    d = datas[i]
                    d._check(forcedata=dmaster)  # check to force output
                    if d.next(datamaster=dmaster, ticks=False):  # retry
                        dts[i] = d.datetime[0]  # good -&gt; store
                        # self._plotfillers2[i].append(slen)  # mark as fill
                    else:
                        # self._plotfillers[i].append(slen)  # mark as empty
                        pass

                # make sure only those at dmaster level end up delivering
                for i, dti in enumerate(dts):
                    if dti is not None:
                        di = datas[i]
                        rpi = False and di.replaying   # to check behavior
                        if dti &gt; dt0:
                            if not rpi:  # must see all ticks ...
                                di.rewind()  # cannot deliver yet
                            # self._plotfillers[i].append(slen)
                        elif not di.replaying:
                            # Replay forces tick fill, else force here
                            di._tick_fill(force=True)

                        # self._plotfillers2[i].append(slen)  # mark as fill

            elif d0ret is None:
                # meant for things like live feeds which may not produce a bar
                # at the moment but need the loop to run for notifications and
                # getting resample and others to produce timely bars
                for data in datas:
                    data._check()
            else:
                lastret = data0._last()
                for data in datas1:
                    lastret += data._last(datamaster=data0)

                if not lastret:
                    # Only go extra round if something was changed by &#34;lasts&#34;
                    break

            # Datas may have generated a new notification after next
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # if any bar, check timers before broker
                self._check_timers(runstrats, dt0, cheat=True)
                if self.p.cheat_on_open:
                    for strat in runstrats:
                        strat._next_open()
                        if self._event_stop:  # stop if requested
                            return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # bars produced by data or filters
                self._check_timers(runstrats, dt0, cheat=False)
                for strat in runstrats:
                    strat._next()
                    if self._event_stop:  # stop if requested
                        return

                    self._next_writers(runstrats)

        # Last notification chance before stopping
        self._datanotify()
        if self._event_stop:  # stop if requested
            return
        self._storenotify()
        if self._event_stop:  # stop if requested
            return

    def _runonce(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in vector mode.

        Strategies are still invoked on a pseudo-event mode in which ``next``
        is called for each data arrival
        &#39;&#39;&#39;
        for strat in runstrats:
            strat._once()
            strat.reset()  # strat called next by next - reset lines

        # The default once for strategies does nothing and therefore
        # has not moved forward all datas/indicators/observers that
        # were homed before calling once, Hence no &#34;need&#34; to do it
        # here again, because pointers are at 0
        datas = sorted(self.datas,
                       key=lambda x: (x._timeframe, x._compression))

        while True:
            # Check next incoming date in the datas
            dts = [d.advance_peek() for d in datas]
            dt0 = min(dts)
            if dt0 == float(&#39;inf&#39;):
                break  # no data delivers anything

            # Timemaster if needed be
            # dmaster = datas[dts.index(dt0)]  # and timemaster
            slen = len(runstrats[0])
            for i, dti in enumerate(dts):
                if dti &lt;= dt0:
                    datas[i].advance()
                    # self._plotfillers2[i].append(slen)  # mark as fill
                else:
                    # self._plotfillers[i].append(slen)
                    pass

            self._check_timers(runstrats, dt0, cheat=True)

            if self.p.cheat_on_open:
                for strat in runstrats:
                    strat._oncepost_open()
                    if self._event_stop:  # stop if requested
                        return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            self._check_timers(runstrats, dt0, cheat=False)

            for strat in runstrats:
                strat._oncepost(dt0)
                if self._event_stop:  # stop if requested
                    return

                self._next_writers(runstrats)

    def _check_timers(self, runstrats, dt0, cheat=False):
        timers = self._timers if not cheat else self._timerscheat
        for t in timers:
            if not t.check(dt0):
                continue

            t.params.owner.notify_timer(t, t.lastwhen, *t.args, **t.kwargs)

            if t.params.strats:
                for strat in runstrats:
                    strat.notify_timer(t, t.lastwhen, *t.args, **t.kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.cerebro.Cerebro"><code class="flex name class">
<span>class <span class="ident">Cerebro</span></span>
</code></dt>
<dd>
<div class="desc"><p>Params</p>
<ul>
<li>
<p><code>preload</code> (default: <code>True</code>)</p>
<p>Whether to preload the different <code>data feeds</code> passed to cerebro for
the Strategies</p>
</li>
<li>
<p><code>runonce</code> (default: <code>True</code>)</p>
<p>Run <code>Indicators</code> in vectorized mode to speed up the entire system.
Strategies and Observers will always be run on an event based basis</p>
</li>
<li>
<p><code>live</code> (default: <code>False</code>)</p>
<p>If no data has reported itself as <em>live</em> (via the data's <code>islive</code>
method but the end user still want to run in <code>live</code> mode, this
parameter can be set to true</p>
<p>This will simultaneously deactivate <code>preload</code> and <code>runonce</code>. It
will have no effect on memory saving schemes.</p>
<p>Run <code>Indicators</code> in vectorized mode to speed up the entire system.
Strategies and Observers will always be run on an event based basis</p>
</li>
<li>
<p><code>maxcpus</code> (default: None -&gt; all available cores)</p>
<p>How many cores to use simultaneously for optimization</p>
</li>
<li>
<p><code>stdstats</code> (default: <code>True</code>)</p>
<p>If True default Observers will be added: Broker (Cash and Value),
Trades and BuySell</p>
</li>
<li>
<p><code>oldbuysell</code> (default: <code>False</code>)</p>
<p>If <code>stdstats</code> is <code>True</code> and observers are getting automatically
added, this switch controls the main behavior of the <code>BuySell</code>
observer</p>
<ul>
<li>
<p><code>False</code>: use the modern behavior in which the buy / sell signals
are plotted below / above the low / high prices respectively to avoid
cluttering the plot</p>
</li>
<li>
<p><code>True</code>: use the deprecated behavior in which the buy / sell signals
are plotted where the average price of the order executions for the
given moment in time is. This will of course be on top of an OHLC bar
or on a Line on Cloe bar, difficulting the recognition of the plot.</p>
</li>
<li><code>oldtrades</code> (default: <code>False</code>)</li>
</ul>
<p>If <code>stdstats</code> is <code>True</code> and observers are getting automatically
added, this switch controls the main behavior of the <code>Trades</code>
observer</p>
<ul>
<li>
<p><code>False</code>: use the modern behavior in which trades for all datas are
plotted with different markers</p>
</li>
<li>
<p><code>True</code>: use the old Trades observer which plots the trades with the
same markers, differentiating only if they are positive or negative</p>
</li>
</ul>
</li>
<li>
<p><code>exactbars</code> (default: <code>False</code>)</p>
<p>With the default value each and every value stored in a line is kept in
memory</p>
<p>Possible values</p>
<ul>
<li>
<p><code>True</code> or <code>1</code>: all "lines" objects reduce memory usage to the
automatically calculated minimum period.</p>
<p>If a Simple Moving Average has a period of 30, the underlying data
will have always a running buffer of 30 bars to allow the
calculation of the Simple Moving Average</p>
<ul>
<li>This setting will deactivate <code>preload</code> and <code>runonce</code></li>
<li>Using this setting also deactivates <strong>plotting</strong></li>
</ul>
</li>
<li>
<p><code>-1</code>: datafreeds and indicators/operations at strategy level will
keep all data in memory.</p>
<p>For example: a <code>RSI</code> internally uses the indicator <code>UpDay</code> to
make calculations. This subindicator will not keep all data in
memory</p>
<ul>
<li>
<p>This allows to keep <code>plotting</code> and <code>preloading</code> active.</p>
</li>
<li>
<p><code>runonce</code> will be deactivated</p>
</li>
</ul>
</li>
<li>
<p><code>-2</code>: data feeds and indicators kept as attributes of the
strategy will keep all points in memory.</p>
<p>For example: a <code>RSI</code> internally uses the indicator <code>UpDay</code> to
make calculations. This subindicator will not keep all data in
memory</p>
<p>If in the <code>__init__</code> something like
<code>a = self.data.close - self.data.high</code> is defined, then <code>a</code>
will not keep all data in memory</p>
<ul>
<li>
<p>This allows to keep <code>plotting</code> and <code>preloading</code> active.</p>
</li>
<li>
<p><code>runonce</code> will be deactivated</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>objcache</code> (default: <code>False</code>)</p>
<p>Experimental option to implement a cache of lines objects and reduce
the amount of them. Example from UltimateOscillator::</p>
<p>bp = self.data.close - TrueLow(self.data)
tr = TrueRange(self.data)
# -&gt; creates another TrueLow(self.data)</p>
<p>If this is <code>True</code> the 2nd <code>TrueLow(self.data)</code> inside <code>TrueRange</code>
matches the signature of the one in the <code>bp</code> calculation. It will be
reused.</p>
<p>Corner cases may happen in which this drives a line object off its
minimum period and breaks things and it is therefore disabled.</p>
</li>
<li>
<p><code>writer</code> (default: <code>False</code>)</p>
<p>If set to <code>True</code> a default WriterFile will be created which will
print to stdout. It will be added to the strategy (in addition to any
other writers added by the user code)</p>
</li>
<li>
<p><code>tradehistory</code> (default: <code>False</code>)</p>
<p>If set to <code>True</code>, it will activate update event logging in each trade
for all strategies. This can also be accomplished on a per strategy
basis with the strategy method <code>set_tradehistory</code></p>
</li>
<li>
<p><code>optdatas</code> (default: <code>True</code>)</p>
<p>If <code>True</code> and optimizing (and the system can <code>preload</code> and use
<code>runonce</code>, data preloading will be done only once in the main process
to save time and resources.</p>
<p>The tests show an approximate <code>20%</code> speed-up moving from a sample
execution in <code>83</code> seconds to <code>66</code></p>
</li>
<li>
<p><code>optreturn</code> (default: <code>True</code>)</p>
<p>If <code>True</code> the optimization results will not be full <code>Strategy</code>
objects (and all <em>datas</em>, <em>indicators</em>, <em>observers</em> &hellip;) but and object
with the following attributes (same as in <code>Strategy</code>):</p>
<ul>
<li><code>params</code> (or <code>p</code>) the strategy had for the execution</li>
<li><code>analyzers</code> the strategy has executed</li>
</ul>
<p>In most occassions, only the <em>analyzers</em> and with which <em>params</em> are
the things needed to evaluate a the performance of a strategy. If
detailed analysis of the generated values for (for example)
<em>indicators</em> is needed, turn this off</p>
<p>The tests show a <code>13% - 15%</code> improvement in execution time. Combined
with <code>optdatas</code> the total gain increases to a total speed-up of
<code>32%</code> in an optimization run.</p>
</li>
<li>
<p><code>oldsync</code> (default: <code>False</code>)</p>
<p>Starting with release 1.9.0.99 the synchronization of multiple datas
(same or different timeframes) has been changed to allow datas of
different lengths.</p>
<p>If the old behavior with data0 as the master of the system is wished,
set this parameter to true</p>
</li>
<li>
<p><code>tz</code> (default: <code>None</code>)</p>
<p>Adds a global timezone for strategies. The argument <code>tz</code> can be</p>
<ul>
<li>
<p><code>None</code>: in this case the datetime displayed by strategies will be
in UTC, which has been always the standard behavior</p>
</li>
<li>
<p><code>pytz</code> instance. It will be used as such to convert UTC times to
the chosen timezone</p>
</li>
<li>
<p><code>string</code>. Instantiating a <code>pytz</code> instance will be attempted.</p>
</li>
<li>
<p><code>integer</code>. Use, for the strategy, the same timezone as the
corresponding <code>data</code> in the <code>self.datas</code> iterable (<code>0</code> would
use the timezone from <code>data0</code>)</p>
</li>
</ul>
</li>
<li>
<p><code>cheat_on_open</code> (default: <code>False</code>)</p>
<p>The <code>next_open</code> method of strategies will be called. This happens
before <code>next</code> and before the broker has had a chance to evaluate
orders. The indicators have not yet been recalculated. This allows
issuing an orde which takes into account the indicators of the previous
day but uses the <code>open</code> price for stake calculations</p>
<p>For cheat_on_open order execution, it is also necessary to make the
call <code>cerebro.broker.set_coo(True)</code> or instantite a broker with
<code>BackBroker(coo=True)</code> (where <em>coo</em> stands for cheat-on-open) or set
the <code>broker_coo</code> parameter to <code>True</code>. Cerebro will do it
automatically unless disabled below.</p>
</li>
<li>
<p><code>broker_coo</code> (default: <code>True</code>)</p>
<p>This will automatically invoke the <code>set_coo</code> method of the broker
with <code>True</code> to activate <code>cheat_on_open</code> execution. Will only do it
if <code>cheat_on_open</code> is also <code>True</code></p>
</li>
<li>
<p><code>quicknotify</code> (default: <code>False</code>)</p>
<p>Broker notifications are delivered right before the delivery of the
<em>next</em> prices. For backtesting this has no implications, but with live
brokers a notification can take place long before the bar is
delivered. When set to <code>True</code> notifications will be delivered as soon
as possible (see <code>qcheck</code> in live feeds)</p>
<p>Set to <code>False</code> for compatibility. May be changed to <code>True</code></p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cerebro(with_metaclass(MetaParams, object)):
    &#39;&#39;&#39;
    Params

      - ``preload`` (default: ``True``)

        Whether to preload the different ``data feeds`` passed to cerebro for
        the Strategies

      - ``runonce`` (default: ``True``)

        Run ``Indicators`` in vectorized mode to speed up the entire system.
        Strategies and Observers will always be run on an event based basis

      - ``live`` (default: ``False``)

        If no data has reported itself as *live* (via the data&#39;s ``islive``
        method but the end user still want to run in ``live`` mode, this
        parameter can be set to true

        This will simultaneously deactivate ``preload`` and ``runonce``. It
        will have no effect on memory saving schemes.

        Run ``Indicators`` in vectorized mode to speed up the entire system.
        Strategies and Observers will always be run on an event based basis

      - ``maxcpus`` (default: None -&gt; all available cores)

        How many cores to use simultaneously for optimization

      - ``stdstats`` (default: ``True``)

        If True default Observers will be added: Broker (Cash and Value),
        Trades and BuySell

      - ``oldbuysell`` (default: ``False``)

        If ``stdstats`` is ``True`` and observers are getting automatically
        added, this switch controls the main behavior of the ``BuySell``
        observer

        - ``False``: use the modern behavior in which the buy / sell signals
          are plotted below / above the low / high prices respectively to avoid
          cluttering the plot

        - ``True``: use the deprecated behavior in which the buy / sell signals
          are plotted where the average price of the order executions for the
          given moment in time is. This will of course be on top of an OHLC bar
          or on a Line on Cloe bar, difficulting the recognition of the plot.
        - ``oldtrades`` (default: ``False``)

        If ``stdstats`` is ``True`` and observers are getting automatically
        added, this switch controls the main behavior of the ``Trades``
        observer

          - ``False``: use the modern behavior in which trades for all datas are
          plotted with different markers

          - ``True``: use the old Trades observer which plots the trades with the
          same markers, differentiating only if they are positive or negative

      - ``exactbars`` (default: ``False``)

        With the default value each and every value stored in a line is kept in
        memory

        Possible values

          - ``True`` or ``1``: all &#34;lines&#34; objects reduce memory usage to the
            automatically calculated minimum period.

            If a Simple Moving Average has a period of 30, the underlying data
            will have always a running buffer of 30 bars to allow the
            calculation of the Simple Moving Average

            - This setting will deactivate ``preload`` and ``runonce``
            - Using this setting also deactivates **plotting**

          - ``-1``: datafreeds and indicators/operations at strategy level will
            keep all data in memory.

            For example: a ``RSI`` internally uses the indicator ``UpDay`` to
            make calculations. This subindicator will not keep all data in
            memory

              - This allows to keep ``plotting`` and ``preloading`` active.

              - ``runonce`` will be deactivated

          - ``-2``: data feeds and indicators kept as attributes of the
            strategy will keep all points in memory.

            For example: a ``RSI`` internally uses the indicator ``UpDay`` to
            make calculations. This subindicator will not keep all data in
            memory

            If in the ``__init__`` something like
            ``a = self.data.close - self.data.high`` is defined, then ``a``
            will not keep all data in memory

            - This allows to keep ``plotting`` and ``preloading`` active.

            - ``runonce`` will be deactivated

      - ``objcache`` (default: ``False``)

        Experimental option to implement a cache of lines objects and reduce
        the amount of them. Example from UltimateOscillator::

          bp = self.data.close - TrueLow(self.data)
          tr = TrueRange(self.data)  # -&gt; creates another TrueLow(self.data)

        If this is ``True`` the 2nd ``TrueLow(self.data)`` inside ``TrueRange``
        matches the signature of the one in the ``bp`` calculation. It will be
        reused.

        Corner cases may happen in which this drives a line object off its
        minimum period and breaks things and it is therefore disabled.

      - ``writer`` (default: ``False``)

        If set to ``True`` a default WriterFile will be created which will
        print to stdout. It will be added to the strategy (in addition to any
        other writers added by the user code)

      - ``tradehistory`` (default: ``False``)

        If set to ``True``, it will activate update event logging in each trade
        for all strategies. This can also be accomplished on a per strategy
        basis with the strategy method ``set_tradehistory``

      - ``optdatas`` (default: ``True``)

        If ``True`` and optimizing (and the system can ``preload`` and use
        ``runonce``, data preloading will be done only once in the main process
        to save time and resources.

        The tests show an approximate ``20%`` speed-up moving from a sample
        execution in ``83`` seconds to ``66``

      - ``optreturn`` (default: ``True``)

        If ``True`` the optimization results will not be full ``Strategy``
        objects (and all *datas*, *indicators*, *observers* ...) but and object
        with the following attributes (same as in ``Strategy``):

          - ``params`` (or ``p``) the strategy had for the execution
          - ``analyzers`` the strategy has executed

        In most occassions, only the *analyzers* and with which *params* are
        the things needed to evaluate a the performance of a strategy. If
        detailed analysis of the generated values for (for example)
        *indicators* is needed, turn this off

        The tests show a ``13% - 15%`` improvement in execution time. Combined
        with ``optdatas`` the total gain increases to a total speed-up of
        ``32%`` in an optimization run.

      - ``oldsync`` (default: ``False``)

        Starting with release 1.9.0.99 the synchronization of multiple datas
        (same or different timeframes) has been changed to allow datas of
        different lengths.

        If the old behavior with data0 as the master of the system is wished,
        set this parameter to true

      - ``tz`` (default: ``None``)

        Adds a global timezone for strategies. The argument ``tz`` can be

          - ``None``: in this case the datetime displayed by strategies will be
            in UTC, which has been always the standard behavior

          - ``pytz`` instance. It will be used as such to convert UTC times to
            the chosen timezone

          - ``string``. Instantiating a ``pytz`` instance will be attempted.

          - ``integer``. Use, for the strategy, the same timezone as the
            corresponding ``data`` in the ``self.datas`` iterable (``0`` would
            use the timezone from ``data0``)

      - ``cheat_on_open`` (default: ``False``)

        The ``next_open`` method of strategies will be called. This happens
        before ``next`` and before the broker has had a chance to evaluate
        orders. The indicators have not yet been recalculated. This allows
        issuing an orde which takes into account the indicators of the previous
        day but uses the ``open`` price for stake calculations

        For cheat_on_open order execution, it is also necessary to make the
        call ``cerebro.broker.set_coo(True)`` or instantite a broker with
        ``BackBroker(coo=True)`` (where *coo* stands for cheat-on-open) or set
        the ``broker_coo`` parameter to ``True``. Cerebro will do it
        automatically unless disabled below.

      - ``broker_coo`` (default: ``True``)

        This will automatically invoke the ``set_coo`` method of the broker
        with ``True`` to activate ``cheat_on_open`` execution. Will only do it
        if ``cheat_on_open`` is also ``True``

      - ``quicknotify`` (default: ``False``)

        Broker notifications are delivered right before the delivery of the
        *next* prices. For backtesting this has no implications, but with live
        brokers a notification can take place long before the bar is
        delivered. When set to ``True`` notifications will be delivered as soon
        as possible (see ``qcheck`` in live feeds)

        Set to ``False`` for compatibility. May be changed to ``True``

    &#39;&#39;&#39;

    params = (
        (&#39;preload&#39;, True),
        (&#39;runonce&#39;, True),
        (&#39;maxcpus&#39;, None),
        (&#39;stdstats&#39;, True),
        (&#39;oldbuysell&#39;, False),
        (&#39;oldtrades&#39;, False),
        (&#39;lookahead&#39;, 0),
        (&#39;exactbars&#39;, False),
        (&#39;optdatas&#39;, True),
        (&#39;optreturn&#39;, True),
        (&#39;objcache&#39;, False),
        (&#39;live&#39;, False),
        (&#39;writer&#39;, False),
        (&#39;tradehistory&#39;, False),
        (&#39;oldsync&#39;, False),
        (&#39;tz&#39;, None),
        (&#39;cheat_on_open&#39;, False),
        (&#39;broker_coo&#39;, True),
        (&#39;quicknotify&#39;, False),
    )

    def __init__(self):
        self._dolive = False
        self._doreplay = False
        self._dooptimize = False
        self.stores = list()
        self.feeds = list()
        self.datas = list()
        self.datasbyname = collections.OrderedDict()
        self.strats = list()
        self.optcbs = list()  # holds a list of callbacks for opt strategies
        self.observers = list()
        self.analyzers = list()
        self.indicators = list()
        self.sizers = dict()
        self.writers = list()
        self.storecbs = list()
        self.datacbs = list()
        self.signals = list()
        self._signal_strat = (None, None, None)
        self._signal_concurrent = False
        self._signal_accumulate = False

        self._dataid = itertools.count(1)

        self._broker = BackBroker()
        self._broker.cerebro = self

        self._tradingcal = None  # TradingCalendar()

        self._pretimers = list()
        self._ohistory = list()
        self._fhistory = None

    @staticmethod
    def iterize(iterable):
        &#39;&#39;&#39;Handy function which turns things into things that can be iterated upon
        including iterables
        &#39;&#39;&#39;
        niterable = list()
        for elem in iterable:
            if isinstance(elem, string_types):
                elem = (elem,)
            elif not isinstance(elem, collectionsAbc.Iterable):  # Different functions will be called for different Python versions
                elem = (elem,)

            niterable.append(elem)

        return niterable

    def set_fund_history(self, fund):
        &#39;&#39;&#39;
        Add a history of orders to be directly executed in the broker for
        performance evaluation

          - ``fund``: is an iterable (ex: list, tuple, iterator, generator)
            in which each element will be also an iterable (with length) with
            the following sub-elements (2 formats are possible)

            ``[datetime, share_value, net asset value]``

            **Note**: it must be sorted (or produce sorted elements) by
              datetime ascending

            where:

              - ``datetime`` is a python ``date/datetime`` instance or a string
                with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
                brackets are optional
              - ``share_value`` is an float/integer
              - ``net_asset_value`` is a float/integer
        &#39;&#39;&#39;
        self._fhistory = fund

    def add_order_history(self, orders, notify=True):
        &#39;&#39;&#39;
        Add a history of orders to be directly executed in the broker for
        performance evaluation

          - ``orders``: is an iterable (ex: list, tuple, iterator, generator)
            in which each element will be also an iterable (with length) with
            the following sub-elements (2 formats are possible)

            ``[datetime, size, price]`` or ``[datetime, size, price, data]``

            **Note**: it must be sorted (or produce sorted elements) by
              datetime ascending

            where:

              - ``datetime`` is a python ``date/datetime`` instance or a string
                with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
                brackets are optional
              - ``size`` is an integer (positive to *buy*, negative to *sell*)
              - ``price`` is a float/integer
              - ``data`` if present can take any of the following values

                - *None* - The 1st data feed will be used as target
                - *integer* - The data with that index (insertion order in
                  **Cerebro**) will be used
                - *string* - a data with that name, assigned for example with
                  ``cerebro.addata(data, name=value)``, will be the target

          - ``notify`` (default: *True*)

            If ``True`` the 1st strategy inserted in the system will be
            notified of the artificial orders created following the information
            from each order in ``orders``

        **Note**: Implicit in the description is the need to add a data feed
          which is the target of the orders. This is for example needed by
          analyzers which track for example the returns
        &#39;&#39;&#39;
        self._ohistory.append((orders, notify))

    def notify_timer(self, timer, when, *args, **kwargs):
        &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
        returned by ``add_timer``, and ``when`` is the calling time. ``args``
        and ``kwargs`` are any additional arguments passed to ``add_timer``

        The actual ``when`` time can be later, but the system may have not be
        able to call the timer before. This value is the timer value and no the
        system time.
        &#39;&#39;&#39;
        pass

    def _add_timer(self, owner, when,
                   offset=datetime.timedelta(), repeat=datetime.timedelta(),
                   weekdays=[], weekcarry=False,
                   monthdays=[], monthcarry=True,
                   allow=None,
                   tzdata=None, strats=False, cheat=False,
                   *args, **kwargs):
        &#39;&#39;&#39;Internal method to really create the timer (not started yet) which
        can be called by cerebro instances or other objects which can access
        cerebro&#39;&#39;&#39;

        timer = Timer(
            tid=len(self._pretimers),
            owner=owner, strats=strats,
            when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, cheat=cheat,
            *args, **kwargs
        )

        self._pretimers.append(timer)
        return timer

    def add_timer(self, when,
                  offset=datetime.timedelta(), repeat=datetime.timedelta(),
                  weekdays=[], weekcarry=False,
                  monthdays=[], monthcarry=True,
                  allow=None,
                  tzdata=None, strats=False, cheat=False,
                  *args, **kwargs):
        &#39;&#39;&#39;
        Schedules a timer to invoke ``notify_timer``

        Arguments:

          - ``when``: can be

            - ``datetime.time`` instance (see below ``tzdata``)
            - ``bt.timer.SESSION_START`` to reference a session start
            - ``bt.timer.SESSION_END`` to reference a session end

         - ``offset`` which must be a ``datetime.timedelta`` instance

           Used to offset the value ``when``. It has a meaningful use in
           combination with ``SESSION_START`` and ``SESSION_END``, to indicated
           things like a timer being called ``15 minutes`` after the session
           start.

          - ``repeat`` which must be a ``datetime.timedelta`` instance

            Indicates if after a 1st call, further calls will be scheduled
            within the same session at the scheduled ``repeat`` delta

            Once the timer goes over the end of the session it is reset to the
            original value for ``when``

          - ``weekdays``: a **sorted** iterable with integers indicating on
            which days (iso codes, Monday is 1, Sunday is 7) the timers can
            be actually invoked

            If not specified, the timer will be active on all days

          - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
            not seen (ex: trading holiday), the timer will be executed on the
            next day (even if in a new week)

          - ``monthdays``: a **sorted** iterable with integers indicating on
            which days of the month a timer has to be executed. For example
            always on day *15* of the month

            If not specified, the timer will be active on all days

          - ``monthcarry`` (default: ``True``). If the day was not seen
            (weekend, trading holiday), the timer will be executed on the next
            available day.

          - ``allow`` (default: ``None``). A callback which receives a
            `datetime.date`` instance and returns ``True`` if the date is
            allowed for timers or else returns ``False``

          - ``tzdata`` which can be either ``None`` (default), a ``pytz``
            instance or a ``data feed`` instance.

            ``None``: ``when`` is interpreted at face value (which translates
            to handling it as if it where UTC even if it&#39;s not)

            ``pytz`` instance: ``when`` will be interpreted as being specified
            in the local time specified by the timezone instance.

            ``data feed`` instance: ``when`` will be interpreted as being
            specified in the local time specified by the ``tz`` parameter of
            the data feed instance.

            **Note**: If ``when`` is either ``SESSION_START`` or
              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
              in the system (aka ``self.data0``) will be used as the reference
              to find out the session times.

          - ``strats`` (default: ``False``) call also the ``notify_timer`` of
            strategies

          - ``cheat`` (default ``False``) if ``True`` the timer will be called
            before the broker has a chance to evaluate the orders. This opens
            the chance to issue orders based on opening price for example right
            before the session starts
          - ``*args``: any extra args will be passed to ``notify_timer``

          - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

        Return Value:

          - The created timer

        &#39;&#39;&#39;
        return self._add_timer(
            owner=self, when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, strats=strats, cheat=cheat,
            *args, **kwargs)

    def addtz(self, tz):
        &#39;&#39;&#39;
        This can also be done with the parameter ``tz``

        Adds a global timezone for strategies. The argument ``tz`` can be

          - ``None``: in this case the datetime displayed by strategies will be
            in UTC, which has been always the standard behavior

          - ``pytz`` instance. It will be used as such to convert UTC times to
            the chosen timezone

          - ``string``. Instantiating a ``pytz`` instance will be attempted.

          - ``integer``. Use, for the strategy, the same timezone as the
            corresponding ``data`` in the ``self.datas`` iterable (``0`` would
            use the timezone from ``data0``)

        &#39;&#39;&#39;
        self.p.tz = tz

    def addcalendar(self, cal):
        &#39;&#39;&#39;Adds a global trading calendar to the system. Individual data feeds
        may have separate calendars which override the global one

        ``cal`` can be an instance of ``TradingCalendar`` a string or an
        instance of ``pandas_market_calendars``. A string will be will be
        instantiated as a ``PandasMarketCalendar`` (which needs the module
        ``pandas_market_calendar`` installed in the system.

        If a subclass of `TradingCalendarBase` is passed (not an instance) it
        will be instantiated
        &#39;&#39;&#39;
        if isinstance(cal, string_types):
            cal = PandasMarketCalendar(calendar=cal)
        elif hasattr(cal, &#39;valid_days&#39;):
            cal = PandasMarketCalendar(calendar=cal)

        else:
            try:
                if issubclass(cal, TradingCalendarBase):
                    cal = cal()
            except TypeError:  # already an instance
                pass

        self._tradingcal = cal

    def add_signal(self, sigtype, sigcls, *sigargs, **sigkwargs):
        &#39;&#39;&#39;Adds a signal to the system which will be later added to a
        ``SignalStrategy``&#39;&#39;&#39;
        self.signals.append((sigtype, sigcls, sigargs, sigkwargs))

    def signal_strategy(self, stratcls, *args, **kwargs):
        &#39;&#39;&#39;Adds a SignalStrategy subclass which can accept signals&#39;&#39;&#39;
        self._signal_strat = (stratcls, args, kwargs)

    def signal_concurrent(self, onoff):
        &#39;&#39;&#39;If signals are added to the system and the ``concurrent`` value is
        set to True, concurrent orders will be allowed&#39;&#39;&#39;
        self._signal_concurrent = onoff

    def signal_accumulate(self, onoff):
        &#39;&#39;&#39;If signals are added to the system and the ``accumulate`` value is
        set to True, entering the market when already in the market, will be
        allowed to increase a position&#39;&#39;&#39;
        self._signal_accumulate = onoff

    def addstore(self, store):
        &#39;&#39;&#39;Adds an ``Store`` instance to the if not already present&#39;&#39;&#39;
        if store not in self.stores:
            self.stores.append(store)

    def addwriter(self, wrtcls, *args, **kwargs):
        &#39;&#39;&#39;Adds an ``Writer`` class to the mix. Instantiation will be done at
        ``run`` time in cerebro
        &#39;&#39;&#39;
        self.writers.append((wrtcls, args, kwargs))

    def addsizer(self, sizercls, *args, **kwargs):
        &#39;&#39;&#39;Adds a ``Sizer`` class (and args) which is the default sizer for any
        strategy added to cerebro
        &#39;&#39;&#39;
        self.sizers[None] = (sizercls, args, kwargs)

    def addsizer_byidx(self, idx, sizercls, *args, **kwargs):
        &#39;&#39;&#39;Adds a ``Sizer`` class by idx. This idx is a reference compatible to
        the one returned by ``addstrategy``. Only the strategy referenced by
        ``idx`` will receive this size
        &#39;&#39;&#39;
        self.sizers[idx] = (sizercls, args, kwargs)

    def addindicator(self, indcls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Indicator`` class to the mix. Instantiation will be done at
        ``run`` time in the passed strategies
        &#39;&#39;&#39;
        self.indicators.append((indcls, args, kwargs))

    def addanalyzer(self, ancls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Analyzer`` class to the mix. Instantiation will be done at
        ``run`` time
        &#39;&#39;&#39;
        self.analyzers.append((ancls, args, kwargs))

    def addobserver(self, obscls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Observer`` class to the mix. Instantiation will be done at
        ``run`` time
        &#39;&#39;&#39;
        self.observers.append((False, obscls, args, kwargs))

    def addobservermulti(self, obscls, *args, **kwargs):
        &#39;&#39;&#39;
        Adds an ``Observer`` class to the mix. Instantiation will be done at
        ``run`` time

        It will be added once per &#34;data&#34; in the system. A use case is a
        buy/sell observer which observes individual datas.

        A counter-example is the CashValue, which observes system-wide values
        &#39;&#39;&#39;
        self.observers.append((True, obscls, args, kwargs))

    def addstorecb(self, callback):
        &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
        notify_store method

        The signature of the callback must support the following:

          - callback(msg, \*args, \*\*kwargs)

        The actual ``msg``, ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        self.storecbs.append(callback)

    def _notify_store(self, msg, *args, **kwargs):
        for callback in self.storecbs:
            callback(msg, *args, **kwargs)

        self.notify_store(msg, *args, **kwargs)

    def notify_store(self, msg, *args, **kwargs):
        &#39;&#39;&#39;Receive store notifications in cerebro

        This method can be overridden in ``Cerebro`` subclasses

        The actual ``msg``, ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        pass

    def _storenotify(self):
        for store in self.stores:
            for notif in store.get_notifications():
                msg, args, kwargs = notif

                self._notify_store(msg, *args, **kwargs)
                for strat in self.runningstrats:
                    strat.notify_store(msg, *args, **kwargs)

    def adddatacb(self, callback):
        &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
        notify_data method

        The signature of the callback must support the following:

          - callback(data, status, \*args, \*\*kwargs)

        The actual ``*args`` and ``**kwargs`` received are implementation
        defined (depend entirely on the *data/broker/store*) but in general one
        should expect them to be *printable* to allow for reception and
        experimentation.
        &#39;&#39;&#39;
        self.datacbs.append(callback)

    def _datanotify(self):
        for data in self.datas:
            for notif in data.get_notifications():
                status, args, kwargs = notif
                self._notify_data(data, status, *args, **kwargs)
                for strat in self.runningstrats:
                    strat.notify_data(data, status, *args, **kwargs)

    def _notify_data(self, data, status, *args, **kwargs):
        for callback in self.datacbs:
            callback(data, status, *args, **kwargs)

        self.notify_data(data, status, *args, **kwargs)

    def notify_data(self, data, status, *args, **kwargs):
        &#39;&#39;&#39;Receive data notifications in cerebro

        This method can be overridden in ``Cerebro`` subclasses

        The actual ``*args`` and ``**kwargs`` received are
        implementation defined (depend entirely on the *data/broker/store*) but
        in general one should expect them to be *printable* to allow for
        reception and experimentation.
        &#39;&#39;&#39;
        pass

    def adddata(self, data, name=None):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` instance to the mix.

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.
        &#39;&#39;&#39;
        if name is not None:
            data._name = name

        data._id = next(self._dataid)
        data.setenvironment(self)

        self.datas.append(data)
        self.datasbyname[data._name] = data
        feed = data.getfeed()
        if feed and feed not in self.feeds:
            self.feeds.append(feed)

        if data.islive():
            self._dolive = True

        return data

    def chaindata(self, *args, **kwargs):
        &#39;&#39;&#39;
        Chains several data feeds into one

        If ``name`` is passed as named argument and is not None it will be put
        into ``data._name`` which is meant for decoration/plotting purposes.

        If ``None``, then the name of the 1st data will be used
        &#39;&#39;&#39;
        dname = kwargs.pop(&#39;name&#39;, None)
        if dname is None:
            dname = args[0]._dataname
        d = bt.feeds.Chainer(dataname=dname, *args)
        self.adddata(d, name=dname)

        return d

    def rolloverdata(self, *args, **kwargs):
        &#39;&#39;&#39;Chains several data feeds into one

        If ``name`` is passed as named argument and is not None it will be put
        into ``data._name`` which is meant for decoration/plotting purposes.

        If ``None``, then the name of the 1st data will be used

        Any other kwargs will be passed to the RollOver class

        &#39;&#39;&#39;
        dname = kwargs.pop(&#39;name&#39;, None)
        if dname is None:
            dname = args[0]._dataname
        d = bt.feeds.RollOver(dataname=dname, *args, **kwargs)
        self.adddata(d, name=dname)

        return d

    def replaydata(self, dataname, name=None, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` to be replayed by the system

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.

        Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
        are supported by the replay filter will be passed transparently
        &#39;&#39;&#39;
        if any(dataname is x for x in self.datas):
            dataname = dataname.clone()

        dataname.replay(**kwargs)
        self.adddata(dataname, name=name)
        self._doreplay = True

        return dataname

    def resampledata(self, dataname, name=None, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Data Feed`` to be resample by the system

        If ``name`` is not None it will be put into ``data._name`` which is
        meant for decoration/plotting purposes.

        Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
        are supported by the resample filter will be passed transparently
        &#39;&#39;&#39;
        if any(dataname is x for x in self.datas):
            dataname = dataname.clone()

        dataname.resample(**kwargs)
        self.adddata(dataname, name=name)
        self._doreplay = True

        return dataname

    def optcallback(self, cb):
        &#39;&#39;&#39;
        Adds a *callback* to the list of callbacks that will be called with the
        optimizations when each of the strategies has been run

        The signature: cb(strategy)
        &#39;&#39;&#39;
        self.optcbs.append(cb)

    def optstrategy(self, strategy, *args, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Strategy`` class to the mix for optimization. Instantiation
        will happen during ``run`` time.

        args and kwargs MUST BE iterables which hold the values to check.

        Example: if a Strategy accepts a parameter ``period``, for optimization
        purposes the call to ``optstrategy`` looks like:

          - cerebro.optstrategy(MyStrategy, period=(15, 25))

        This will execute an optimization for values 15 and 25. Whereas

          - cerebro.optstrategy(MyStrategy, period=range(15, 25))

        will execute MyStrategy with ``period`` values 15 -&gt; 25 (25 not
        included, because ranges are semi-open in Python)

        If a parameter is passed but shall not be optimized the call looks
        like:

          - cerebro.optstrategy(MyStrategy, period=(15,))

        Notice that ``period`` is still passed as an iterable ... of just 1
        element

        ``backtrader`` will anyhow try to identify situations like:

          - cerebro.optstrategy(MyStrategy, period=15)

        and will create an internal pseudo-iterable if possible
        &#39;&#39;&#39;
        self._dooptimize = True
        args = self.iterize(args)
        optargs = itertools.product(*args)

        optkeys = list(kwargs)

        vals = self.iterize(kwargs.values())
        optvals = itertools.product(*vals)

        okwargs1 = map(zip, itertools.repeat(optkeys), optvals)

        optkwargs = map(dict, okwargs1)

        it = itertools.product([strategy], optargs, optkwargs)
        self.strats.append(it)

    def addstrategy(self, strategy, *args, **kwargs):
        &#39;&#39;&#39;
        Adds a ``Strategy`` class to the mix for a single pass run.
        Instantiation will happen during ``run`` time.

        args and kwargs will be passed to the strategy as they are during
        instantiation.

        Returns the index with which addition of other objects (like sizers)
        can be referenced
        &#39;&#39;&#39;
        self.strats.append([(strategy, args, kwargs)])
        return len(self.strats) - 1

    def setbroker(self, broker):
        &#39;&#39;&#39;
        Sets a specific ``broker`` instance for this strategy, replacing the
        one inherited from cerebro.
        &#39;&#39;&#39;
        self._broker = broker
        broker.cerebro = self
        return broker

    def getbroker(self):
        &#39;&#39;&#39;
        Returns the broker instance.

        This is also available as a ``property`` by the name ``broker``
        &#39;&#39;&#39;
        return self._broker

    broker = property(getbroker, setbroker)

    def plot(self, plotter=None, numfigs=1, iplot=True, start=None, end=None,
             width=16, height=9, dpi=300, tight=True, use=None,
             **kwargs):
        &#39;&#39;&#39;
        Plots the strategies inside cerebro

        If ``plotter`` is None a default ``Plot`` instance is created and
        ``kwargs`` are passed to it during instantiation.

        ``numfigs`` split the plot in the indicated number of charts reducing
        chart density if wished

        ``iplot``: if ``True`` and running in a ``notebook`` the charts will be
        displayed inline

        ``use``: set it to the name of the desired matplotlib backend. It will
        take precedence over ``iplot``

        ``start``: An index to the datetime line array of the strategy or a
        ``datetime.date``, ``datetime.datetime`` instance indicating the start
        of the plot

        ``end``: An index to the datetime line array of the strategy or a
        ``datetime.date``, ``datetime.datetime`` instance indicating the end
        of the plot

        ``width``: in inches of the saved figure

        ``height``: in inches of the saved figure

        ``dpi``: quality in dots per inches of the saved figure

        ``tight``: only save actual content and not the frame of the figure
        &#39;&#39;&#39;
        if self._exactbars &gt; 0:
            return

        if not plotter:
            from . import plot
            if self.p.oldsync:
                plotter = plot.Plot_OldSync(**kwargs)
            else:
                plotter = plot.Plot(**kwargs)

        # pfillers = {self.datas[i]: self._plotfillers[i]
        # for i, x in enumerate(self._plotfillers)}

        # pfillers2 = {self.datas[i]: self._plotfillers2[i]
        # for i, x in enumerate(self._plotfillers2)}

        figs = []
        for stratlist in self.runstrats:
            for si, strat in enumerate(stratlist):
                rfig = plotter.plot(strat, figid=si * 100,
                                    numfigs=numfigs, iplot=iplot,
                                    start=start, end=end, use=use)
                # pfillers=pfillers2)

                figs.append(rfig)

            plotter.show()

        return figs

    def __call__(self, iterstrat):
        &#39;&#39;&#39;
        Used during optimization to pass the cerebro over the multiprocesing
        module without complains
        &#39;&#39;&#39;

        predata = self.p.optdatas and self._dopreload and self._dorunonce
        return self.runstrategies(iterstrat, predata=predata)

    def __getstate__(self):
        &#39;&#39;&#39;
        Used during optimization to prevent optimization result `runstrats`
        from being pickled to subprocesses
        &#39;&#39;&#39;

        rv = vars(self).copy()
        if &#39;runstrats&#39; in rv:
            del(rv[&#39;runstrats&#39;])
        return rv

    def runstop(self):
        &#39;&#39;&#39;If invoked from inside a strategy or anywhere else, including other
        threads the execution will stop as soon as possible.&#39;&#39;&#39;
        self._event_stop = True  # signal a stop has been requested

    def run(self, **kwargs):
        &#39;&#39;&#39;The core method to perform backtesting. Any ``kwargs`` passed to it
        will affect the value of the standard parameters ``Cerebro`` was
        instantiated with.

        If ``cerebro`` has not datas the method will immediately bail out.

        It has different return values:

          - For No Optimization: a list contanining instances of the Strategy
            classes added with ``addstrategy``

          - For Optimization: a list of lists which contain instances of the
            Strategy classes added with ``addstrategy``
        &#39;&#39;&#39;
        self._event_stop = False  # Stop is requested

        if not self.datas:
            return []  # nothing can be run

        pkeys = self.params._getkeys()
        for key, val in kwargs.items():
            if key in pkeys:
                setattr(self.params, key, val)

        # Manage activate/deactivate object cache
        linebuffer.LineActions.cleancache()  # clean cache
        indicator.Indicator.cleancache()  # clean cache

        linebuffer.LineActions.usecache(self.p.objcache)
        indicator.Indicator.usecache(self.p.objcache)

        self._dorunonce = self.p.runonce
        self._dopreload = self.p.preload
        self._exactbars = int(self.p.exactbars)

        if self._exactbars:
            self._dorunonce = False  # something is saving memory, no runonce
            self._dopreload = self._dopreload and self._exactbars &lt; 1

        self._doreplay = self._doreplay or any(x.replaying for x in self.datas)
        if self._doreplay:
            # preloading is not supported with replay. full timeframe bars
            # are constructed in realtime
            self._dopreload = False

        if self._dolive or self.p.live:
            # in this case both preload and runonce must be off
            self._dorunonce = False
            self._dopreload = False

        self.runwriters = list()

        # Add the system default writer if requested
        if self.p.writer is True:
            wr = WriterFile()
            self.runwriters.append(wr)

        # Instantiate any other writers
        for wrcls, wrargs, wrkwargs in self.writers:
            wr = wrcls(*wrargs, **wrkwargs)
            self.runwriters.append(wr)

        # Write down if any writer wants the full csv output
        self.writers_csv = any(map(lambda x: x.p.csv, self.runwriters))

        self.runstrats = list()

        if self.signals:  # allow processing of signals
            signalst, sargs, skwargs = self._signal_strat
            if signalst is None:
                # Try to see if the 1st regular strategy is a signal strategy
                try:
                    signalst, sargs, skwargs = self.strats.pop(0)
                except IndexError:
                    pass  # Nothing there
                else:
                    if not isinstance(signalst, SignalStrategy):
                        # no signal ... reinsert at the beginning
                        self.strats.insert(0, (signalst, sargs, skwargs))
                        signalst = None  # flag as not presetn

            if signalst is None:  # recheck
                # Still None, create a default one
                signalst, sargs, skwargs = SignalStrategy, tuple(), dict()

            # Add the signal strategy
            self.addstrategy(signalst,
                             _accumulate=self._signal_accumulate,
                             _concurrent=self._signal_concurrent,
                             signals=self.signals,
                             *sargs,
                             **skwargs)

        if not self.strats:  # Datas are present, add a strategy
            self.addstrategy(Strategy)

        iterstrats = itertools.product(*self.strats)
        if not self._dooptimize or self.p.maxcpus == 1:
            # If no optimmization is wished ... or 1 core is to be used
            # let&#39;s skip process &#34;spawning&#34;
            for iterstrat in iterstrats:
                runstrat = self.runstrategies(iterstrat)
                self.runstrats.append(runstrat)
                if self._dooptimize:
                    for cb in self.optcbs:
                        cb(runstrat)  # callback receives finished strategy
        else:
            if self.p.optdatas and self._dopreload and self._dorunonce:
                for data in self.datas:
                    data.reset()
                    if self._exactbars &lt; 1:  # datas can be full length
                        data.extend(size=self.params.lookahead)
                    data._start()
                    if self._dopreload:
                        data.preload()

            pool = multiprocessing.Pool(self.p.maxcpus or None)
            for r in pool.imap(self, iterstrats):
                self.runstrats.append(r)
                for cb in self.optcbs:
                    cb(r)  # callback receives finished strategy

            pool.close()

            if self.p.optdatas and self._dopreload and self._dorunonce:
                for data in self.datas:
                    data.stop()

        if not self._dooptimize:
            # avoid a list of list for regular cases
            return self.runstrats[0]

        return self.runstrats

    def _init_stcount(self):
        self.stcount = itertools.count(0)

    def _next_stid(self):
        return next(self.stcount)

    def runstrategies(self, iterstrat, predata=False):
        &#39;&#39;&#39;
        Internal method invoked by ``run``` to run a set of strategies
        &#39;&#39;&#39;
        self._init_stcount()

        self.runningstrats = runstrats = list()
        for store in self.stores:
            store.start()

        if self.p.cheat_on_open and self.p.broker_coo:
            # try to activate in broker
            if hasattr(self._broker, &#39;set_coo&#39;):
                self._broker.set_coo(True)

        if self._fhistory is not None:
            self._broker.set_fund_history(self._fhistory)

        for orders, onotify in self._ohistory:
            self._broker.add_order_history(orders, onotify)

        self._broker.start()

        for feed in self.feeds:
            feed.start()

        if self.writers_csv:
            wheaders = list()
            for data in self.datas:
                if data.csv:
                    wheaders.extend(data.getwriterheaders())

            for writer in self.runwriters:
                if writer.p.csv:
                    writer.addheaders(wheaders)

        # self._plotfillers = [list() for d in self.datas]
        # self._plotfillers2 = [list() for d in self.datas]

        if not predata:
            for data in self.datas:
                data.reset()
                if self._exactbars &lt; 1:  # datas can be full length
                    data.extend(size=self.params.lookahead)
                data._start()
                if self._dopreload:
                    data.preload()

        for stratcls, sargs, skwargs in iterstrat:
            sargs = self.datas + list(sargs)
            try:
                strat = stratcls(*sargs, **skwargs)
            except bt.errors.StrategySkipError:
                continue  # do not add strategy to the mix

            if self.p.oldsync:
                strat._oldsync = True  # tell strategy to use old clock update
            if self.p.tradehistory:
                strat.set_tradehistory()
            runstrats.append(strat)

        tz = self.p.tz
        if isinstance(tz, integer_types):
            tz = self.datas[tz]._tz
        else:
            tz = tzparse(tz)

        if runstrats:
            # loop separated for clarity
            defaultsizer = self.sizers.get(None, (None, None, None))
            for idx, strat in enumerate(runstrats):
                if self.p.stdstats:
                    strat._addobserver(False, observers.Broker)
                    if self.p.oldbuysell:
                        strat._addobserver(True, observers.BuySell)
                    else:
                        strat._addobserver(True, observers.BuySell,
                                           barplot=True)

                    if self.p.oldtrades or len(self.datas) == 1:
                        strat._addobserver(False, observers.Trades)
                    else:
                        strat._addobserver(False, observers.DataTrades)

                for multi, obscls, obsargs, obskwargs in self.observers:
                    strat._addobserver(multi, obscls, *obsargs, **obskwargs)

                for indcls, indargs, indkwargs in self.indicators:
                    strat._addindicator(indcls, *indargs, **indkwargs)

                for ancls, anargs, ankwargs in self.analyzers:
                    strat._addanalyzer(ancls, *anargs, **ankwargs)

                sizer, sargs, skwargs = self.sizers.get(idx, defaultsizer)
                if sizer is not None:
                    strat._addsizer(sizer, *sargs, **skwargs)

                strat._settz(tz)
                strat._start()

                for writer in self.runwriters:
                    if writer.p.csv:
                        writer.addheaders(strat.getwriterheaders())

            if not predata:
                for strat in runstrats:
                    strat.qbuffer(self._exactbars, replaying=self._doreplay)

            for writer in self.runwriters:
                writer.start()

            # Prepare timers
            self._timers = []
            self._timerscheat = []
            for timer in self._pretimers:
                # preprocess tzdata if needed
                timer.start(self.datas[0])

                if timer.params.cheat:
                    self._timerscheat.append(timer)
                else:
                    self._timers.append(timer)

            if self._dopreload and self._dorunonce:
                if self.p.oldsync:
                    self._runonce_old(runstrats)
                else:
                    self._runonce(runstrats)
            else:
                if self.p.oldsync:
                    self._runnext_old(runstrats)
                else:
                    self._runnext(runstrats)

            for strat in runstrats:
                strat._stop()

        self._broker.stop()

        if not predata:
            for data in self.datas:
                data.stop()

        for feed in self.feeds:
            feed.stop()

        for store in self.stores:
            store.stop()

        self.stop_writers(runstrats)

        if self._dooptimize and self.p.optreturn:
            # Results can be optimized
            results = list()
            for strat in runstrats:
                for a in strat.analyzers:
                    a.strategy = None
                    a._parent = None
                    for attrname in dir(a):
                        if attrname.startswith(&#39;data&#39;):
                            setattr(a, attrname, None)

                oreturn = OptReturn(strat.params, analyzers=strat.analyzers, strategycls=type(strat))
                results.append(oreturn)

            return results

        return runstrats

    def stop_writers(self, runstrats):
        cerebroinfo = OrderedDict()
        datainfos = OrderedDict()

        for i, data in enumerate(self.datas):
            datainfos[&#39;Data%d&#39; % i] = data.getwriterinfo()

        cerebroinfo[&#39;Datas&#39;] = datainfos

        stratinfos = dict()
        for strat in runstrats:
            stname = strat.__class__.__name__
            stratinfos[stname] = strat.getwriterinfo()

        cerebroinfo[&#39;Strategies&#39;] = stratinfos

        for writer in self.runwriters:
            writer.writedict(dict(Cerebro=cerebroinfo))
            writer.stop()

    def _brokernotify(self):
        &#39;&#39;&#39;
        Internal method which kicks the broker and delivers any broker
        notification to the strategy
        &#39;&#39;&#39;
        self._broker.next()
        while True:
            order = self._broker.get_notification()
            if order is None:
                break

            owner = order.owner
            if owner is None:
                owner = self.runningstrats[0]  # default

            owner._addnotification(order, quicknotify=self.p.quicknotify)

    def _runnext_old(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in full next mode. All objects have its
        ``next`` method invoke on each data arrival
        &#39;&#39;&#39;
        data0 = self.datas[0]
        d0ret = True
        while d0ret or d0ret is None:
            lastret = False
            # Notify anything from the store even before moving datas
            # because datas may not move due to an error reported by the store
            self._storenotify()
            if self._event_stop:  # stop if requested
                return
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            d0ret = data0.next()
            if d0ret:
                for data in self.datas[1:]:
                    if not data.next(datamaster=data0):  # no delivery
                        data._check(forcedata=data0)  # check forcing output
                        data.next(datamaster=data0)  # retry

            elif d0ret is None:
                # meant for things like live feeds which may not produce a bar
                # at the moment but need the loop to run for notifications and
                # getting resample and others to produce timely bars
                data0._check()
                for data in self.datas[1:]:
                    data._check()
            else:
                lastret = data0._last()
                for data in self.datas[1:]:
                    lastret += data._last(datamaster=data0)

                if not lastret:
                    # Only go extra round if something was changed by &#34;lasts&#34;
                    break

            # Datas may have generated a new notification after next
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # bars produced by data or filters
                for strat in runstrats:
                    strat._next()
                    if self._event_stop:  # stop if requested
                        return

                    self._next_writers(runstrats)

        # Last notification chance before stopping
        self._datanotify()
        if self._event_stop:  # stop if requested
            return
        self._storenotify()
        if self._event_stop:  # stop if requested
            return

    def _runonce_old(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in vector mode.
        Strategies are still invoked on a pseudo-event mode in which ``next``
        is called for each data arrival
        &#39;&#39;&#39;
        for strat in runstrats:
            strat._once()

        # The default once for strategies does nothing and therefore
        # has not moved forward all datas/indicators/observers that
        # were homed before calling once, Hence no &#34;need&#34; to do it
        # here again, because pointers are at 0
        data0 = self.datas[0]
        datas = self.datas[1:]
        for i in range(data0.buflen()):
            data0.advance()
            for data in datas:
                data.advance(datamaster=data0)

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            for strat in runstrats:
                # data0.datetime[0] for compat. w/ new strategy&#39;s oncepost
                strat._oncepost(data0.datetime[0])
                if self._event_stop:  # stop if requested
                    return

                self._next_writers(runstrats)

    def _next_writers(self, runstrats):
        if not self.runwriters:
            return

        if self.writers_csv:
            wvalues = list()
            for data in self.datas:
                if data.csv:
                    wvalues.extend(data.getwritervalues())

            for strat in runstrats:
                wvalues.extend(strat.getwritervalues())

            for writer in self.runwriters:
                if writer.p.csv:
                    writer.addvalues(wvalues)

                    writer.next()

    def _disable_runonce(self):
        &#39;&#39;&#39;API for lineiterators to disable runonce (see HeikinAshi)&#39;&#39;&#39;
        self._dorunonce = False

    def _runnext(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in full next mode. All objects have its
        ``next`` method invoke on each data arrival
        &#39;&#39;&#39;
        datas = sorted(self.datas,
                       key=lambda x: (x._timeframe, x._compression))
        datas1 = datas[1:]
        data0 = datas[0]
        d0ret = True

        rs = [i for i, x in enumerate(datas) if x.resampling]
        rp = [i for i, x in enumerate(datas) if x.replaying]
        rsonly = [i for i, x in enumerate(datas)
                  if x.resampling and not x.replaying]
        onlyresample = len(datas) == len(rsonly)
        noresample = not rsonly

        clonecount = sum(d._clone for d in datas)
        ldatas = len(datas)
        ldatas_noclones = ldatas - clonecount
        lastqcheck = False
        dt0 = date2num(datetime.datetime.max) - 2  # default at max
        while d0ret or d0ret is None:
            # if any has live data in the buffer, no data will wait anything
            newqcheck = not any(d.haslivedata() for d in datas)
            if not newqcheck:
                # If no data has reached the live status or all, wait for
                # the next incoming data
                livecount = sum(d._laststatus == d.LIVE for d in datas)
                newqcheck = not livecount or livecount == ldatas_noclones

            lastret = False
            # Notify anything from the store even before moving datas
            # because datas may not move due to an error reported by the store
            self._storenotify()
            if self._event_stop:  # stop if requested
                return
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            # record starting time and tell feeds to discount the elapsed time
            # from the qcheck value
            drets = []
            qstart = datetime.datetime.utcnow()
            for d in datas:
                qlapse = datetime.datetime.utcnow() - qstart
                d.do_qcheck(newqcheck, qlapse.total_seconds())
                drets.append(d.next(ticks=False))

            d0ret = any((dret for dret in drets))
            if not d0ret and any((dret is None for dret in drets)):
                d0ret = None

            if d0ret:
                dts = []
                for i, ret in enumerate(drets):
                    dts.append(datas[i].datetime[0] if ret else None)

                # Get index to minimum datetime
                if onlyresample or noresample:
                    dt0 = min((d for d in dts if d is not None))
                else:
                    dt0 = min((d for i, d in enumerate(dts)
                               if d is not None and i not in rsonly))

                dmaster = datas[dts.index(dt0)]  # and timemaster
                self._dtmaster = dmaster.num2date(dt0)
                self._udtmaster = num2date(dt0)

                # slen = len(runstrats[0])
                # Try to get something for those that didn&#39;t return
                for i, ret in enumerate(drets):
                    if ret:  # dts already contains a valid datetime for this i
                        continue

                    # try to get a data by checking with a master
                    d = datas[i]
                    d._check(forcedata=dmaster)  # check to force output
                    if d.next(datamaster=dmaster, ticks=False):  # retry
                        dts[i] = d.datetime[0]  # good -&gt; store
                        # self._plotfillers2[i].append(slen)  # mark as fill
                    else:
                        # self._plotfillers[i].append(slen)  # mark as empty
                        pass

                # make sure only those at dmaster level end up delivering
                for i, dti in enumerate(dts):
                    if dti is not None:
                        di = datas[i]
                        rpi = False and di.replaying   # to check behavior
                        if dti &gt; dt0:
                            if not rpi:  # must see all ticks ...
                                di.rewind()  # cannot deliver yet
                            # self._plotfillers[i].append(slen)
                        elif not di.replaying:
                            # Replay forces tick fill, else force here
                            di._tick_fill(force=True)

                        # self._plotfillers2[i].append(slen)  # mark as fill

            elif d0ret is None:
                # meant for things like live feeds which may not produce a bar
                # at the moment but need the loop to run for notifications and
                # getting resample and others to produce timely bars
                for data in datas:
                    data._check()
            else:
                lastret = data0._last()
                for data in datas1:
                    lastret += data._last(datamaster=data0)

                if not lastret:
                    # Only go extra round if something was changed by &#34;lasts&#34;
                    break

            # Datas may have generated a new notification after next
            self._datanotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # if any bar, check timers before broker
                self._check_timers(runstrats, dt0, cheat=True)
                if self.p.cheat_on_open:
                    for strat in runstrats:
                        strat._next_open()
                        if self._event_stop:  # stop if requested
                            return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            if d0ret or lastret:  # bars produced by data or filters
                self._check_timers(runstrats, dt0, cheat=False)
                for strat in runstrats:
                    strat._next()
                    if self._event_stop:  # stop if requested
                        return

                    self._next_writers(runstrats)

        # Last notification chance before stopping
        self._datanotify()
        if self._event_stop:  # stop if requested
            return
        self._storenotify()
        if self._event_stop:  # stop if requested
            return

    def _runonce(self, runstrats):
        &#39;&#39;&#39;
        Actual implementation of run in vector mode.

        Strategies are still invoked on a pseudo-event mode in which ``next``
        is called for each data arrival
        &#39;&#39;&#39;
        for strat in runstrats:
            strat._once()
            strat.reset()  # strat called next by next - reset lines

        # The default once for strategies does nothing and therefore
        # has not moved forward all datas/indicators/observers that
        # were homed before calling once, Hence no &#34;need&#34; to do it
        # here again, because pointers are at 0
        datas = sorted(self.datas,
                       key=lambda x: (x._timeframe, x._compression))

        while True:
            # Check next incoming date in the datas
            dts = [d.advance_peek() for d in datas]
            dt0 = min(dts)
            if dt0 == float(&#39;inf&#39;):
                break  # no data delivers anything

            # Timemaster if needed be
            # dmaster = datas[dts.index(dt0)]  # and timemaster
            slen = len(runstrats[0])
            for i, dti in enumerate(dts):
                if dti &lt;= dt0:
                    datas[i].advance()
                    # self._plotfillers2[i].append(slen)  # mark as fill
                else:
                    # self._plotfillers[i].append(slen)
                    pass

            self._check_timers(runstrats, dt0, cheat=True)

            if self.p.cheat_on_open:
                for strat in runstrats:
                    strat._oncepost_open()
                    if self._event_stop:  # stop if requested
                        return

            self._brokernotify()
            if self._event_stop:  # stop if requested
                return

            self._check_timers(runstrats, dt0, cheat=False)

            for strat in runstrats:
                strat._oncepost(dt0)
                if self._event_stop:  # stop if requested
                    return

                self._next_writers(runstrats)

    def _check_timers(self, runstrats, dt0, cheat=False):
        timers = self._timers if not cheat else self._timerscheat
        for t in timers:
            if not t.check(dt0):
                continue

            t.params.owner.notify_timer(t, t.lastwhen, *t.args, **t.kwargs)

            if t.params.strats:
                for strat in runstrats:
                    strat.notify_timer(t, t.lastwhen, *t.args, **t.kwargs)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.cerebro.Cerebro.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.cerebro.Cerebro.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.cerebro.Cerebro.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="backtrader.cerebro.Cerebro.iterize"><code class="name flex">
<span>def <span class="ident">iterize</span></span>(<span>iterable)</span>
</code></dt>
<dd>
<div class="desc"><p>Handy function which turns things into things that can be iterated upon
including iterables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def iterize(iterable):
    &#39;&#39;&#39;Handy function which turns things into things that can be iterated upon
    including iterables
    &#39;&#39;&#39;
    niterable = list()
    for elem in iterable:
        if isinstance(elem, string_types):
            elem = (elem,)
        elif not isinstance(elem, collectionsAbc.Iterable):  # Different functions will be called for different Python versions
            elem = (elem,)

        niterable.append(elem)

    return niterable</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="backtrader.cerebro.Cerebro.broker"><code class="name">var <span class="ident">broker</span></code></dt>
<dd>
<div class="desc"><p>Returns the broker instance.</p>
<p>This is also available as a <code>property</code> by the name <code>broker</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getbroker(self):
    &#39;&#39;&#39;
    Returns the broker instance.

    This is also available as a ``property`` by the name ``broker``
    &#39;&#39;&#39;
    return self._broker</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.cerebro.Cerebro.add_order_history"><code class="name flex">
<span>def <span class="ident">add_order_history</span></span>(<span>self, orders, notify=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a history of orders to be directly executed in the broker for
performance evaluation</p>
<ul>
<li>
<p><code>orders</code>: is an iterable (ex: list, tuple, iterator, generator)
in which each element will be also an iterable (with length) with
the following sub-elements (2 formats are possible)</p>
<p><code>[datetime, size, price]</code> or <code>[datetime, size, price, data]</code></p>
<p><strong>Note</strong>: it must be sorted (or produce sorted elements) by
datetime ascending</p>
<p>where:</p>
<ul>
<li><code>datetime</code> is a python <code>date/datetime</code> instance or a string
with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
brackets are optional</li>
<li><code>size</code> is an integer (positive to <em>buy</em>, negative to <em>sell</em>)</li>
<li><code>price</code> is a float/integer</li>
<li>
<p><code>data</code> if present can take any of the following values</p>
<ul>
<li><em>None</em> - The 1st data feed will be used as target</li>
<li><em>integer</em> - The data with that index (insertion order in
<strong>Cerebro</strong>) will be used</li>
<li><em>string</em> - a data with that name, assigned for example with
<code>cerebro.addata(data, name=value)</code>, will be the target</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>notify</code> (default: <em>True</em>)</p>
<p>If <code>True</code> the 1st strategy inserted in the system will be
notified of the artificial orders created following the information
from each order in <code>orders</code></p>
</li>
</ul>
<p><strong>Note</strong>: Implicit in the description is the need to add a data feed
which is the target of the orders. This is for example needed by
analyzers which track for example the returns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_order_history(self, orders, notify=True):
    &#39;&#39;&#39;
    Add a history of orders to be directly executed in the broker for
    performance evaluation

      - ``orders``: is an iterable (ex: list, tuple, iterator, generator)
        in which each element will be also an iterable (with length) with
        the following sub-elements (2 formats are possible)

        ``[datetime, size, price]`` or ``[datetime, size, price, data]``

        **Note**: it must be sorted (or produce sorted elements) by
          datetime ascending

        where:

          - ``datetime`` is a python ``date/datetime`` instance or a string
            with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
            brackets are optional
          - ``size`` is an integer (positive to *buy*, negative to *sell*)
          - ``price`` is a float/integer
          - ``data`` if present can take any of the following values

            - *None* - The 1st data feed will be used as target
            - *integer* - The data with that index (insertion order in
              **Cerebro**) will be used
            - *string* - a data with that name, assigned for example with
              ``cerebro.addata(data, name=value)``, will be the target

      - ``notify`` (default: *True*)

        If ``True`` the 1st strategy inserted in the system will be
        notified of the artificial orders created following the information
        from each order in ``orders``

    **Note**: Implicit in the description is the need to add a data feed
      which is the target of the orders. This is for example needed by
      analyzers which track for example the returns
    &#39;&#39;&#39;
    self._ohistory.append((orders, notify))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.add_signal"><code class="name flex">
<span>def <span class="ident">add_signal</span></span>(<span>self, sigtype, sigcls, *sigargs, **sigkwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a signal to the system which will be later added to a
<code>SignalStrategy</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal(self, sigtype, sigcls, *sigargs, **sigkwargs):
    &#39;&#39;&#39;Adds a signal to the system which will be later added to a
    ``SignalStrategy``&#39;&#39;&#39;
    self.signals.append((sigtype, sigcls, sigargs, sigkwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.add_timer"><code class="name flex">
<span>def <span class="ident">add_timer</span></span>(<span>self, when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, strats=False, cheat=False, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Schedules a timer to invoke <code>notify_timer</code></p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>
<p><code>when</code>: can be</p>
</li>
<li>
<p><code>datetime.time</code> instance (see below <code>tzdata</code>)</p>
</li>
<li><code>bt.timer.SESSION_START</code> to reference a session start</li>
<li>
<p><code>bt.timer.SESSION_END</code> to reference a session end</p>
</li>
<li>
<p><code>offset</code> which must be a <code>datetime.timedelta</code> instance</p>
</li>
</ul>
<p>Used to offset the value <code>when</code>. It has a meaningful use in
combination with <code>SESSION_START</code> and <code>SESSION_END</code>, to indicated
things like a timer being called <code>15 minutes</code> after the session
start.</p>
<ul>
<li>
<p><code>repeat</code> which must be a <code>datetime.timedelta</code> instance</p>
<p>Indicates if after a 1st call, further calls will be scheduled
within the same session at the scheduled <code>repeat</code> delta</p>
<p>Once the timer goes over the end of the session it is reset to the
original value for <code>when</code></p>
</li>
<li>
<p><code>weekdays</code>: a <strong>sorted</strong> iterable with integers indicating on
which days (iso codes, Monday is 1, Sunday is 7) the timers can
be actually invoked</p>
<p>If not specified, the timer will be active on all days</p>
</li>
<li>
<p><code>weekcarry</code> (default: <code>False</code>). If <code>True</code> and the weekday was
not seen (ex: trading holiday), the timer will be executed on the
next day (even if in a new week)</p>
</li>
<li>
<p><code>monthdays</code>: a <strong>sorted</strong> iterable with integers indicating on
which days of the month a timer has to be executed. For example
always on day <em>15</em> of the month</p>
<p>If not specified, the timer will be active on all days</p>
</li>
<li>
<p><code>monthcarry</code> (default: <code>True</code>). If the day was not seen
(weekend, trading holiday), the timer will be executed on the next
available day.</p>
</li>
<li>
<p><code>allow</code> (default: <code>None</code>). A callback which receives a
`datetime.date<code> instance and returns </code>True`` if the date is
allowed for timers or else returns <code>False</code></p>
</li>
<li>
<p><code>tzdata</code> which can be either <code>None</code> (default), a <code>pytz</code>
instance or a <code>data feed</code> instance.</p>
<p><code>None</code>: <code>when</code> is interpreted at face value (which translates
to handling it as if it where UTC even if it's not)</p>
<p><code>pytz</code> instance: <code>when</code> will be interpreted as being specified
in the local time specified by the timezone instance.</p>
<p><code>data feed</code> instance: <code>when</code> will be interpreted as being
specified in the local time specified by the <code>tz</code> parameter of
the data feed instance.</p>
<p><strong>Note</strong>: If <code>when</code> is either <code>SESSION_START</code> or
<code>SESSION_END</code> and <code>tzdata</code> is <code>None</code>, the 1st <em>data feed</em>
in the system (aka <code>self.data0</code>) will be used as the reference
to find out the session times.</p>
</li>
<li>
<p><code>strats</code> (default: <code>False</code>) call also the <code>notify_timer</code> of
strategies</p>
</li>
<li>
<p><code>cheat</code> (default <code>False</code>) if <code>True</code> the timer will be called
before the broker has a chance to evaluate the orders. This opens
the chance to issue orders based on opening price for example right
before the session starts</p>
</li>
<li>
<p><code>*args</code>: any extra args will be passed to <code>notify_timer</code></p>
</li>
<li>
<p><code>**kwargs</code>: any extra kwargs will be passed to <code>notify_timer</code></p>
</li>
</ul>
<p>Return Value:</p>
<ul>
<li>The created timer</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_timer(self, when,
              offset=datetime.timedelta(), repeat=datetime.timedelta(),
              weekdays=[], weekcarry=False,
              monthdays=[], monthcarry=True,
              allow=None,
              tzdata=None, strats=False, cheat=False,
              *args, **kwargs):
    &#39;&#39;&#39;
    Schedules a timer to invoke ``notify_timer``

    Arguments:

      - ``when``: can be

        - ``datetime.time`` instance (see below ``tzdata``)
        - ``bt.timer.SESSION_START`` to reference a session start
        - ``bt.timer.SESSION_END`` to reference a session end

     - ``offset`` which must be a ``datetime.timedelta`` instance

       Used to offset the value ``when``. It has a meaningful use in
       combination with ``SESSION_START`` and ``SESSION_END``, to indicated
       things like a timer being called ``15 minutes`` after the session
       start.

      - ``repeat`` which must be a ``datetime.timedelta`` instance

        Indicates if after a 1st call, further calls will be scheduled
        within the same session at the scheduled ``repeat`` delta

        Once the timer goes over the end of the session it is reset to the
        original value for ``when``

      - ``weekdays``: a **sorted** iterable with integers indicating on
        which days (iso codes, Monday is 1, Sunday is 7) the timers can
        be actually invoked

        If not specified, the timer will be active on all days

      - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
        not seen (ex: trading holiday), the timer will be executed on the
        next day (even if in a new week)

      - ``monthdays``: a **sorted** iterable with integers indicating on
        which days of the month a timer has to be executed. For example
        always on day *15* of the month

        If not specified, the timer will be active on all days

      - ``monthcarry`` (default: ``True``). If the day was not seen
        (weekend, trading holiday), the timer will be executed on the next
        available day.

      - ``allow`` (default: ``None``). A callback which receives a
        `datetime.date`` instance and returns ``True`` if the date is
        allowed for timers or else returns ``False``

      - ``tzdata`` which can be either ``None`` (default), a ``pytz``
        instance or a ``data feed`` instance.

        ``None``: ``when`` is interpreted at face value (which translates
        to handling it as if it where UTC even if it&#39;s not)

        ``pytz`` instance: ``when`` will be interpreted as being specified
        in the local time specified by the timezone instance.

        ``data feed`` instance: ``when`` will be interpreted as being
        specified in the local time specified by the ``tz`` parameter of
        the data feed instance.

        **Note**: If ``when`` is either ``SESSION_START`` or
          ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
          in the system (aka ``self.data0``) will be used as the reference
          to find out the session times.

      - ``strats`` (default: ``False``) call also the ``notify_timer`` of
        strategies

      - ``cheat`` (default ``False``) if ``True`` the timer will be called
        before the broker has a chance to evaluate the orders. This opens
        the chance to issue orders based on opening price for example right
        before the session starts
      - ``*args``: any extra args will be passed to ``notify_timer``

      - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

    Return Value:

      - The created timer

    &#39;&#39;&#39;
    return self._add_timer(
        owner=self, when=when, offset=offset, repeat=repeat,
        weekdays=weekdays, weekcarry=weekcarry,
        monthdays=monthdays, monthcarry=monthcarry,
        allow=allow,
        tzdata=tzdata, strats=strats, cheat=cheat,
        *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addanalyzer"><code class="name flex">
<span>def <span class="ident">addanalyzer</span></span>(<span>self, ancls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Analyzer</code> class to the mix. Instantiation will be done at
<code>run</code> time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addanalyzer(self, ancls, *args, **kwargs):
    &#39;&#39;&#39;
    Adds an ``Analyzer`` class to the mix. Instantiation will be done at
    ``run`` time
    &#39;&#39;&#39;
    self.analyzers.append((ancls, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addcalendar"><code class="name flex">
<span>def <span class="ident">addcalendar</span></span>(<span>self, cal)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a global trading calendar to the system. Individual data feeds
may have separate calendars which override the global one</p>
<p><code>cal</code> can be an instance of <code>TradingCalendar</code> a string or an
instance of <code>pandas_market_calendars</code>. A string will be will be
instantiated as a <code>PandasMarketCalendar</code> (which needs the module
<code>pandas_market_calendar</code> installed in the system.</p>
<p>If a subclass of <code>TradingCalendarBase</code> is passed (not an instance) it
will be instantiated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addcalendar(self, cal):
    &#39;&#39;&#39;Adds a global trading calendar to the system. Individual data feeds
    may have separate calendars which override the global one

    ``cal`` can be an instance of ``TradingCalendar`` a string or an
    instance of ``pandas_market_calendars``. A string will be will be
    instantiated as a ``PandasMarketCalendar`` (which needs the module
    ``pandas_market_calendar`` installed in the system.

    If a subclass of `TradingCalendarBase` is passed (not an instance) it
    will be instantiated
    &#39;&#39;&#39;
    if isinstance(cal, string_types):
        cal = PandasMarketCalendar(calendar=cal)
    elif hasattr(cal, &#39;valid_days&#39;):
        cal = PandasMarketCalendar(calendar=cal)

    else:
        try:
            if issubclass(cal, TradingCalendarBase):
                cal = cal()
        except TypeError:  # already an instance
            pass

    self._tradingcal = cal</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.adddata"><code class="name flex">
<span>def <span class="ident">adddata</span></span>(<span>self, data, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Data Feed</code> instance to the mix.</p>
<p>If <code>name</code> is not None it will be put into <code>data._name</code> which is
meant for decoration/plotting purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adddata(self, data, name=None):
    &#39;&#39;&#39;
    Adds a ``Data Feed`` instance to the mix.

    If ``name`` is not None it will be put into ``data._name`` which is
    meant for decoration/plotting purposes.
    &#39;&#39;&#39;
    if name is not None:
        data._name = name

    data._id = next(self._dataid)
    data.setenvironment(self)

    self.datas.append(data)
    self.datasbyname[data._name] = data
    feed = data.getfeed()
    if feed and feed not in self.feeds:
        self.feeds.append(feed)

    if data.islive():
        self._dolive = True

    return data</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.adddatacb"><code class="name flex">
<span>def <span class="ident">adddatacb</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a callback to get messages which would be handled by the
notify_data method</p>
<p>The signature of the callback must support the following:</p>
<ul>
<li>callback(data, status, *args, **kwargs)</li>
</ul>
<p>The actual <code>*args</code> and <code>**kwargs</code> received are implementation
defined (depend entirely on the <em>data/broker/store</em>) but in general one
should expect them to be <em>printable</em> to allow for reception and
experimentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adddatacb(self, callback):
    &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
    notify_data method

    The signature of the callback must support the following:

      - callback(data, status, \*args, \*\*kwargs)

    The actual ``*args`` and ``**kwargs`` received are implementation
    defined (depend entirely on the *data/broker/store*) but in general one
    should expect them to be *printable* to allow for reception and
    experimentation.
    &#39;&#39;&#39;
    self.datacbs.append(callback)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addindicator"><code class="name flex">
<span>def <span class="ident">addindicator</span></span>(<span>self, indcls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Indicator</code> class to the mix. Instantiation will be done at
<code>run</code> time in the passed strategies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addindicator(self, indcls, *args, **kwargs):
    &#39;&#39;&#39;
    Adds an ``Indicator`` class to the mix. Instantiation will be done at
    ``run`` time in the passed strategies
    &#39;&#39;&#39;
    self.indicators.append((indcls, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addobserver"><code class="name flex">
<span>def <span class="ident">addobserver</span></span>(<span>self, obscls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Observer</code> class to the mix. Instantiation will be done at
<code>run</code> time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addobserver(self, obscls, *args, **kwargs):
    &#39;&#39;&#39;
    Adds an ``Observer`` class to the mix. Instantiation will be done at
    ``run`` time
    &#39;&#39;&#39;
    self.observers.append((False, obscls, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addobservermulti"><code class="name flex">
<span>def <span class="ident">addobservermulti</span></span>(<span>self, obscls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Observer</code> class to the mix. Instantiation will be done at
<code>run</code> time</p>
<p>It will be added once per "data" in the system. A use case is a
buy/sell observer which observes individual datas.</p>
<p>A counter-example is the CashValue, which observes system-wide values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addobservermulti(self, obscls, *args, **kwargs):
    &#39;&#39;&#39;
    Adds an ``Observer`` class to the mix. Instantiation will be done at
    ``run`` time

    It will be added once per &#34;data&#34; in the system. A use case is a
    buy/sell observer which observes individual datas.

    A counter-example is the CashValue, which observes system-wide values
    &#39;&#39;&#39;
    self.observers.append((True, obscls, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addsizer"><code class="name flex">
<span>def <span class="ident">addsizer</span></span>(<span>self, sizercls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Sizer</code> class (and args) which is the default sizer for any
strategy added to cerebro</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addsizer(self, sizercls, *args, **kwargs):
    &#39;&#39;&#39;Adds a ``Sizer`` class (and args) which is the default sizer for any
    strategy added to cerebro
    &#39;&#39;&#39;
    self.sizers[None] = (sizercls, args, kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addsizer_byidx"><code class="name flex">
<span>def <span class="ident">addsizer_byidx</span></span>(<span>self, idx, sizercls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Sizer</code> class by idx. This idx is a reference compatible to
the one returned by <code>addstrategy</code>. Only the strategy referenced by
<code>idx</code> will receive this size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addsizer_byidx(self, idx, sizercls, *args, **kwargs):
    &#39;&#39;&#39;Adds a ``Sizer`` class by idx. This idx is a reference compatible to
    the one returned by ``addstrategy``. Only the strategy referenced by
    ``idx`` will receive this size
    &#39;&#39;&#39;
    self.sizers[idx] = (sizercls, args, kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addstore"><code class="name flex">
<span>def <span class="ident">addstore</span></span>(<span>self, store)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Store</code> instance to the if not already present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addstore(self, store):
    &#39;&#39;&#39;Adds an ``Store`` instance to the if not already present&#39;&#39;&#39;
    if store not in self.stores:
        self.stores.append(store)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addstorecb"><code class="name flex">
<span>def <span class="ident">addstorecb</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a callback to get messages which would be handled by the
notify_store method</p>
<p>The signature of the callback must support the following:</p>
<ul>
<li>callback(msg, *args, **kwargs)</li>
</ul>
<p>The actual <code>msg</code>, <code>*args</code> and <code>**kwargs</code> received are
implementation defined (depend entirely on the <em>data/broker/store</em>) but
in general one should expect them to be <em>printable</em> to allow for
reception and experimentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addstorecb(self, callback):
    &#39;&#39;&#39;Adds a callback to get messages which would be handled by the
    notify_store method

    The signature of the callback must support the following:

      - callback(msg, \*args, \*\*kwargs)

    The actual ``msg``, ``*args`` and ``**kwargs`` received are
    implementation defined (depend entirely on the *data/broker/store*) but
    in general one should expect them to be *printable* to allow for
    reception and experimentation.
    &#39;&#39;&#39;
    self.storecbs.append(callback)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addstrategy"><code class="name flex">
<span>def <span class="ident">addstrategy</span></span>(<span>self, strategy, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Strategy</code> class to the mix for a single pass run.
Instantiation will happen during <code>run</code> time.</p>
<p>args and kwargs will be passed to the strategy as they are during
instantiation.</p>
<p>Returns the index with which addition of other objects (like sizers)
can be referenced</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addstrategy(self, strategy, *args, **kwargs):
    &#39;&#39;&#39;
    Adds a ``Strategy`` class to the mix for a single pass run.
    Instantiation will happen during ``run`` time.

    args and kwargs will be passed to the strategy as they are during
    instantiation.

    Returns the index with which addition of other objects (like sizers)
    can be referenced
    &#39;&#39;&#39;
    self.strats.append([(strategy, args, kwargs)])
    return len(self.strats) - 1</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addtz"><code class="name flex">
<span>def <span class="ident">addtz</span></span>(<span>self, tz)</span>
</code></dt>
<dd>
<div class="desc"><p>This can also be done with the parameter <code>tz</code></p>
<p>Adds a global timezone for strategies. The argument <code>tz</code> can be</p>
<ul>
<li>
<p><code>None</code>: in this case the datetime displayed by strategies will be
in UTC, which has been always the standard behavior</p>
</li>
<li>
<p><code>pytz</code> instance. It will be used as such to convert UTC times to
the chosen timezone</p>
</li>
<li>
<p><code>string</code>. Instantiating a <code>pytz</code> instance will be attempted.</p>
</li>
<li>
<p><code>integer</code>. Use, for the strategy, the same timezone as the
corresponding <code>data</code> in the <code>self.datas</code> iterable (<code>0</code> would
use the timezone from <code>data0</code>)</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addtz(self, tz):
    &#39;&#39;&#39;
    This can also be done with the parameter ``tz``

    Adds a global timezone for strategies. The argument ``tz`` can be

      - ``None``: in this case the datetime displayed by strategies will be
        in UTC, which has been always the standard behavior

      - ``pytz`` instance. It will be used as such to convert UTC times to
        the chosen timezone

      - ``string``. Instantiating a ``pytz`` instance will be attempted.

      - ``integer``. Use, for the strategy, the same timezone as the
        corresponding ``data`` in the ``self.datas`` iterable (``0`` would
        use the timezone from ``data0``)

    &#39;&#39;&#39;
    self.p.tz = tz</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.addwriter"><code class="name flex">
<span>def <span class="ident">addwriter</span></span>(<span>self, wrtcls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds an <code>Writer</code> class to the mix. Instantiation will be done at
<code>run</code> time in cerebro</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addwriter(self, wrtcls, *args, **kwargs):
    &#39;&#39;&#39;Adds an ``Writer`` class to the mix. Instantiation will be done at
    ``run`` time in cerebro
    &#39;&#39;&#39;
    self.writers.append((wrtcls, args, kwargs))</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.chaindata"><code class="name flex">
<span>def <span class="ident">chaindata</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Chains several data feeds into one</p>
<p>If <code>name</code> is passed as named argument and is not None it will be put
into <code>data._name</code> which is meant for decoration/plotting purposes.</p>
<p>If <code>None</code>, then the name of the 1st data will be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chaindata(self, *args, **kwargs):
    &#39;&#39;&#39;
    Chains several data feeds into one

    If ``name`` is passed as named argument and is not None it will be put
    into ``data._name`` which is meant for decoration/plotting purposes.

    If ``None``, then the name of the 1st data will be used
    &#39;&#39;&#39;
    dname = kwargs.pop(&#39;name&#39;, None)
    if dname is None:
        dname = args[0]._dataname
    d = bt.feeds.Chainer(dataname=dname, *args)
    self.adddata(d, name=dname)

    return d</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.getbroker"><code class="name flex">
<span>def <span class="ident">getbroker</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the broker instance.</p>
<p>This is also available as a <code>property</code> by the name <code>broker</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getbroker(self):
    &#39;&#39;&#39;
    Returns the broker instance.

    This is also available as a ``property`` by the name ``broker``
    &#39;&#39;&#39;
    return self._broker</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.notify_data"><code class="name flex">
<span>def <span class="ident">notify_data</span></span>(<span>self, data, status, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive data notifications in cerebro</p>
<p>This method can be overridden in <code><a title="backtrader.cerebro.Cerebro" href="#backtrader.cerebro.Cerebro">Cerebro</a></code> subclasses</p>
<p>The actual <code>*args</code> and <code>**kwargs</code> received are
implementation defined (depend entirely on the <em>data/broker/store</em>) but
in general one should expect them to be <em>printable</em> to allow for
reception and experimentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_data(self, data, status, *args, **kwargs):
    &#39;&#39;&#39;Receive data notifications in cerebro

    This method can be overridden in ``Cerebro`` subclasses

    The actual ``*args`` and ``**kwargs`` received are
    implementation defined (depend entirely on the *data/broker/store*) but
    in general one should expect them to be *printable* to allow for
    reception and experimentation.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.notify_store"><code class="name flex">
<span>def <span class="ident">notify_store</span></span>(<span>self, msg, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive store notifications in cerebro</p>
<p>This method can be overridden in <code><a title="backtrader.cerebro.Cerebro" href="#backtrader.cerebro.Cerebro">Cerebro</a></code> subclasses</p>
<p>The actual <code>msg</code>, <code>*args</code> and <code>**kwargs</code> received are
implementation defined (depend entirely on the <em>data/broker/store</em>) but
in general one should expect them to be <em>printable</em> to allow for
reception and experimentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_store(self, msg, *args, **kwargs):
    &#39;&#39;&#39;Receive store notifications in cerebro

    This method can be overridden in ``Cerebro`` subclasses

    The actual ``msg``, ``*args`` and ``**kwargs`` received are
    implementation defined (depend entirely on the *data/broker/store*) but
    in general one should expect them to be *printable* to allow for
    reception and experimentation.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.notify_timer"><code class="name flex">
<span>def <span class="ident">notify_timer</span></span>(<span>self, timer, when, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a timer notification where <code>timer</code> is the timer which was
returned by <code>add_timer</code>, and <code>when</code> is the calling time. <code>args</code>
and <code>kwargs</code> are any additional arguments passed to <code>add_timer</code></p>
<p>The actual <code>when</code> time can be later, but the system may have not be
able to call the timer before. This value is the timer value and no the
system time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_timer(self, timer, when, *args, **kwargs):
    &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
    returned by ``add_timer``, and ``when`` is the calling time. ``args``
    and ``kwargs`` are any additional arguments passed to ``add_timer``

    The actual ``when`` time can be later, but the system may have not be
    able to call the timer before. This value is the timer value and no the
    system time.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.optcallback"><code class="name flex">
<span>def <span class="ident">optcallback</span></span>(<span>self, cb)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <em>callback</em> to the list of callbacks that will be called with the
optimizations when each of the strategies has been run</p>
<p>The signature: cb(strategy)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optcallback(self, cb):
    &#39;&#39;&#39;
    Adds a *callback* to the list of callbacks that will be called with the
    optimizations when each of the strategies has been run

    The signature: cb(strategy)
    &#39;&#39;&#39;
    self.optcbs.append(cb)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.optstrategy"><code class="name flex">
<span>def <span class="ident">optstrategy</span></span>(<span>self, strategy, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Strategy</code> class to the mix for optimization. Instantiation
will happen during <code>run</code> time.</p>
<p>args and kwargs MUST BE iterables which hold the values to check.</p>
<p>Example: if a Strategy accepts a parameter <code>period</code>, for optimization
purposes the call to <code>optstrategy</code> looks like:</p>
<ul>
<li>cerebro.optstrategy(MyStrategy, period=(15, 25))</li>
</ul>
<p>This will execute an optimization for values 15 and 25. Whereas</p>
<ul>
<li>cerebro.optstrategy(MyStrategy, period=range(15, 25))</li>
</ul>
<p>will execute MyStrategy with <code>period</code> values 15 -&gt; 25 (25 not
included, because ranges are semi-open in Python)</p>
<p>If a parameter is passed but shall not be optimized the call looks
like:</p>
<ul>
<li>cerebro.optstrategy(MyStrategy, period=(15,))</li>
</ul>
<p>Notice that <code>period</code> is still passed as an iterable &hellip; of just 1
element</p>
<p><code><a title="backtrader" href="index.html">backtrader</a></code> will anyhow try to identify situations like:</p>
<ul>
<li>cerebro.optstrategy(MyStrategy, period=15)</li>
</ul>
<p>and will create an internal pseudo-iterable if possible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optstrategy(self, strategy, *args, **kwargs):
    &#39;&#39;&#39;
    Adds a ``Strategy`` class to the mix for optimization. Instantiation
    will happen during ``run`` time.

    args and kwargs MUST BE iterables which hold the values to check.

    Example: if a Strategy accepts a parameter ``period``, for optimization
    purposes the call to ``optstrategy`` looks like:

      - cerebro.optstrategy(MyStrategy, period=(15, 25))

    This will execute an optimization for values 15 and 25. Whereas

      - cerebro.optstrategy(MyStrategy, period=range(15, 25))

    will execute MyStrategy with ``period`` values 15 -&gt; 25 (25 not
    included, because ranges are semi-open in Python)

    If a parameter is passed but shall not be optimized the call looks
    like:

      - cerebro.optstrategy(MyStrategy, period=(15,))

    Notice that ``period`` is still passed as an iterable ... of just 1
    element

    ``backtrader`` will anyhow try to identify situations like:

      - cerebro.optstrategy(MyStrategy, period=15)

    and will create an internal pseudo-iterable if possible
    &#39;&#39;&#39;
    self._dooptimize = True
    args = self.iterize(args)
    optargs = itertools.product(*args)

    optkeys = list(kwargs)

    vals = self.iterize(kwargs.values())
    optvals = itertools.product(*vals)

    okwargs1 = map(zip, itertools.repeat(optkeys), optvals)

    optkwargs = map(dict, okwargs1)

    it = itertools.product([strategy], optargs, optkwargs)
    self.strats.append(it)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, plotter=None, numfigs=1, iplot=True, start=None, end=None, width=16, height=9, dpi=300, tight=True, use=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the strategies inside cerebro</p>
<p>If <code>plotter</code> is None a default <code>Plot</code> instance is created and
<code>kwargs</code> are passed to it during instantiation.</p>
<p><code>numfigs</code> split the plot in the indicated number of charts reducing
chart density if wished</p>
<p><code>iplot</code>: if <code>True</code> and running in a <code>notebook</code> the charts will be
displayed inline</p>
<p><code>use</code>: set it to the name of the desired matplotlib backend. It will
take precedence over <code>iplot</code></p>
<p><code>start</code>: An index to the datetime line array of the strategy or a
<code>datetime.date</code>, <code>datetime.datetime</code> instance indicating the start
of the plot</p>
<p><code>end</code>: An index to the datetime line array of the strategy or a
<code>datetime.date</code>, <code>datetime.datetime</code> instance indicating the end
of the plot</p>
<p><code>width</code>: in inches of the saved figure</p>
<p><code>height</code>: in inches of the saved figure</p>
<p><code>dpi</code>: quality in dots per inches of the saved figure</p>
<p><code>tight</code>: only save actual content and not the frame of the figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, plotter=None, numfigs=1, iplot=True, start=None, end=None,
         width=16, height=9, dpi=300, tight=True, use=None,
         **kwargs):
    &#39;&#39;&#39;
    Plots the strategies inside cerebro

    If ``plotter`` is None a default ``Plot`` instance is created and
    ``kwargs`` are passed to it during instantiation.

    ``numfigs`` split the plot in the indicated number of charts reducing
    chart density if wished

    ``iplot``: if ``True`` and running in a ``notebook`` the charts will be
    displayed inline

    ``use``: set it to the name of the desired matplotlib backend. It will
    take precedence over ``iplot``

    ``start``: An index to the datetime line array of the strategy or a
    ``datetime.date``, ``datetime.datetime`` instance indicating the start
    of the plot

    ``end``: An index to the datetime line array of the strategy or a
    ``datetime.date``, ``datetime.datetime`` instance indicating the end
    of the plot

    ``width``: in inches of the saved figure

    ``height``: in inches of the saved figure

    ``dpi``: quality in dots per inches of the saved figure

    ``tight``: only save actual content and not the frame of the figure
    &#39;&#39;&#39;
    if self._exactbars &gt; 0:
        return

    if not plotter:
        from . import plot
        if self.p.oldsync:
            plotter = plot.Plot_OldSync(**kwargs)
        else:
            plotter = plot.Plot(**kwargs)

    # pfillers = {self.datas[i]: self._plotfillers[i]
    # for i, x in enumerate(self._plotfillers)}

    # pfillers2 = {self.datas[i]: self._plotfillers2[i]
    # for i, x in enumerate(self._plotfillers2)}

    figs = []
    for stratlist in self.runstrats:
        for si, strat in enumerate(stratlist):
            rfig = plotter.plot(strat, figid=si * 100,
                                numfigs=numfigs, iplot=iplot,
                                start=start, end=end, use=use)
            # pfillers=pfillers2)

            figs.append(rfig)

        plotter.show()

    return figs</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.replaydata"><code class="name flex">
<span>def <span class="ident">replaydata</span></span>(<span>self, dataname, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Data Feed</code> to be replayed by the system</p>
<p>If <code>name</code> is not None it will be put into <code>data._name</code> which is
meant for decoration/plotting purposes.</p>
<p>Any other kwargs like <code>timeframe</code>, <code>compression</code>, <code>todate</code> which
are supported by the replay filter will be passed transparently</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replaydata(self, dataname, name=None, **kwargs):
    &#39;&#39;&#39;
    Adds a ``Data Feed`` to be replayed by the system

    If ``name`` is not None it will be put into ``data._name`` which is
    meant for decoration/plotting purposes.

    Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
    are supported by the replay filter will be passed transparently
    &#39;&#39;&#39;
    if any(dataname is x for x in self.datas):
        dataname = dataname.clone()

    dataname.replay(**kwargs)
    self.adddata(dataname, name=name)
    self._doreplay = True

    return dataname</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.resampledata"><code class="name flex">
<span>def <span class="ident">resampledata</span></span>(<span>self, dataname, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a <code>Data Feed</code> to be resample by the system</p>
<p>If <code>name</code> is not None it will be put into <code>data._name</code> which is
meant for decoration/plotting purposes.</p>
<p>Any other kwargs like <code>timeframe</code>, <code>compression</code>, <code>todate</code> which
are supported by the resample filter will be passed transparently</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resampledata(self, dataname, name=None, **kwargs):
    &#39;&#39;&#39;
    Adds a ``Data Feed`` to be resample by the system

    If ``name`` is not None it will be put into ``data._name`` which is
    meant for decoration/plotting purposes.

    Any other kwargs like ``timeframe``, ``compression``, ``todate`` which
    are supported by the resample filter will be passed transparently
    &#39;&#39;&#39;
    if any(dataname is x for x in self.datas):
        dataname = dataname.clone()

    dataname.resample(**kwargs)
    self.adddata(dataname, name=name)
    self._doreplay = True

    return dataname</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.rolloverdata"><code class="name flex">
<span>def <span class="ident">rolloverdata</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Chains several data feeds into one</p>
<p>If <code>name</code> is passed as named argument and is not None it will be put
into <code>data._name</code> which is meant for decoration/plotting purposes.</p>
<p>If <code>None</code>, then the name of the 1st data will be used</p>
<p>Any other kwargs will be passed to the RollOver class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rolloverdata(self, *args, **kwargs):
    &#39;&#39;&#39;Chains several data feeds into one

    If ``name`` is passed as named argument and is not None it will be put
    into ``data._name`` which is meant for decoration/plotting purposes.

    If ``None``, then the name of the 1st data will be used

    Any other kwargs will be passed to the RollOver class

    &#39;&#39;&#39;
    dname = kwargs.pop(&#39;name&#39;, None)
    if dname is None:
        dname = args[0]._dataname
    d = bt.feeds.RollOver(dataname=dname, *args, **kwargs)
    self.adddata(d, name=dname)

    return d</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The core method to perform backtesting. Any <code>kwargs</code> passed to it
will affect the value of the standard parameters <code><a title="backtrader.cerebro.Cerebro" href="#backtrader.cerebro.Cerebro">Cerebro</a></code> was
instantiated with.</p>
<p>If <code>cerebro</code> has not datas the method will immediately bail out.</p>
<p>It has different return values:</p>
<ul>
<li>
<p>For No Optimization: a list contanining instances of the Strategy
classes added with <code>addstrategy</code></p>
</li>
<li>
<p>For Optimization: a list of lists which contain instances of the
Strategy classes added with <code>addstrategy</code></p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, **kwargs):
    &#39;&#39;&#39;The core method to perform backtesting. Any ``kwargs`` passed to it
    will affect the value of the standard parameters ``Cerebro`` was
    instantiated with.

    If ``cerebro`` has not datas the method will immediately bail out.

    It has different return values:

      - For No Optimization: a list contanining instances of the Strategy
        classes added with ``addstrategy``

      - For Optimization: a list of lists which contain instances of the
        Strategy classes added with ``addstrategy``
    &#39;&#39;&#39;
    self._event_stop = False  # Stop is requested

    if not self.datas:
        return []  # nothing can be run

    pkeys = self.params._getkeys()
    for key, val in kwargs.items():
        if key in pkeys:
            setattr(self.params, key, val)

    # Manage activate/deactivate object cache
    linebuffer.LineActions.cleancache()  # clean cache
    indicator.Indicator.cleancache()  # clean cache

    linebuffer.LineActions.usecache(self.p.objcache)
    indicator.Indicator.usecache(self.p.objcache)

    self._dorunonce = self.p.runonce
    self._dopreload = self.p.preload
    self._exactbars = int(self.p.exactbars)

    if self._exactbars:
        self._dorunonce = False  # something is saving memory, no runonce
        self._dopreload = self._dopreload and self._exactbars &lt; 1

    self._doreplay = self._doreplay or any(x.replaying for x in self.datas)
    if self._doreplay:
        # preloading is not supported with replay. full timeframe bars
        # are constructed in realtime
        self._dopreload = False

    if self._dolive or self.p.live:
        # in this case both preload and runonce must be off
        self._dorunonce = False
        self._dopreload = False

    self.runwriters = list()

    # Add the system default writer if requested
    if self.p.writer is True:
        wr = WriterFile()
        self.runwriters.append(wr)

    # Instantiate any other writers
    for wrcls, wrargs, wrkwargs in self.writers:
        wr = wrcls(*wrargs, **wrkwargs)
        self.runwriters.append(wr)

    # Write down if any writer wants the full csv output
    self.writers_csv = any(map(lambda x: x.p.csv, self.runwriters))

    self.runstrats = list()

    if self.signals:  # allow processing of signals
        signalst, sargs, skwargs = self._signal_strat
        if signalst is None:
            # Try to see if the 1st regular strategy is a signal strategy
            try:
                signalst, sargs, skwargs = self.strats.pop(0)
            except IndexError:
                pass  # Nothing there
            else:
                if not isinstance(signalst, SignalStrategy):
                    # no signal ... reinsert at the beginning
                    self.strats.insert(0, (signalst, sargs, skwargs))
                    signalst = None  # flag as not presetn

        if signalst is None:  # recheck
            # Still None, create a default one
            signalst, sargs, skwargs = SignalStrategy, tuple(), dict()

        # Add the signal strategy
        self.addstrategy(signalst,
                         _accumulate=self._signal_accumulate,
                         _concurrent=self._signal_concurrent,
                         signals=self.signals,
                         *sargs,
                         **skwargs)

    if not self.strats:  # Datas are present, add a strategy
        self.addstrategy(Strategy)

    iterstrats = itertools.product(*self.strats)
    if not self._dooptimize or self.p.maxcpus == 1:
        # If no optimmization is wished ... or 1 core is to be used
        # let&#39;s skip process &#34;spawning&#34;
        for iterstrat in iterstrats:
            runstrat = self.runstrategies(iterstrat)
            self.runstrats.append(runstrat)
            if self._dooptimize:
                for cb in self.optcbs:
                    cb(runstrat)  # callback receives finished strategy
    else:
        if self.p.optdatas and self._dopreload and self._dorunonce:
            for data in self.datas:
                data.reset()
                if self._exactbars &lt; 1:  # datas can be full length
                    data.extend(size=self.params.lookahead)
                data._start()
                if self._dopreload:
                    data.preload()

        pool = multiprocessing.Pool(self.p.maxcpus or None)
        for r in pool.imap(self, iterstrats):
            self.runstrats.append(r)
            for cb in self.optcbs:
                cb(r)  # callback receives finished strategy

        pool.close()

        if self.p.optdatas and self._dopreload and self._dorunonce:
            for data in self.datas:
                data.stop()

    if not self._dooptimize:
        # avoid a list of list for regular cases
        return self.runstrats[0]

    return self.runstrats</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.runstop"><code class="name flex">
<span>def <span class="ident">runstop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If invoked from inside a strategy or anywhere else, including other
threads the execution will stop as soon as possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runstop(self):
    &#39;&#39;&#39;If invoked from inside a strategy or anywhere else, including other
    threads the execution will stop as soon as possible.&#39;&#39;&#39;
    self._event_stop = True  # signal a stop has been requested</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.runstrategies"><code class="name flex">
<span>def <span class="ident">runstrategies</span></span>(<span>self, iterstrat, predata=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal method invoked by ``run``` to run a set of strategies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runstrategies(self, iterstrat, predata=False):
    &#39;&#39;&#39;
    Internal method invoked by ``run``` to run a set of strategies
    &#39;&#39;&#39;
    self._init_stcount()

    self.runningstrats = runstrats = list()
    for store in self.stores:
        store.start()

    if self.p.cheat_on_open and self.p.broker_coo:
        # try to activate in broker
        if hasattr(self._broker, &#39;set_coo&#39;):
            self._broker.set_coo(True)

    if self._fhistory is not None:
        self._broker.set_fund_history(self._fhistory)

    for orders, onotify in self._ohistory:
        self._broker.add_order_history(orders, onotify)

    self._broker.start()

    for feed in self.feeds:
        feed.start()

    if self.writers_csv:
        wheaders = list()
        for data in self.datas:
            if data.csv:
                wheaders.extend(data.getwriterheaders())

        for writer in self.runwriters:
            if writer.p.csv:
                writer.addheaders(wheaders)

    # self._plotfillers = [list() for d in self.datas]
    # self._plotfillers2 = [list() for d in self.datas]

    if not predata:
        for data in self.datas:
            data.reset()
            if self._exactbars &lt; 1:  # datas can be full length
                data.extend(size=self.params.lookahead)
            data._start()
            if self._dopreload:
                data.preload()

    for stratcls, sargs, skwargs in iterstrat:
        sargs = self.datas + list(sargs)
        try:
            strat = stratcls(*sargs, **skwargs)
        except bt.errors.StrategySkipError:
            continue  # do not add strategy to the mix

        if self.p.oldsync:
            strat._oldsync = True  # tell strategy to use old clock update
        if self.p.tradehistory:
            strat.set_tradehistory()
        runstrats.append(strat)

    tz = self.p.tz
    if isinstance(tz, integer_types):
        tz = self.datas[tz]._tz
    else:
        tz = tzparse(tz)

    if runstrats:
        # loop separated for clarity
        defaultsizer = self.sizers.get(None, (None, None, None))
        for idx, strat in enumerate(runstrats):
            if self.p.stdstats:
                strat._addobserver(False, observers.Broker)
                if self.p.oldbuysell:
                    strat._addobserver(True, observers.BuySell)
                else:
                    strat._addobserver(True, observers.BuySell,
                                       barplot=True)

                if self.p.oldtrades or len(self.datas) == 1:
                    strat._addobserver(False, observers.Trades)
                else:
                    strat._addobserver(False, observers.DataTrades)

            for multi, obscls, obsargs, obskwargs in self.observers:
                strat._addobserver(multi, obscls, *obsargs, **obskwargs)

            for indcls, indargs, indkwargs in self.indicators:
                strat._addindicator(indcls, *indargs, **indkwargs)

            for ancls, anargs, ankwargs in self.analyzers:
                strat._addanalyzer(ancls, *anargs, **ankwargs)

            sizer, sargs, skwargs = self.sizers.get(idx, defaultsizer)
            if sizer is not None:
                strat._addsizer(sizer, *sargs, **skwargs)

            strat._settz(tz)
            strat._start()

            for writer in self.runwriters:
                if writer.p.csv:
                    writer.addheaders(strat.getwriterheaders())

        if not predata:
            for strat in runstrats:
                strat.qbuffer(self._exactbars, replaying=self._doreplay)

        for writer in self.runwriters:
            writer.start()

        # Prepare timers
        self._timers = []
        self._timerscheat = []
        for timer in self._pretimers:
            # preprocess tzdata if needed
            timer.start(self.datas[0])

            if timer.params.cheat:
                self._timerscheat.append(timer)
            else:
                self._timers.append(timer)

        if self._dopreload and self._dorunonce:
            if self.p.oldsync:
                self._runonce_old(runstrats)
            else:
                self._runonce(runstrats)
        else:
            if self.p.oldsync:
                self._runnext_old(runstrats)
            else:
                self._runnext(runstrats)

        for strat in runstrats:
            strat._stop()

    self._broker.stop()

    if not predata:
        for data in self.datas:
            data.stop()

    for feed in self.feeds:
        feed.stop()

    for store in self.stores:
        store.stop()

    self.stop_writers(runstrats)

    if self._dooptimize and self.p.optreturn:
        # Results can be optimized
        results = list()
        for strat in runstrats:
            for a in strat.analyzers:
                a.strategy = None
                a._parent = None
                for attrname in dir(a):
                    if attrname.startswith(&#39;data&#39;):
                        setattr(a, attrname, None)

            oreturn = OptReturn(strat.params, analyzers=strat.analyzers, strategycls=type(strat))
            results.append(oreturn)

        return results

    return runstrats</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.set_fund_history"><code class="name flex">
<span>def <span class="ident">set_fund_history</span></span>(<span>self, fund)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a history of orders to be directly executed in the broker for
performance evaluation</p>
<ul>
<li>
<p><code>fund</code>: is an iterable (ex: list, tuple, iterator, generator)
in which each element will be also an iterable (with length) with
the following sub-elements (2 formats are possible)</p>
<p><code>[datetime, share_value, net asset value]</code></p>
<p><strong>Note</strong>: it must be sorted (or produce sorted elements) by
datetime ascending</p>
<p>where:</p>
<ul>
<li><code>datetime</code> is a python <code>date/datetime</code> instance or a string
with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
brackets are optional</li>
<li><code>share_value</code> is an float/integer</li>
<li><code>net_asset_value</code> is a float/integer</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fund_history(self, fund):
    &#39;&#39;&#39;
    Add a history of orders to be directly executed in the broker for
    performance evaluation

      - ``fund``: is an iterable (ex: list, tuple, iterator, generator)
        in which each element will be also an iterable (with length) with
        the following sub-elements (2 formats are possible)

        ``[datetime, share_value, net asset value]``

        **Note**: it must be sorted (or produce sorted elements) by
          datetime ascending

        where:

          - ``datetime`` is a python ``date/datetime`` instance or a string
            with format YYYY-MM-DD[THH:MM:SS[.us]] where the elements in
            brackets are optional
          - ``share_value`` is an float/integer
          - ``net_asset_value`` is a float/integer
    &#39;&#39;&#39;
    self._fhistory = fund</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.setbroker"><code class="name flex">
<span>def <span class="ident">setbroker</span></span>(<span>self, broker)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a specific <code>broker</code> instance for this strategy, replacing the
one inherited from cerebro.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setbroker(self, broker):
    &#39;&#39;&#39;
    Sets a specific ``broker`` instance for this strategy, replacing the
    one inherited from cerebro.
    &#39;&#39;&#39;
    self._broker = broker
    broker.cerebro = self
    return broker</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.signal_accumulate"><code class="name flex">
<span>def <span class="ident">signal_accumulate</span></span>(<span>self, onoff)</span>
</code></dt>
<dd>
<div class="desc"><p>If signals are added to the system and the <code>accumulate</code> value is
set to True, entering the market when already in the market, will be
allowed to increase a position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_accumulate(self, onoff):
    &#39;&#39;&#39;If signals are added to the system and the ``accumulate`` value is
    set to True, entering the market when already in the market, will be
    allowed to increase a position&#39;&#39;&#39;
    self._signal_accumulate = onoff</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.signal_concurrent"><code class="name flex">
<span>def <span class="ident">signal_concurrent</span></span>(<span>self, onoff)</span>
</code></dt>
<dd>
<div class="desc"><p>If signals are added to the system and the <code>concurrent</code> value is
set to True, concurrent orders will be allowed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_concurrent(self, onoff):
    &#39;&#39;&#39;If signals are added to the system and the ``concurrent`` value is
    set to True, concurrent orders will be allowed&#39;&#39;&#39;
    self._signal_concurrent = onoff</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.signal_strategy"><code class="name flex">
<span>def <span class="ident">signal_strategy</span></span>(<span>self, stratcls, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a SignalStrategy subclass which can accept signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_strategy(self, stratcls, *args, **kwargs):
    &#39;&#39;&#39;Adds a SignalStrategy subclass which can accept signals&#39;&#39;&#39;
    self._signal_strat = (stratcls, args, kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.cerebro.Cerebro.stop_writers"><code class="name flex">
<span>def <span class="ident">stop_writers</span></span>(<span>self, runstrats)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_writers(self, runstrats):
    cerebroinfo = OrderedDict()
    datainfos = OrderedDict()

    for i, data in enumerate(self.datas):
        datainfos[&#39;Data%d&#39; % i] = data.getwriterinfo()

    cerebroinfo[&#39;Datas&#39;] = datainfos

    stratinfos = dict()
    for strat in runstrats:
        stname = strat.__class__.__name__
        stratinfos[stname] = strat.getwriterinfo()

    cerebroinfo[&#39;Strategies&#39;] = stratinfos

    for writer in self.runwriters:
        writer.writedict(dict(Cerebro=cerebroinfo))
        writer.stop()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.cerebro.OptReturn"><code class="flex name class">
<span>class <span class="ident">OptReturn</span></span>
<span>(</span><span>params, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptReturn(object):
    def __init__(self, params, **kwargs):
        self.p = self.params = params
        for k, v in kwargs.items():
            setattr(self, k, v)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.cerebro.Cerebro" href="#backtrader.cerebro.Cerebro">Cerebro</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.cerebro.Cerebro.add_order_history" href="#backtrader.cerebro.Cerebro.add_order_history">add_order_history</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.add_signal" href="#backtrader.cerebro.Cerebro.add_signal">add_signal</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.add_timer" href="#backtrader.cerebro.Cerebro.add_timer">add_timer</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addanalyzer" href="#backtrader.cerebro.Cerebro.addanalyzer">addanalyzer</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addcalendar" href="#backtrader.cerebro.Cerebro.addcalendar">addcalendar</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.adddata" href="#backtrader.cerebro.Cerebro.adddata">adddata</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.adddatacb" href="#backtrader.cerebro.Cerebro.adddatacb">adddatacb</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addindicator" href="#backtrader.cerebro.Cerebro.addindicator">addindicator</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addobserver" href="#backtrader.cerebro.Cerebro.addobserver">addobserver</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addobservermulti" href="#backtrader.cerebro.Cerebro.addobservermulti">addobservermulti</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addsizer" href="#backtrader.cerebro.Cerebro.addsizer">addsizer</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addsizer_byidx" href="#backtrader.cerebro.Cerebro.addsizer_byidx">addsizer_byidx</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addstore" href="#backtrader.cerebro.Cerebro.addstore">addstore</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addstorecb" href="#backtrader.cerebro.Cerebro.addstorecb">addstorecb</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addstrategy" href="#backtrader.cerebro.Cerebro.addstrategy">addstrategy</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addtz" href="#backtrader.cerebro.Cerebro.addtz">addtz</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.addwriter" href="#backtrader.cerebro.Cerebro.addwriter">addwriter</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.broker" href="#backtrader.cerebro.Cerebro.broker">broker</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.chaindata" href="#backtrader.cerebro.Cerebro.chaindata">chaindata</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.frompackages" href="#backtrader.cerebro.Cerebro.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.getbroker" href="#backtrader.cerebro.Cerebro.getbroker">getbroker</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.iterize" href="#backtrader.cerebro.Cerebro.iterize">iterize</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.notify_data" href="#backtrader.cerebro.Cerebro.notify_data">notify_data</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.notify_store" href="#backtrader.cerebro.Cerebro.notify_store">notify_store</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.notify_timer" href="#backtrader.cerebro.Cerebro.notify_timer">notify_timer</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.optcallback" href="#backtrader.cerebro.Cerebro.optcallback">optcallback</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.optstrategy" href="#backtrader.cerebro.Cerebro.optstrategy">optstrategy</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.packages" href="#backtrader.cerebro.Cerebro.packages">packages</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.params" href="#backtrader.cerebro.Cerebro.params">params</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.plot" href="#backtrader.cerebro.Cerebro.plot">plot</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.replaydata" href="#backtrader.cerebro.Cerebro.replaydata">replaydata</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.resampledata" href="#backtrader.cerebro.Cerebro.resampledata">resampledata</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.rolloverdata" href="#backtrader.cerebro.Cerebro.rolloverdata">rolloverdata</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.run" href="#backtrader.cerebro.Cerebro.run">run</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.runstop" href="#backtrader.cerebro.Cerebro.runstop">runstop</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.runstrategies" href="#backtrader.cerebro.Cerebro.runstrategies">runstrategies</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.set_fund_history" href="#backtrader.cerebro.Cerebro.set_fund_history">set_fund_history</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.setbroker" href="#backtrader.cerebro.Cerebro.setbroker">setbroker</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.signal_accumulate" href="#backtrader.cerebro.Cerebro.signal_accumulate">signal_accumulate</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.signal_concurrent" href="#backtrader.cerebro.Cerebro.signal_concurrent">signal_concurrent</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.signal_strategy" href="#backtrader.cerebro.Cerebro.signal_strategy">signal_strategy</a></code></li>
<li><code><a title="backtrader.cerebro.Cerebro.stop_writers" href="#backtrader.cerebro.Cerebro.stop_writers">stop_writers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.cerebro.OptReturn" href="#backtrader.cerebro.OptReturn">OptReturn</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>