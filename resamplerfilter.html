<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.resamplerfilter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.resamplerfilter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)


from datetime import datetime, date, timedelta

from .dataseries import TimeFrame, _Bar
from .utils.py3 import with_metaclass
from . import metabase
from .utils.date import date2num, num2date


class DTFaker(object):
    # This will only be used for data sources which at some point in time
    # return None from _load to indicate that a check of the resampler and/or
    # notification queue is needed
    # This is meant (at least initially) for real-time feeds, because those are
    # the ones in need of events like the ones described above.
    # These data sources should also be producing ``utc`` time directly because
    # the real-time feed is (more often than not)  timestamped and utc provides
    # a universal reference
    # That&#39;s why below the timestamp is chosen in UTC and passed directly to
    # date2num to avoid a localization. But it is extracted from data.num2date
    # to ensure the returned datetime object is localized according to the
    # expected output by the user (local timezone or any specified)

    def __init__(self, data, forcedata=None):
        self.data = data

        # Aliases
        self.datetime = self
        self.p = self

        if forcedata is None:
            _dtime = datetime.utcnow() + data._timeoffset()
            self._dt = dt = date2num(_dtime)  # utc-like time
            self._dtime = data.num2date(dt)  # localized time
        else:
            self._dt = forcedata.datetime[0]  # utc-like time
            self._dtime = forcedata.datetime.datetime()  # localized time

        self.sessionend = data.p.sessionend

    def __len__(self):
        return len(self.data)

    def __call__(self, idx=0):
        return self._dtime  # simulates data.datetime.datetime()

    def datetime(self, idx=0):
        return self._dtime

    def date(self, idx=0):
        return self._dtime.date()

    def time(self, idx=0):
        return self._dtime.time()

    @property
    def _calendar(self):
        return self.data._calendar

    def __getitem__(self, idx):
        return self._dt if idx == 0 else float(&#39;-inf&#39;)

    def num2date(self, *args, **kwargs):
        return self.data.num2date(*args, **kwargs)

    def date2num(self, *args, **kwargs):
        return self.data.date2num(*args, **kwargs)

    def _getnexteos(self):
        return self.data._getnexteos()


class _BaseResampler(with_metaclass(metabase.MetaParams, object)):
    params = (
        (&#39;bar2edge&#39;, True),
        (&#39;adjbartime&#39;, True),
        (&#39;rightedge&#39;, True),
        (&#39;boundoff&#39;, 0),

        (&#39;timeframe&#39;, TimeFrame.Days),
        (&#39;compression&#39;, 1),

        (&#39;takelate&#39;, True),

        (&#39;sessionend&#39;, True),
    )

    def __init__(self, data):
        self.subdays = TimeFrame.Ticks &lt; self.p.timeframe &lt; TimeFrame.Days
        self.subweeks = self.p.timeframe &lt; TimeFrame.Weeks
        self.componly = (not self.subdays and
                         data._timeframe == self.p.timeframe and
                         not (self.p.compression % data._compression))

        self.bar = _Bar(maxdate=True)  # bar holder
        self.compcount = 0  # count of produced bars to control compression
        self._firstbar = True
        self.doadjusttime = (self.p.bar2edge and self.p.adjbartime and
                             self.subweeks)

        self._nexteos = None

        # Modify data information according to own parameters
        data.resampling = 1
        data.replaying = self.replaying
        data._timeframe = self.p.timeframe
        data._compression = self.p.compression

        self.data = data

    def _latedata(self, data):
        # new data at position 0, still untouched from stream
        if not self.subdays:
            return False

        # Time already delivered
        return len(data) &gt; 1 and data.datetime[0] &lt;= data.datetime[-1]

    def _checkbarover(self, data, fromcheck=False, forcedata=None):
        chkdata = DTFaker(data, forcedata) if fromcheck else data

        isover = False
        if not self.componly and not self._barover(chkdata):
            return isover

        if self.subdays and self.p.bar2edge:
            isover = True
        elif not fromcheck:  # fromcheck doesn&#39;t increase compcount
            self.compcount += 1
            if not (self.compcount % self.p.compression):
                # boundary crossed and enough bars for compression ... proceed
                isover = True

        return isover

    def _barover(self, data):
        tframe = self.p.timeframe

        if tframe == TimeFrame.Ticks:
            # Ticks is already the lowest level
            return self.bar.isopen()

        elif tframe &lt; TimeFrame.Days:
            return self._barover_subdays(data)

        elif tframe == TimeFrame.Days:
            return self._barover_days(data)

        elif tframe == TimeFrame.Weeks:
            return self._barover_weeks(data)

        elif tframe == TimeFrame.Months:
            return self._barover_months(data)

        elif tframe == TimeFrame.Years:
            return self._barover_years(data)

    def _eosset(self):
        if self._nexteos is None:
            self._nexteos, self._nextdteos = self.data._getnexteos()
            return

    def _eoscheck(self, data, seteos=True, exact=False):
        if seteos:
            self._eosset()

        equal = data.datetime[0] == self._nextdteos
        grter = data.datetime[0] &gt; self._nextdteos

        if exact:
            ret = equal
        else:
            # if the compared data goes over the endofsession
            # make sure the resampled bar is open and has something before that
            # end of session. It could be a weekend and nothing was delivered
            # until Monday
            if grter:
                ret = (self.bar.isopen() and
                       self.bar.datetime &lt;= self._nextdteos)
            else:
                ret = equal

        if ret:
            self._lasteos = self._nexteos
            self._lastdteos = self._nextdteos
            self._nexteos = None
            self._nextdteos = float(&#39;-inf&#39;)

        return ret

    def _barover_days(self, data):
        return self._eoscheck(data)

    def _barover_weeks(self, data):
        if self.data._calendar is None:
            year, week, _ = data.num2date(self.bar.datetime).date().isocalendar()
            yearweek = year * 100 + week

            baryear, barweek, _ = data.datetime.date().isocalendar()
            bar_yearweek = baryear * 100 + barweek

            return bar_yearweek &gt; yearweek
        else:
            return data._calendar.last_weekday(data.datetime.date())

    def _barover_months(self, data):
        dt = data.num2date(self.bar.datetime).date()
        yearmonth = dt.year * 100 + dt.month

        bardt = data.datetime.datetime()
        bar_yearmonth = bardt.year * 100 + bardt.month

        return bar_yearmonth &gt; yearmonth

    def _barover_years(self, data):
        return (data.datetime.datetime().year &gt;
                data.num2date(self.bar.datetime).year)

    def _gettmpoint(self, tm):
        &#39;&#39;&#39;Returns the point of time intraday for a given time according to the
        timeframe

          - Ex 1: 00:05:00 in minutes -&gt; point = 5
          - Ex 2: 00:05:20 in seconds -&gt; point = 5 * 60 + 20 = 320
        &#39;&#39;&#39;
        point = tm.hour * 60 + tm.minute
        restpoint = 0

        if self.p.timeframe &lt; TimeFrame.Minutes:
            point = point * 60 + tm.second

            if self.p.timeframe &lt; TimeFrame.Seconds:
                point = point * 1e6 + tm.microsecond
            else:
                restpoint = tm.microsecond
        else:
            restpoint = tm.second + tm.microsecond

        point += self.p.boundoff

        return point, restpoint

    def _barover_subdays(self, data):
        if self._eoscheck(data):
            return True

        if data.datetime[0] &lt; self.bar.datetime:
            return False

        # Get time objects for the comparisons - in utc-like format
        tm = num2date(self.bar.datetime).time()
        bartm = num2date(data.datetime[0]).time()

        point, _ = self._gettmpoint(tm)
        barpoint, _ = self._gettmpoint(bartm)

        ret = False
        if barpoint &gt; point:
            # The data bar has surpassed the internal bar
            if not self.p.bar2edge:
                # Compression done on simple bar basis (like days)
                ret = True
            elif self.p.compression == 1:
                # no bar compression requested -&gt; internal bar done
                ret = True
            else:
                point_comp = point // self.p.compression
                barpoint_comp = barpoint // self.p.compression

                # Went over boundary including compression
                if barpoint_comp &gt; point_comp:
                    ret = True

        return ret

    def check(self, data, _forcedata=None):
        &#39;&#39;&#39;Called to check if the current stored bar has to be delivered in
        spite of the data not having moved forward. If no ticks from a live
        feed come in, a 5 second resampled bar could be delivered 20 seconds
        later. When this method is called the wall clock (incl data time
        offset) is called to check if the time has gone so far as to have to
        deliver the already stored data
        &#39;&#39;&#39;
        if not self.bar.isopen():
            return

        return self(data, fromcheck=True, forcedata=_forcedata)

    def _dataonedge(self, data):
        if not self.subweeks:
            if data._calendar is None:
                return False, True  # nothing can be done

            tframe = self.p.timeframe
            ret = False
            if tframe == TimeFrame.Weeks:  # Ticks is already the lowest
                ret = data._calendar.last_weekday(data.datetime.date())
            elif tframe == TimeFrame.Months:
                ret = data._calendar.last_monthday(data.datetime.date())
            elif tframe == TimeFrame.Years:
                ret = data._calendar.last_yearday(data.datetime.date())

            if ret:
                # Data must be consumed but compression may not be met yet
                # Prevent barcheckover from being called because it could again
                # increase compcount
                docheckover = False
                self.compcount += 1
                ret = not (self.compcount % self.p.compression)
            else:
                docheckover = True

            return ret, docheckover

        if self._eoscheck(data, exact=True):
            return True, True

        if self.subdays:
            point, prest = self._gettmpoint(data.datetime.time())
            if prest:
                return False, True  # cannot be on boundary, subunits present

            # Pass through compression to get boundary and rest over boundary
            bound, brest = divmod(point, self.p.compression)

            # if no extra and decomp bound is point
            return (brest == 0 and point == (bound * self.p.compression), True)

        # Code overriden by eoscheck
        if False and self.p.sessionend:
            # Days scenario - get datetime to compare in output timezone
            # because p.sessionend is expected in output timezone
            bdtime = data.datetime.datetime()
            bsend = datetime.combine(bdtime.date(), data.p.sessionend)
            return bdtime == bsend

        return False, True  # subweeks, not subdays and not sessionend

    def _calcadjtime(self, greater=False):
        if self._nexteos is None:
            # Session has been exceeded - end of session is the mark
            return self._lastdteos  # utc-like

        dt = self.data.num2date(self.bar.datetime)

        # Get current time
        tm = dt.time()
        # Get the point of the day in the time frame unit (ex: minute 200)
        point, _ = self._gettmpoint(tm)

        # Apply compression to update the point position (comp 5 -&gt; 200 // 5)
        # point = (point // self.p.compression)
        point = point // self.p.compression

        # If rightedge (end of boundary is activated) add it unless recursing
        point += self.p.rightedge

        # Restore point to the timeframe units by de-applying compression
        point *= self.p.compression

        # Get hours, minutes, seconds and microseconds
        extradays = 0
        if self.p.timeframe == TimeFrame.Minutes:
            ph, pm = divmod(point, 60)
            ps = 0
            pus = 0
        elif self.p.timeframe == TimeFrame.Seconds:
            ph, pm = divmod(point, 60 * 60)
            pm, ps = divmod(pm, 60)
            pus = 0
        elif self.p.timeframe &lt;= TimeFrame.MicroSeconds:
            ph, pm = divmod(point, 60 * 60 * 1e6)
            pm, psec = divmod(pm, 60 * 1e6)
            ps, pus = divmod(psec, 1e6)
        elif self.p.timeframe == TimeFrame.Days:
            # last resort
            eost = self._nexteos.time()
            ph = eost.hour
            pm = eost.minute
            ps = eost.second
            pus = eost.microsecond

        if ph &gt; 23:  # went over midnight:
            extradays = ph // 24
            ph %= 24

        # Replace intraday parts with the calculated ones and update it
        dt = dt.replace(hour=int(ph), minute=int(pm),
                        second=int(ps), microsecond=int(pus))
        if extradays:
            dt += timedelta(days=extradays)
        dtnum = self.data.date2num(dt)
        return dtnum

    def _adjusttime(self, greater=False, forcedata=None):
        &#39;&#39;&#39;
        Adjusts the time of calculated bar (from underlying data source) by
        using the timeframe to the appropriate boundary, with compression taken
        into account

        Depending on param ``rightedge`` uses the starting boundary or the
        ending one
        &#39;&#39;&#39;
        dtnum = self._calcadjtime(greater=greater)
        if greater and dtnum &lt;= self.bar.datetime:
            return False

        self.bar.datetime = dtnum
        return True


class Resampler(_BaseResampler):
    &#39;&#39;&#39;This class resamples data of a given timeframe to a larger timeframe.

    Params

      - bar2edge (default: True)

        resamples using time boundaries as the target. For example with a
        &#34;ticks -&gt; 5 seconds&#34; the resulting 5 seconds bars will be aligned to
        xx:00, xx:05, xx:10 ...

      - adjbartime (default: True)

        Use the time at the boundary to adjust the time of the delivered
        resampled bar instead of the last seen timestamp. If resampling to &#34;5
        seconds&#34; the time of the bar will be adjusted for example to hh:mm:05
        even if the last seen timestamp was hh:mm:04.33

        .. note::

           Time will only be adjusted if &#34;bar2edge&#34; is True. It wouldn&#39;t make
           sense to adjust the time if the bar has not been aligned to a
           boundary

      - rightedge (default: True)

        Use the right edge of the time boundaries to set the time.

        If False and compressing to 5 seconds the time of a resampled bar for
        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
        boundary

        If True the used boundary for the time will be hh:mm:05 (the ending
        boundary)
    &#39;&#39;&#39;
    params = (
        (&#39;bar2edge&#39;, True),
        (&#39;adjbartime&#39;, True),
        (&#39;rightedge&#39;, True),
    )

    replaying = False

    def last(self, data):
        &#39;&#39;&#39;Called when the data is no longer producing bars

        Can be called multiple times. It has the chance to (for example)
        produce extra bars which may still be accumulated and have to be
        delivered
        &#39;&#39;&#39;
        if self.bar.isopen():
            if self.doadjusttime:
                self._adjusttime()

            data._add2stack(self.bar.lvalues())
            self.bar.bstart(maxdate=True)  # close the bar to avoid dups
            return True

        return False

    def __call__(self, data, fromcheck=False, forcedata=None):
        &#39;&#39;&#39;Called for each set of values produced by the data source&#39;&#39;&#39;
        consumed = False
        onedge = False
        docheckover = True
        if not fromcheck:
            if self._latedata(data):
                if not self.p.takelate:
                    data.backwards()
                    return True  # get a new bar

                self.bar.bupdate(data)  # update new or existing bar
                # push time beyond reference
                self.bar.datetime = data.datetime[-1] + 0.000001
                data.backwards()  # remove used bar
                return True

            if self.componly:  # only if not subdays
                # Get a session ref before rewinding
                _, self._lastdteos = self.data._getnexteos()
                consumed = True

            else:
                onedge, docheckover = self._dataonedge(data)  # for subdays
                consumed = onedge

        if consumed:
            self.bar.bupdate(data)  # update new or existing bar
            data.backwards()  # remove used bar

        # if self.bar.isopen and (onedge or (docheckover and checkbarover))
        cond = self.bar.isopen()
        if cond:  # original is and, the 2nd term must also be true
            if not onedge:  # onedge true is sufficient
                if docheckover:
                    cond = self._checkbarover(data, fromcheck=fromcheck,
                                              forcedata=forcedata)
        if cond:
            dodeliver = False
            if forcedata is not None:
                # check our delivery time is not larger than that of forcedata
                tframe = self.p.timeframe
                if tframe == TimeFrame.Ticks:  # Ticks is already the lowest
                    dodeliver = True
                elif tframe == TimeFrame.Minutes:
                    dtnum = self._calcadjtime(greater=True)
                    dodeliver = dtnum &lt;= forcedata.datetime[0]
                elif tframe == TimeFrame.Days:
                    dtnum = self._calcadjtime(greater=True)
                    dodeliver = dtnum &lt;= forcedata.datetime[0]
            else:
                dodeliver = True

            if dodeliver:
                if not onedge and self.doadjusttime:
                    self._adjusttime(greater=True, forcedata=forcedata)

                data._add2stack(self.bar.lvalues())
                self.bar.bstart(maxdate=True)  # bar delivered -&gt; restart

        if not fromcheck:
            if not consumed:
                self.bar.bupdate(data)  # update new or existing bar
                data.backwards()  # remove used bar

        return True


class Replayer(_BaseResampler):
    &#39;&#39;&#39;This class replays data of a given timeframe to a larger timeframe.

    It simulates the action of the market by slowly building up (for ex.) a
    daily bar from tick/seconds/minutes data

    Only when the bar is complete will the &#34;length&#34; of the data be changed
    effectively delivering a closed bar

    Params

      - bar2edge (default: True)

        replays using time boundaries as the target of the closed bar. For
        example with a &#34;ticks -&gt; 5 seconds&#34; the resulting 5 seconds bars will
        be aligned to xx:00, xx:05, xx:10 ...

      - adjbartime (default: False)

        Use the time at the boundary to adjust the time of the delivered
        resampled bar instead of the last seen timestamp. If resampling to &#34;5
        seconds&#34; the time of the bar will be adjusted for example to hh:mm:05
        even if the last seen timestamp was hh:mm:04.33

        .. note::

           Time will only be adjusted if &#34;bar2edge&#34; is True. It wouldn&#39;t make
           sense to adjust the time if the bar has not been aligned to a
           boundary

        .. note:: if this parameter is True an extra tick with the *adjusted*
                  time will be introduced at the end of the *replayed* bar

      - rightedge (default: True)

        Use the right edge of the time boundaries to set the time.

        If False and compressing to 5 seconds the time of a resampled bar for
        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
        boundary

        If True the used boundary for the time will be hh:mm:05 (the ending
        boundary)
    &#39;&#39;&#39;
    params = (
        (&#39;bar2edge&#39;, True),
        (&#39;adjbartime&#39;, False),
        (&#39;rightedge&#39;, True),
    )

    replaying = True

    def __call__(self, data, fromcheck=False, forcedata=None):
        consumed = False
        onedge = False
        takinglate = False
        docheckover = True

        if not fromcheck:
            if self._latedata(data):
                if not self.p.takelate:
                    data.backwards(force=True)
                    return True  # get a new bar

                consumed = True
                takinglate = True

            elif self.componly:  # only if not subdays
                consumed = True

            else:
                onedge, docheckover = self._dataonedge(data)  # for subdays
                consumed = onedge

            data._tick_fill(force=True)  # update

        if consumed:
            self.bar.bupdate(data)
            if takinglate:
                self.bar.datetime = data.datetime[-1] + 0.000001

        # if onedge or (checkbarover and self._checkbarover)
        cond = onedge
        if not cond:  # original is or, if true it would suffice
            if docheckover:
                cond = self._checkbarover(data, fromcheck=fromcheck)
        if cond:
            if not onedge and self.doadjusttime:  # insert tick with adjtime
                adjusted = self._adjusttime(greater=True)
                if adjusted:
                    ago = 0 if (consumed or fromcheck) else -1
                    # Update to the point right before the new data
                    data._updatebar(self.bar.lvalues(), forward=False, ago=ago)

                if not fromcheck:
                    if not consumed:
                        # Reopen bar with real new data and save data to queue
                        self.bar.bupdate(data, reopen=True)
                        # erase is True, but the tick will not be seen below
                        # and therefore no need to mark as 1st
                        data._save2stack(erase=True, force=True)
                    else:
                        self.bar.bstart(maxdate=True)
                        self._firstbar = True  # next is first
                else:  # from check
                    # fromcheck or consumed have  forced delivery, reopen
                    self.bar.bstart(maxdate=True)
                    self._firstbar = True  # next is first
                    if adjusted:
                        # after adjusting need to redeliver if this was a check
                        data._save2stack(erase=True, force=True)

            elif not fromcheck:
                if not consumed:
                    # Data already &#34;forwarded&#34; and we replay to new bar
                    # No need to go backwards. simply reopen internal cache
                    self.bar.bupdate(data, reopen=True)
                else:
                    # compression only, used data to update bar, hence remove
                    # from stream, update existing data, reopen bar
                    if not self._firstbar:  # only discard data if not firstbar
                        data.backwards(force=True)
                    data._updatebar(self.bar.lvalues(), forward=False, ago=0)
                    self.bar.bstart(maxdate=True)
                    self._firstbar = True  # make sure next tick moves forward

        elif not fromcheck:
            # not over, update, remove new entry, deliver
            if not consumed:
                self.bar.bupdate(data)

            if not self._firstbar:  # only discard data if not firstbar
                data.backwards(force=True)

            data._updatebar(self.bar.lvalues(), forward=False, ago=0)
            self._firstbar = False

        return False  # the existing bar can be processed by the system


class ResamplerTicks(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Ticks),)


class ResamplerSeconds(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Seconds),)


class ResamplerMinutes(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Minutes),)


class ResamplerDaily(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Days),)


class ResamplerWeekly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Weeks),)


class ResamplerMonthly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Months),)


class ResamplerYearly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Years),)


class ReplayerTicks(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Ticks),)


class ReplayerSeconds(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Seconds),)


class ReplayerMinutes(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Minutes),)


class ReplayerDaily(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Days),)


class ReplayerWeekly(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Weeks),)


class ReplayerMonthly(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Months),)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.resamplerfilter.DTFaker"><code class="flex name class">
<span>class <span class="ident">DTFaker</span></span>
<span>(</span><span>data, forcedata=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DTFaker(object):
    # This will only be used for data sources which at some point in time
    # return None from _load to indicate that a check of the resampler and/or
    # notification queue is needed
    # This is meant (at least initially) for real-time feeds, because those are
    # the ones in need of events like the ones described above.
    # These data sources should also be producing ``utc`` time directly because
    # the real-time feed is (more often than not)  timestamped and utc provides
    # a universal reference
    # That&#39;s why below the timestamp is chosen in UTC and passed directly to
    # date2num to avoid a localization. But it is extracted from data.num2date
    # to ensure the returned datetime object is localized according to the
    # expected output by the user (local timezone or any specified)

    def __init__(self, data, forcedata=None):
        self.data = data

        # Aliases
        self.datetime = self
        self.p = self

        if forcedata is None:
            _dtime = datetime.utcnow() + data._timeoffset()
            self._dt = dt = date2num(_dtime)  # utc-like time
            self._dtime = data.num2date(dt)  # localized time
        else:
            self._dt = forcedata.datetime[0]  # utc-like time
            self._dtime = forcedata.datetime.datetime()  # localized time

        self.sessionend = data.p.sessionend

    def __len__(self):
        return len(self.data)

    def __call__(self, idx=0):
        return self._dtime  # simulates data.datetime.datetime()

    def datetime(self, idx=0):
        return self._dtime

    def date(self, idx=0):
        return self._dtime.date()

    def time(self, idx=0):
        return self._dtime.time()

    @property
    def _calendar(self):
        return self.data._calendar

    def __getitem__(self, idx):
        return self._dt if idx == 0 else float(&#39;-inf&#39;)

    def num2date(self, *args, **kwargs):
        return self.data.num2date(*args, **kwargs)

    def date2num(self, *args, **kwargs):
        return self.data.date2num(*args, **kwargs)

    def _getnexteos(self):
        return self.data._getnexteos()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="backtrader.resamplerfilter.DTFaker.date"><code class="name flex">
<span>def <span class="ident">date</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date(self, idx=0):
    return self._dtime.date()</code></pre>
</details>
</dd>
<dt id="backtrader.resamplerfilter.DTFaker.date2num"><code class="name flex">
<span>def <span class="ident">date2num</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date2num(self, *args, **kwargs):
    return self.data.date2num(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.resamplerfilter.DTFaker.datetime"><code class="name flex">
<span>def <span class="ident">datetime</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def datetime(self, idx=0):
    return self._dtime</code></pre>
</details>
</dd>
<dt id="backtrader.resamplerfilter.DTFaker.num2date"><code class="name flex">
<span>def <span class="ident">num2date</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num2date(self, *args, **kwargs):
    return self.data.num2date(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.resamplerfilter.DTFaker.time"><code class="name flex">
<span>def <span class="ident">time</span></span>(<span>self, idx=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time(self, idx=0):
    return self._dtime.time()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.Replayer"><code class="flex name class">
<span>class <span class="ident">Replayer</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Replayer(_BaseResampler):
    &#39;&#39;&#39;This class replays data of a given timeframe to a larger timeframe.

    It simulates the action of the market by slowly building up (for ex.) a
    daily bar from tick/seconds/minutes data

    Only when the bar is complete will the &#34;length&#34; of the data be changed
    effectively delivering a closed bar

    Params

      - bar2edge (default: True)

        replays using time boundaries as the target of the closed bar. For
        example with a &#34;ticks -&gt; 5 seconds&#34; the resulting 5 seconds bars will
        be aligned to xx:00, xx:05, xx:10 ...

      - adjbartime (default: False)

        Use the time at the boundary to adjust the time of the delivered
        resampled bar instead of the last seen timestamp. If resampling to &#34;5
        seconds&#34; the time of the bar will be adjusted for example to hh:mm:05
        even if the last seen timestamp was hh:mm:04.33

        .. note::

           Time will only be adjusted if &#34;bar2edge&#34; is True. It wouldn&#39;t make
           sense to adjust the time if the bar has not been aligned to a
           boundary

        .. note:: if this parameter is True an extra tick with the *adjusted*
                  time will be introduced at the end of the *replayed* bar

      - rightedge (default: True)

        Use the right edge of the time boundaries to set the time.

        If False and compressing to 5 seconds the time of a resampled bar for
        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
        boundary

        If True the used boundary for the time will be hh:mm:05 (the ending
        boundary)
    &#39;&#39;&#39;
    params = (
        (&#39;bar2edge&#39;, True),
        (&#39;adjbartime&#39;, False),
        (&#39;rightedge&#39;, True),
    )

    replaying = True

    def __call__(self, data, fromcheck=False, forcedata=None):
        consumed = False
        onedge = False
        takinglate = False
        docheckover = True

        if not fromcheck:
            if self._latedata(data):
                if not self.p.takelate:
                    data.backwards(force=True)
                    return True  # get a new bar

                consumed = True
                takinglate = True

            elif self.componly:  # only if not subdays
                consumed = True

            else:
                onedge, docheckover = self._dataonedge(data)  # for subdays
                consumed = onedge

            data._tick_fill(force=True)  # update

        if consumed:
            self.bar.bupdate(data)
            if takinglate:
                self.bar.datetime = data.datetime[-1] + 0.000001

        # if onedge or (checkbarover and self._checkbarover)
        cond = onedge
        if not cond:  # original is or, if true it would suffice
            if docheckover:
                cond = self._checkbarover(data, fromcheck=fromcheck)
        if cond:
            if not onedge and self.doadjusttime:  # insert tick with adjtime
                adjusted = self._adjusttime(greater=True)
                if adjusted:
                    ago = 0 if (consumed or fromcheck) else -1
                    # Update to the point right before the new data
                    data._updatebar(self.bar.lvalues(), forward=False, ago=ago)

                if not fromcheck:
                    if not consumed:
                        # Reopen bar with real new data and save data to queue
                        self.bar.bupdate(data, reopen=True)
                        # erase is True, but the tick will not be seen below
                        # and therefore no need to mark as 1st
                        data._save2stack(erase=True, force=True)
                    else:
                        self.bar.bstart(maxdate=True)
                        self._firstbar = True  # next is first
                else:  # from check
                    # fromcheck or consumed have  forced delivery, reopen
                    self.bar.bstart(maxdate=True)
                    self._firstbar = True  # next is first
                    if adjusted:
                        # after adjusting need to redeliver if this was a check
                        data._save2stack(erase=True, force=True)

            elif not fromcheck:
                if not consumed:
                    # Data already &#34;forwarded&#34; and we replay to new bar
                    # No need to go backwards. simply reopen internal cache
                    self.bar.bupdate(data, reopen=True)
                else:
                    # compression only, used data to update bar, hence remove
                    # from stream, update existing data, reopen bar
                    if not self._firstbar:  # only discard data if not firstbar
                        data.backwards(force=True)
                    data._updatebar(self.bar.lvalues(), forward=False, ago=0)
                    self.bar.bstart(maxdate=True)
                    self._firstbar = True  # make sure next tick moves forward

        elif not fromcheck:
            # not over, update, remove new entry, deliver
            if not consumed:
                self.bar.bupdate(data)

            if not self._firstbar:  # only discard data if not firstbar
                data.backwards(force=True)

            data._updatebar(self.bar.lvalues(), forward=False, ago=0)
            self._firstbar = False

        return False  # the existing bar can be processed by the system</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.ReplayerDaily" href="#backtrader.resamplerfilter.ReplayerDaily">ReplayerDaily</a></li>
<li><a title="backtrader.resamplerfilter.ReplayerMinutes" href="#backtrader.resamplerfilter.ReplayerMinutes">ReplayerMinutes</a></li>
<li><a title="backtrader.resamplerfilter.ReplayerMonthly" href="#backtrader.resamplerfilter.ReplayerMonthly">ReplayerMonthly</a></li>
<li><a title="backtrader.resamplerfilter.ReplayerSeconds" href="#backtrader.resamplerfilter.ReplayerSeconds">ReplayerSeconds</a></li>
<li><a title="backtrader.resamplerfilter.ReplayerTicks" href="#backtrader.resamplerfilter.ReplayerTicks">ReplayerTicks</a></li>
<li><a title="backtrader.resamplerfilter.ReplayerWeekly" href="#backtrader.resamplerfilter.ReplayerWeekly">ReplayerWeekly</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.Replayer.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Replayer.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Replayer.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Replayer.replaying"><code class="name">var <span class="ident">replaying</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerDaily"><code class="flex name class">
<span>class <span class="ident">ReplayerDaily</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerDaily(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Days),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerDaily.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerDaily.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerDaily.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMinutes"><code class="flex name class">
<span>class <span class="ident">ReplayerMinutes</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerMinutes(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Minutes),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerMinutes.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMinutes.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMinutes.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMonthly"><code class="flex name class">
<span>class <span class="ident">ReplayerMonthly</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerMonthly(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Months),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerMonthly.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMonthly.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerMonthly.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerSeconds"><code class="flex name class">
<span>class <span class="ident">ReplayerSeconds</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerSeconds(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Seconds),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerSeconds.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerSeconds.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerSeconds.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerTicks"><code class="flex name class">
<span>class <span class="ident">ReplayerTicks</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerTicks(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Ticks),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerTicks.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerTicks.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerTicks.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerWeekly"><code class="flex name class">
<span>class <span class="ident">ReplayerWeekly</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class replays data of a given timeframe to a larger timeframe.</p>
<p>It simulates the action of the market by slowly building up (for ex.) a
daily bar from tick/seconds/minutes data</p>
<p>Only when the bar is complete will the "length" of the data be changed
effectively delivering a closed bar</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  replays using time boundaries as the target of the closed bar. For
  example with a "ticks -&gt; 5 seconds" the resulting 5 seconds bars will
  be aligned to xx:00, xx:05, xx:10 ...

- adjbartime (default: False)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

  !!! note "Note:&amp;ensp;if this parameter is True an extra tick with the *adjusted*"
      time will be introduced at the end of the *replayed* bar

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplayerWeekly(Replayer):
    params = ((&#39;timeframe&#39;, TimeFrame.Weeks),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ReplayerWeekly.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerWeekly.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ReplayerWeekly.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.Resampler"><code class="flex name class">
<span>class <span class="ident">Resampler</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Resampler(_BaseResampler):
    &#39;&#39;&#39;This class resamples data of a given timeframe to a larger timeframe.

    Params

      - bar2edge (default: True)

        resamples using time boundaries as the target. For example with a
        &#34;ticks -&gt; 5 seconds&#34; the resulting 5 seconds bars will be aligned to
        xx:00, xx:05, xx:10 ...

      - adjbartime (default: True)

        Use the time at the boundary to adjust the time of the delivered
        resampled bar instead of the last seen timestamp. If resampling to &#34;5
        seconds&#34; the time of the bar will be adjusted for example to hh:mm:05
        even if the last seen timestamp was hh:mm:04.33

        .. note::

           Time will only be adjusted if &#34;bar2edge&#34; is True. It wouldn&#39;t make
           sense to adjust the time if the bar has not been aligned to a
           boundary

      - rightedge (default: True)

        Use the right edge of the time boundaries to set the time.

        If False and compressing to 5 seconds the time of a resampled bar for
        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
        boundary

        If True the used boundary for the time will be hh:mm:05 (the ending
        boundary)
    &#39;&#39;&#39;
    params = (
        (&#39;bar2edge&#39;, True),
        (&#39;adjbartime&#39;, True),
        (&#39;rightedge&#39;, True),
    )

    replaying = False

    def last(self, data):
        &#39;&#39;&#39;Called when the data is no longer producing bars

        Can be called multiple times. It has the chance to (for example)
        produce extra bars which may still be accumulated and have to be
        delivered
        &#39;&#39;&#39;
        if self.bar.isopen():
            if self.doadjusttime:
                self._adjusttime()

            data._add2stack(self.bar.lvalues())
            self.bar.bstart(maxdate=True)  # close the bar to avoid dups
            return True

        return False

    def __call__(self, data, fromcheck=False, forcedata=None):
        &#39;&#39;&#39;Called for each set of values produced by the data source&#39;&#39;&#39;
        consumed = False
        onedge = False
        docheckover = True
        if not fromcheck:
            if self._latedata(data):
                if not self.p.takelate:
                    data.backwards()
                    return True  # get a new bar

                self.bar.bupdate(data)  # update new or existing bar
                # push time beyond reference
                self.bar.datetime = data.datetime[-1] + 0.000001
                data.backwards()  # remove used bar
                return True

            if self.componly:  # only if not subdays
                # Get a session ref before rewinding
                _, self._lastdteos = self.data._getnexteos()
                consumed = True

            else:
                onedge, docheckover = self._dataonedge(data)  # for subdays
                consumed = onedge

        if consumed:
            self.bar.bupdate(data)  # update new or existing bar
            data.backwards()  # remove used bar

        # if self.bar.isopen and (onedge or (docheckover and checkbarover))
        cond = self.bar.isopen()
        if cond:  # original is and, the 2nd term must also be true
            if not onedge:  # onedge true is sufficient
                if docheckover:
                    cond = self._checkbarover(data, fromcheck=fromcheck,
                                              forcedata=forcedata)
        if cond:
            dodeliver = False
            if forcedata is not None:
                # check our delivery time is not larger than that of forcedata
                tframe = self.p.timeframe
                if tframe == TimeFrame.Ticks:  # Ticks is already the lowest
                    dodeliver = True
                elif tframe == TimeFrame.Minutes:
                    dtnum = self._calcadjtime(greater=True)
                    dodeliver = dtnum &lt;= forcedata.datetime[0]
                elif tframe == TimeFrame.Days:
                    dtnum = self._calcadjtime(greater=True)
                    dodeliver = dtnum &lt;= forcedata.datetime[0]
            else:
                dodeliver = True

            if dodeliver:
                if not onedge and self.doadjusttime:
                    self._adjusttime(greater=True, forcedata=forcedata)

                data._add2stack(self.bar.lvalues())
                self.bar.bstart(maxdate=True)  # bar delivered -&gt; restart

        if not fromcheck:
            if not consumed:
                self.bar.bupdate(data)  # update new or existing bar
                data.backwards()  # remove used bar

        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.ResamplerDaily" href="#backtrader.resamplerfilter.ResamplerDaily">ResamplerDaily</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerMinutes" href="#backtrader.resamplerfilter.ResamplerMinutes">ResamplerMinutes</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerMonthly" href="#backtrader.resamplerfilter.ResamplerMonthly">ResamplerMonthly</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerSeconds" href="#backtrader.resamplerfilter.ResamplerSeconds">ResamplerSeconds</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerTicks" href="#backtrader.resamplerfilter.ResamplerTicks">ResamplerTicks</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerWeekly" href="#backtrader.resamplerfilter.ResamplerWeekly">ResamplerWeekly</a></li>
<li><a title="backtrader.resamplerfilter.ResamplerYearly" href="#backtrader.resamplerfilter.ResamplerYearly">ResamplerYearly</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.Resampler.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Resampler.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Resampler.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.Resampler.replaying"><code class="name">var <span class="ident">replaying</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.resamplerfilter.Resampler.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the data is no longer producing bars</p>
<p>Can be called multiple times. It has the chance to (for example)
produce extra bars which may still be accumulated and have to be
delivered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self, data):
    &#39;&#39;&#39;Called when the data is no longer producing bars

    Can be called multiple times. It has the chance to (for example)
    produce extra bars which may still be accumulated and have to be
    delivered
    &#39;&#39;&#39;
    if self.bar.isopen():
        if self.doadjusttime:
            self._adjusttime()

        data._add2stack(self.bar.lvalues())
        self.bar.bstart(maxdate=True)  # close the bar to avoid dups
        return True

    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerDaily"><code class="flex name class">
<span>class <span class="ident">ResamplerDaily</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerDaily(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Days),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerDaily.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerDaily.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerDaily.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMinutes"><code class="flex name class">
<span>class <span class="ident">ResamplerMinutes</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerMinutes(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Minutes),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerMinutes.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMinutes.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMinutes.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMonthly"><code class="flex name class">
<span>class <span class="ident">ResamplerMonthly</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerMonthly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Months),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerMonthly.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMonthly.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerMonthly.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerSeconds"><code class="flex name class">
<span>class <span class="ident">ResamplerSeconds</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerSeconds(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Seconds),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerSeconds.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerSeconds.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerSeconds.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerTicks"><code class="flex name class">
<span>class <span class="ident">ResamplerTicks</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerTicks(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Ticks),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerTicks.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerTicks.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerTicks.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerWeekly"><code class="flex name class">
<span>class <span class="ident">ResamplerWeekly</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerWeekly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Weeks),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerWeekly.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerWeekly.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerWeekly.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerYearly"><code class="flex name class">
<span>class <span class="ident">ResamplerYearly</span></span>
<span>(</span><span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>This class resamples data of a given timeframe to a larger timeframe.</p>
<p>Params</p>
<pre><code>- bar2edge (default: True)

  resamples using time boundaries as the target. For example with a
  "ticks -&gt; 5 seconds" the resulting 5 seconds bars will be aligned to
  xx:00, xx:05, xx:10 ...

- adjbartime (default: True)

  Use the time at the boundary to adjust the time of the delivered
  resampled bar instead of the last seen timestamp. If resampling to "5
  seconds" the time of the bar will be adjusted for example to hh:mm:05
  even if the last seen timestamp was hh:mm:04.33

  !!! note "Note"
      Time will only be adjusted if "bar2edge" is True. It wouldn't make
      sense to adjust the time if the bar has not been aligned to a
      boundary

- rightedge (default: True)

  Use the right edge of the time boundaries to set the time.

  If False and compressing to 5 seconds the time of a resampled bar for
  seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the starting
  boundary

  If True the used boundary for the time will be hh:mm:05 (the ending
  boundary)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResamplerYearly(Resampler):
    params = ((&#39;timeframe&#39;, TimeFrame.Years),)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></li>
<li>backtrader.resamplerfilter._BaseResampler</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.resamplerfilter.ResamplerYearly.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerYearly.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.resamplerfilter.ResamplerYearly.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.resamplerfilter.DTFaker" href="#backtrader.resamplerfilter.DTFaker">DTFaker</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.DTFaker.date" href="#backtrader.resamplerfilter.DTFaker.date">date</a></code></li>
<li><code><a title="backtrader.resamplerfilter.DTFaker.date2num" href="#backtrader.resamplerfilter.DTFaker.date2num">date2num</a></code></li>
<li><code><a title="backtrader.resamplerfilter.DTFaker.datetime" href="#backtrader.resamplerfilter.DTFaker.datetime">datetime</a></code></li>
<li><code><a title="backtrader.resamplerfilter.DTFaker.num2date" href="#backtrader.resamplerfilter.DTFaker.num2date">num2date</a></code></li>
<li><code><a title="backtrader.resamplerfilter.DTFaker.time" href="#backtrader.resamplerfilter.DTFaker.time">time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.Replayer" href="#backtrader.resamplerfilter.Replayer">Replayer</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.Replayer.frompackages" href="#backtrader.resamplerfilter.Replayer.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Replayer.packages" href="#backtrader.resamplerfilter.Replayer.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Replayer.params" href="#backtrader.resamplerfilter.Replayer.params">params</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Replayer.replaying" href="#backtrader.resamplerfilter.Replayer.replaying">replaying</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerDaily" href="#backtrader.resamplerfilter.ReplayerDaily">ReplayerDaily</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerDaily.frompackages" href="#backtrader.resamplerfilter.ReplayerDaily.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerDaily.packages" href="#backtrader.resamplerfilter.ReplayerDaily.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerDaily.params" href="#backtrader.resamplerfilter.ReplayerDaily.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerMinutes" href="#backtrader.resamplerfilter.ReplayerMinutes">ReplayerMinutes</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerMinutes.frompackages" href="#backtrader.resamplerfilter.ReplayerMinutes.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerMinutes.packages" href="#backtrader.resamplerfilter.ReplayerMinutes.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerMinutes.params" href="#backtrader.resamplerfilter.ReplayerMinutes.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerMonthly" href="#backtrader.resamplerfilter.ReplayerMonthly">ReplayerMonthly</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerMonthly.frompackages" href="#backtrader.resamplerfilter.ReplayerMonthly.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerMonthly.packages" href="#backtrader.resamplerfilter.ReplayerMonthly.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerMonthly.params" href="#backtrader.resamplerfilter.ReplayerMonthly.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerSeconds" href="#backtrader.resamplerfilter.ReplayerSeconds">ReplayerSeconds</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerSeconds.frompackages" href="#backtrader.resamplerfilter.ReplayerSeconds.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerSeconds.packages" href="#backtrader.resamplerfilter.ReplayerSeconds.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerSeconds.params" href="#backtrader.resamplerfilter.ReplayerSeconds.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerTicks" href="#backtrader.resamplerfilter.ReplayerTicks">ReplayerTicks</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerTicks.frompackages" href="#backtrader.resamplerfilter.ReplayerTicks.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerTicks.packages" href="#backtrader.resamplerfilter.ReplayerTicks.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerTicks.params" href="#backtrader.resamplerfilter.ReplayerTicks.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ReplayerWeekly" href="#backtrader.resamplerfilter.ReplayerWeekly">ReplayerWeekly</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ReplayerWeekly.frompackages" href="#backtrader.resamplerfilter.ReplayerWeekly.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerWeekly.packages" href="#backtrader.resamplerfilter.ReplayerWeekly.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ReplayerWeekly.params" href="#backtrader.resamplerfilter.ReplayerWeekly.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.Resampler" href="#backtrader.resamplerfilter.Resampler">Resampler</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.Resampler.frompackages" href="#backtrader.resamplerfilter.Resampler.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Resampler.last" href="#backtrader.resamplerfilter.Resampler.last">last</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Resampler.packages" href="#backtrader.resamplerfilter.Resampler.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Resampler.params" href="#backtrader.resamplerfilter.Resampler.params">params</a></code></li>
<li><code><a title="backtrader.resamplerfilter.Resampler.replaying" href="#backtrader.resamplerfilter.Resampler.replaying">replaying</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerDaily" href="#backtrader.resamplerfilter.ResamplerDaily">ResamplerDaily</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerDaily.frompackages" href="#backtrader.resamplerfilter.ResamplerDaily.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerDaily.packages" href="#backtrader.resamplerfilter.ResamplerDaily.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerDaily.params" href="#backtrader.resamplerfilter.ResamplerDaily.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerMinutes" href="#backtrader.resamplerfilter.ResamplerMinutes">ResamplerMinutes</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerMinutes.frompackages" href="#backtrader.resamplerfilter.ResamplerMinutes.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerMinutes.packages" href="#backtrader.resamplerfilter.ResamplerMinutes.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerMinutes.params" href="#backtrader.resamplerfilter.ResamplerMinutes.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerMonthly" href="#backtrader.resamplerfilter.ResamplerMonthly">ResamplerMonthly</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerMonthly.frompackages" href="#backtrader.resamplerfilter.ResamplerMonthly.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerMonthly.packages" href="#backtrader.resamplerfilter.ResamplerMonthly.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerMonthly.params" href="#backtrader.resamplerfilter.ResamplerMonthly.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerSeconds" href="#backtrader.resamplerfilter.ResamplerSeconds">ResamplerSeconds</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerSeconds.frompackages" href="#backtrader.resamplerfilter.ResamplerSeconds.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerSeconds.packages" href="#backtrader.resamplerfilter.ResamplerSeconds.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerSeconds.params" href="#backtrader.resamplerfilter.ResamplerSeconds.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerTicks" href="#backtrader.resamplerfilter.ResamplerTicks">ResamplerTicks</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerTicks.frompackages" href="#backtrader.resamplerfilter.ResamplerTicks.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerTicks.packages" href="#backtrader.resamplerfilter.ResamplerTicks.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerTicks.params" href="#backtrader.resamplerfilter.ResamplerTicks.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerWeekly" href="#backtrader.resamplerfilter.ResamplerWeekly">ResamplerWeekly</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerWeekly.frompackages" href="#backtrader.resamplerfilter.ResamplerWeekly.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerWeekly.packages" href="#backtrader.resamplerfilter.ResamplerWeekly.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerWeekly.params" href="#backtrader.resamplerfilter.ResamplerWeekly.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.resamplerfilter.ResamplerYearly" href="#backtrader.resamplerfilter.ResamplerYearly">ResamplerYearly</a></code></h4>
<ul class="">
<li><code><a title="backtrader.resamplerfilter.ResamplerYearly.frompackages" href="#backtrader.resamplerfilter.ResamplerYearly.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerYearly.packages" href="#backtrader.resamplerfilter.ResamplerYearly.packages">packages</a></code></li>
<li><code><a title="backtrader.resamplerfilter.ResamplerYearly.params" href="#backtrader.resamplerfilter.ResamplerYearly.params">params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>