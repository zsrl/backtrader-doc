<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>backtrader.strategy API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>backtrader.strategy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin389/env python
# -*- coding: utf-8; py-indent-offset:4 -*-
###############################################################################
#
# Copyright (C) 2015-2023 Daniel Rodriguez
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
#
###############################################################################
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import collections
import copy
import datetime
import inspect
import itertools
import operator

from .utils.py3 import (filter, keys, integer_types, iteritems, itervalues,
                        map, MAXINT, string_types, with_metaclass)

import backtrader as bt
from .lineiterator import LineIterator, StrategyBase
from .lineroot import LineSingle
from .lineseries import LineSeriesStub
from .metabase import ItemCollection, findowner
from .trade import Trade
from .utils import OrderedDict, AutoOrderedDict, AutoDictList


class MetaStrategy(StrategyBase.__class__):
    _indcol = dict()

    def __new__(meta, name, bases, dct):
        # Hack to support original method name for notify_order
        if &#39;notify&#39; in dct:
            # rename &#39;notify&#39; to &#39;notify_order&#39;
            dct[&#39;notify_order&#39;] = dct.pop(&#39;notify&#39;)
        if &#39;notify_operation&#39; in dct:
            # rename &#39;notify&#39; to &#39;notify_order&#39;
            dct[&#39;notify_trade&#39;] = dct.pop(&#39;notify_operation&#39;)

        return super(MetaStrategy, meta).__new__(meta, name, bases, dct)

    def __init__(cls, name, bases, dct):
        &#39;&#39;&#39;
        Class has already been created ... register subclasses
        &#39;&#39;&#39;
        # Initialize the class
        super(MetaStrategy, cls).__init__(name, bases, dct)

        if not cls.aliased and \
           name != &#39;Strategy&#39; and not name.startswith(&#39;_&#39;):
            cls._indcol[name] = cls

    def donew(cls, *args, **kwargs):
        _obj, args, kwargs = super(MetaStrategy, cls).donew(*args, **kwargs)

        # Find the owner and store it
        _obj.env = _obj.cerebro = cerebro = findowner(_obj, bt.Cerebro)
        _obj._id = cerebro._next_stid()

        return _obj, args, kwargs

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaStrategy, cls).dopreinit(_obj, *args, **kwargs)
        _obj.broker = _obj.env.broker
        _obj._sizer = bt.sizers.FixedSize()
        _obj._orders = list()
        _obj._orderspending = list()
        _obj._trades = collections.defaultdict(AutoDictList)
        _obj._tradespending = list()

        _obj.stats = _obj.observers = ItemCollection()
        _obj.analyzers = ItemCollection()
        _obj._alnames = collections.defaultdict(itertools.count)
        _obj.writers = list()

        _obj._slave_analyzers = list()

        _obj._tradehistoryon = False

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaStrategy, cls).dopostinit(_obj, *args, **kwargs)

        _obj._sizer.set(_obj, _obj.broker)

        return _obj, args, kwargs


class Strategy(with_metaclass(MetaStrategy, StrategyBase)):
    &#39;&#39;&#39;
    Base class to be subclassed for user defined strategies.
    &#39;&#39;&#39;

    _ltype = LineIterator.StratType

    csv = True
    _oldsync = False  # update clock using old methodology : data 0

    # keep the latest delivered data date in the line
    lines = (&#39;datetime&#39;,)

    def qbuffer(self, savemem=0, replaying=False):
        &#39;&#39;&#39;Enable the memory saving schemes. Possible values for ``savemem``:

          0: No savings. Each lines object keeps in memory all values

          1: All lines objects save memory, using the strictly minimum needed

        Negative values are meant to be used when plotting is required:

          -1: Indicators at Strategy Level and Observers do not enable memory
              savings (but anything declared below it does)

          -2: Same as -1 plus activation of memory saving for any indicators
              which has declared *plotinfo.plot* as False (will not be plotted)
        &#39;&#39;&#39;
        if savemem &lt; 0:
            # Get any attribute which labels itself as Indicator
            for ind in self._lineiterators[self.IndType]:
                subsave = isinstance(ind, (LineSingle,))
                if not subsave and savemem &lt; -1:
                    subsave = not ind.plotinfo.plot
                ind.qbuffer(savemem=subsave)

        elif savemem &gt; 0:
            for data in self.datas:
                data.qbuffer(replaying=replaying)

            for line in self.lines:
                line.qbuffer(savemem=1)

            # Save in all object types depending on the strategy
            for itcls in self._lineiterators:
                for it in self._lineiterators[itcls]:
                    it.qbuffer(savemem=1)

    def _periodset(self):
        dataids = [id(data) for data in self.datas]

        _dminperiods = collections.defaultdict(list)
        for lineiter in self._lineiterators[LineIterator.IndType]:
            # if multiple datas are used and multiple timeframes the larger
            # timeframe may place larger time constraints in calling next.
            clk = getattr(lineiter, &#39;_clock&#39;, None)
            if clk is None:
                clk = getattr(lineiter._owner, &#39;_clock&#39;, None)
                if clk is None:
                    continue

            while True:
                if id(clk) in dataids:
                    break  # already top-level clock (data feed)

                # See if the current clock has higher level clocks
                clk2 = getattr(clk, &#39;_clock&#39;, None)
                if clk2 is None:
                    clk2 = getattr(clk._owner, &#39;_clock&#39;, None)

                if clk2 is None:
                    break  # if no clock found, bail out

                clk = clk2  # keep the ref and try to go up the hierarchy

            if clk is None:
                continue  # no clock found, go to next

            # LineSeriesStup wraps a line and the clock is the wrapped line and
            # no the wrapper itself.
            if isinstance(clk, LineSeriesStub):
                clk = clk.lines[0]

            _dminperiods[clk].append(lineiter._minperiod)

        self._minperiods = list()
        for data in self.datas:

            # Do not only consider the data as clock but also its lines which
            # may have been individually passed as clock references and
            # discovered as clocks above

            # Initialize with data min period if any
            dlminperiods = _dminperiods[data]

            for l in data.lines:  # search each line for min periods
                if l in _dminperiods:
                    dlminperiods += _dminperiods[l]  # found, add it

            # keep the reference to the line if any was found
            _dminperiods[data] = [max(dlminperiods)] if dlminperiods else []

            dminperiod = max(_dminperiods[data] or [data._minperiod])
            self._minperiods.append(dminperiod)

        # Set the minperiod
        minperiods = \
            [x._minperiod for x in self._lineiterators[LineIterator.IndType]]
        self._minperiod = max(minperiods or [self._minperiod])

    def _addwriter(self, writer):
        &#39;&#39;&#39;
        Unlike the other _addxxx functions this one receives an instance
        because the writer works at cerebro level and is only passed to the
        strategy to simplify the logic
        &#39;&#39;&#39;
        self.writers.append(writer)

    def _addindicator(self, indcls, *indargs, **indkwargs):
        indcls(*indargs, **indkwargs)

    def _addanalyzer_slave(self, ancls, *anargs, **ankwargs):
        &#39;&#39;&#39;Like _addanalyzer but meant for observers (or other entities) which
        rely on the output of an analyzer for the data. These analyzers have
        not been added by the user and are kept separate from the main
        analyzers

        Returns the created analyzer
        &#39;&#39;&#39;
        analyzer = ancls(*anargs, **ankwargs)
        self._slave_analyzers.append(analyzer)
        return analyzer

    def _getanalyzer_slave(self, idx):
        return self._slave_analyzers.append[idx]

    def _addanalyzer(self, ancls, *anargs, **ankwargs):
        anname = ankwargs.pop(&#39;_name&#39;, &#39;&#39;) or ancls.__name__.lower()
        nsuffix = next(self._alnames[anname])
        anname += str(nsuffix or &#39;&#39;)  # 0 (first instance) gets no suffix
        analyzer = ancls(*anargs, **ankwargs)
        self.analyzers.append(analyzer, anname)

    def _addobserver(self, multi, obscls, *obsargs, **obskwargs):
        obsname = obskwargs.pop(&#39;obsname&#39;, &#39;&#39;)
        if not obsname:
            obsname = obscls.__name__.lower()

        if not multi:
            newargs = list(itertools.chain(self.datas, obsargs))
            obs = obscls(*newargs, **obskwargs)
            self.stats.append(obs, obsname)
            return

        setattr(self.stats, obsname, list())
        l = getattr(self.stats, obsname)

        for data in self.datas:
            obs = obscls(data, *obsargs, **obskwargs)
            l.append(obs)

    def _getminperstatus(self):
        # check the min period status connected to datas
        dlens = map(operator.sub, self._minperiods, map(len, self.datas))
        self._minperstatus = minperstatus = max(dlens)
        return minperstatus

    def prenext_open(self):
        pass

    def nextstart_open(self):
        self.next_open()

    def next_open(self):
        pass

    def _oncepost_open(self):
        minperstatus = self._minperstatus
        if minperstatus &lt; 0:
            self.next_open()
        elif minperstatus == 0:
            self.nextstart_open()  # only called for the 1st value
        else:
            self.prenext_open()

    def _oncepost(self, dt):
        for indicator in self._lineiterators[LineIterator.IndType]:
            if len(indicator._clock) &gt; len(indicator):
                indicator.advance()

        if self._oldsync:
            # Strategy has not been reset, the line is there
            self.advance()
        else:
            # strategy has been reset to beginning. advance step by step
            self.forward()

        self.lines.datetime[0] = dt
        self._notify()

        minperstatus = self._getminperstatus()
        if minperstatus &lt; 0:
            self.next()
        elif minperstatus == 0:
            self.nextstart()  # only called for the 1st value
        else:
            self.prenext()

        self._next_analyzers(minperstatus, once=True)
        self._next_observers(minperstatus, once=True)

        self.clear()

    def _clk_update(self):
        if self._oldsync:
            clk_len = super(Strategy, self)._clk_update()
            self.lines.datetime[0] = max(d.datetime[0]
                                         for d in self.datas if len(d))
            return clk_len

        newdlens = [len(d) for d in self.datas]
        if any(nl &gt; l for l, nl in zip(self._dlens, newdlens)):
            self.forward()

        self.lines.datetime[0] = max(d.datetime[0]
                                     for d in self.datas if len(d))
        self._dlens = newdlens

        return len(self)

    def _next_open(self):
        minperstatus = self._minperstatus
        if minperstatus &lt; 0:
            self.next_open()
        elif minperstatus == 0:
            self.nextstart_open()  # only called for the 1st value
        else:
            self.prenext_open()

    def _next(self):
        super(Strategy, self)._next()

        minperstatus = self._getminperstatus()
        self._next_analyzers(minperstatus)
        self._next_observers(minperstatus)

        self.clear()

    def _next_observers(self, minperstatus, once=False):
        for observer in self._lineiterators[LineIterator.ObsType]:
            for analyzer in observer._analyzers:
                if minperstatus &lt; 0:
                    analyzer._next()
                elif minperstatus == 0:
                    analyzer._nextstart()  # only called for the 1st value
                else:
                    analyzer._prenext()

            if once:
                if len(self) &gt; len(observer):
                    if self._oldsync:
                        observer.advance()
                    else:
                        observer.forward()

                if minperstatus &lt; 0:
                    observer.next()
                elif minperstatus == 0:
                    observer.nextstart()  # only called for the 1st value
                elif len(observer):
                    observer.prenext()
            else:
                observer._next()

    def _next_analyzers(self, minperstatus, once=False):
        for analyzer in self.analyzers:
            if minperstatus &lt; 0:
                analyzer._next()
            elif minperstatus == 0:
                analyzer._nextstart()  # only called for the 1st value
            else:
                analyzer._prenext()

    def _settz(self, tz):
        self.lines.datetime._settz(tz)

    def _start(self):
        self._periodset()

        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._start()

        for obs in self.observers:
            if not isinstance(obs, list):
                obs = [obs]  # support of multi-data observers

            for o in obs:
                o._start()

        # change operators to stage 2
        self._stage2()

        self._dlens = [len(data) for data in self.datas]

        self._minperstatus = MAXINT  # start in prenext

        self.start()

    def start(self):
        &#39;&#39;&#39;Called right before the backtesting is about to be started.&#39;&#39;&#39;
        pass

    def getwriterheaders(self):
        self.indobscsv = [self]

        indobs = itertools.chain(
            self.getindicators_lines(), self.getobservers())
        self.indobscsv.extend(filter(lambda x: x.csv, indobs))

        headers = list()

        # prepare the indicators/observers data headers
        for iocsv in self.indobscsv:
            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
            headers.append(name)
            headers.append(&#39;len&#39;)
            headers.extend(iocsv.getlinealiases())

        return headers

    def getwritervalues(self):
        values = list()

        for iocsv in self.indobscsv:
            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
            values.append(name)
            lio = len(iocsv)
            values.append(lio)
            if lio:
                values.extend(map(lambda l: l[0], iocsv.lines.itersize()))
            else:
                values.extend([&#39;&#39;] * iocsv.lines.size())

        return values

    def getwriterinfo(self):
        wrinfo = AutoOrderedDict()

        wrinfo[&#39;Params&#39;] = self.p._getkwargs()

        sections = [
            [&#39;Indicators&#39;, self.getindicators_lines()],
            [&#39;Observers&#39;, self.getobservers()]
        ]

        for sectname, sectitems in sections:
            sinfo = wrinfo[sectname]
            for item in sectitems:
                itname = item.__class__.__name__
                sinfo[itname].Lines = item.lines.getlinealiases() or None
                sinfo[itname].Params = item.p._getkwargs() or None

        ainfo = wrinfo.Analyzers

        # Internal Value Analyzer
        ainfo.Value.Begin = self.broker.startingcash
        ainfo.Value.End = self.broker.getvalue()

        # no slave analyzers for writer
        for aname, analyzer in self.analyzers.getitems():
            ainfo[aname].Params = analyzer.p._getkwargs() or None
            ainfo[aname].Analysis = analyzer.get_analysis()

        return wrinfo

    def _stop(self):
        self.stop()

        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._stop()

        # change operators back to stage 1 - allows reuse of datas
        self._stage1()

    def stop(self):
        &#39;&#39;&#39;Called right before the backtesting is about to be stopped&#39;&#39;&#39;
        pass

    def set_tradehistory(self, onoff=True):
        self._tradehistoryon = onoff

    def clear(self):
        self._orders.extend(self._orderspending)
        self._orderspending = list()
        self._tradespending = list()

    def _addnotification(self, order, quicknotify=False):
        if not order.p.simulated:
            self._orderspending.append(order)

        if quicknotify:
            qorders = [order]
            qtrades = []

        if not order.executed.size:
            if quicknotify:
                self._notify(qorders=qorders, qtrades=qtrades)
            return

        tradedata = order.data._compensate
        if tradedata is None:
            tradedata = order.data

        datatrades = self._trades[tradedata][order.tradeid]
        if not datatrades:
            trade = Trade(data=tradedata, tradeid=order.tradeid,
                          historyon=self._tradehistoryon)
            datatrades.append(trade)
        else:
            trade = datatrades[-1]

        for exbit in order.executed.iterpending():
            if exbit is None:
                break

            if exbit.closed:
                trade.update(order,
                             exbit.closed,
                             exbit.price,
                             exbit.closedvalue,
                             exbit.closedcomm,
                             exbit.pnl,
                             comminfo=order.comminfo)

                if trade.isclosed:
                    self._tradespending.append(copy.copy(trade))
                    if quicknotify:
                        qtrades.append(copy.copy(trade))

            # Update it if needed
            if exbit.opened:
                if trade.isclosed:
                    trade = Trade(data=tradedata, tradeid=order.tradeid,
                                  historyon=self._tradehistoryon)
                    datatrades.append(trade)

                trade.update(order,
                             exbit.opened,
                             exbit.price,
                             exbit.openedvalue,
                             exbit.openedcomm,
                             exbit.pnl,
                             comminfo=order.comminfo)

                # This extra check covers the case in which different tradeid
                # orders have put the position down to 0 and the next order
                # &#34;opens&#34; a position but &#34;closes&#34; the trade
                if trade.isclosed:
                    self._tradespending.append(copy.copy(trade))
                    if quicknotify:
                        qtrades.append(copy.copy(trade))

            if trade.justopened:
                self._tradespending.append(copy.copy(trade))
                if quicknotify:
                    qtrades.append(copy.copy(trade))

        if quicknotify:
            self._notify(qorders=qorders, qtrades=qtrades)

    def _notify(self, qorders=[], qtrades=[]):
        if self.cerebro.p.quicknotify:
            # need to know if quicknotify is on, to not reprocess pendingorders
            # and pendingtrades, which have to exist for things like observers
            # which look into it
            procorders = qorders
            proctrades = qtrades
        else:
            procorders = self._orderspending
            proctrades = self._tradespending

        for order in procorders:
            if order.exectype != order.Historical or order.histnotify:
                self.notify_order(order)
            for analyzer in itertools.chain(self.analyzers,
                                            self._slave_analyzers):
                analyzer._notify_order(order)

        for trade in proctrades:
            self.notify_trade(trade)
            for analyzer in itertools.chain(self.analyzers,
                                            self._slave_analyzers):
                analyzer._notify_trade(trade)

        if qorders:
            return  # cash is notified on a regular basis

        cash = self.broker.getcash()
        value = self.broker.getvalue()
        fundvalue = self.broker.fundvalue
        fundshares = self.broker.fundshares

        self.notify_cashvalue(cash, value)
        self.notify_fund(cash, value, fundvalue, fundshares)
        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._notify_cashvalue(cash, value)
            analyzer._notify_fund(cash, value, fundvalue, fundshares)

    def add_timer(self, when,
                  offset=datetime.timedelta(), repeat=datetime.timedelta(),
                  weekdays=[], weekcarry=False,
                  monthdays=[], monthcarry=True,
                  allow=None,
                  tzdata=None, cheat=False,
                  *args, **kwargs):
        &#39;&#39;&#39;
        **Note**: can be called during ``__init__`` or ``start``

        Schedules a timer to invoke either a specified callback or the
        ``notify_timer`` of one or more strategies.

        Arguments:

          - ``when``: can be

            - ``datetime.time`` instance (see below ``tzdata``)
            - ``bt.timer.SESSION_START`` to reference a session start
            - ``bt.timer.SESSION_END`` to reference a session end

         - ``offset`` which must be a ``datetime.timedelta`` instance

           Used to offset the value ``when``. It has a meaningful use in
           combination with ``SESSION_START`` and ``SESSION_END``, to indicated
           things like a timer being called ``15 minutes`` after the session
           start.

          - ``repeat`` which must be a ``datetime.timedelta`` instance

            Indicates if after a 1st call, further calls will be scheduled
            within the same session at the scheduled ``repeat`` delta

            Once the timer goes over the end of the session it is reset to the
            original value for ``when``

          - ``weekdays``: a **sorted** iterable with integers indicating on
            which days (iso codes, Monday is 1, Sunday is 7) the timers can
            be actually invoked

            If not specified, the timer will be active on all days

          - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
            not seen (ex: trading holiday), the timer will be executed on the
            next day (even if in a new week)

          - ``monthdays``: a **sorted** iterable with integers indicating on
            which days of the month a timer has to be executed. For example
            always on day *15* of the month

            If not specified, the timer will be active on all days

          - ``monthcarry`` (default: ``True``). If the day was not seen
            (weekend, trading holiday), the timer will be executed on the next
            available day.

          - ``allow`` (default: ``None``). A callback which receives a
            `datetime.date`` instance and returns ``True`` if the date is
            allowed for timers or else returns ``False``

          - ``tzdata`` which can be either ``None`` (default), a ``pytz``
            instance or a ``data feed`` instance.

            ``None``: ``when`` is interpreted at face value (which translates
            to handling it as if it where UTC even if it&#39;s not)

            ``pytz`` instance: ``when`` will be interpreted as being specified
            in the local time specified by the timezone instance.

            ``data feed`` instance: ``when`` will be interpreted as being
            specified in the local time specified by the ``tz`` parameter of
            the data feed instance.

            **Note**: If ``when`` is either ``SESSION_START`` or
              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
              in the system (aka ``self.data0``) will be used as the reference
              to find out the session times.

          - ``cheat`` (default ``False``) if ``True`` the timer will be called
            before the broker has a chance to evaluate the orders. This opens
            the chance to issue orders based on opening price for example right
            before the session starts

          - ``*args``: any extra args will be passed to ``notify_timer``

          - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

        Return Value:

          - The created timer

        &#39;&#39;&#39;
        return self.cerebro._add_timer(
            owner=self, when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, strats=False, cheat=cheat,
            *args, **kwargs)

    def notify_timer(self, timer, when, *args, **kwargs):
        &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
        returned by ``add_timer``, and ``when`` is the calling time. ``args``
        and ``kwargs`` are any additional arguments passed to ``add_timer``

        The actual ``when`` time can be later, but the system may have not be
        able to call the timer before. This value is the timer value and no the
        system time.
        &#39;&#39;&#39;
        pass

    def notify_cashvalue(self, cash, value):
        &#39;&#39;&#39;
        Receives the current fund value, value status of the strategy&#39;s broker
        &#39;&#39;&#39;
        pass

    def notify_fund(self, cash, value, fundvalue, shares):
        &#39;&#39;&#39;
        Receives the current cash, value, fundvalue and fund shares
        &#39;&#39;&#39;
        pass

    def notify_order(self, order):
        &#39;&#39;&#39;
        Receives an order whenever there has been a change in one
        &#39;&#39;&#39;
        pass

    def notify_trade(self, trade):
        &#39;&#39;&#39;
        Receives a trade whenever there has been a change in one
        &#39;&#39;&#39;
        pass

    def notify_store(self, msg, *args, **kwargs):
        &#39;&#39;&#39;Receives a notification from a store provider&#39;&#39;&#39;
        pass

    def notify_data(self, data, status, *args, **kwargs):
        &#39;&#39;&#39;Receives a notification from data&#39;&#39;&#39;
        pass

    def getdatanames(self):
        &#39;&#39;&#39;
        Returns a list of the existing data names
        &#39;&#39;&#39;
        return keys(self.env.datasbyname)

    def getdatabyname(self, name):
        &#39;&#39;&#39;
        Returns a given data by name using the environment (cerebro)
        &#39;&#39;&#39;
        return self.env.datasbyname[name]

    def cancel(self, order):
        &#39;&#39;&#39;Cancels the order in the broker&#39;&#39;&#39;
        self.broker.cancel(order)

    def buy(self, data=None,
            size=None, price=None, plimit=None,
            exectype=None, valid=None, tradeid=0, oco=None,
            trailamount=None, trailpercent=None,
            parent=None, transmit=True,
            **kwargs):
        &#39;&#39;&#39;Create a buy (long) order and send it to the broker

          - ``data`` (default: ``None``)

            For which data the order has to be created. If ``None`` then the
            first data in the system, ``self.datas[0] or self.data0`` (aka
            ``self.data``) will be used

          - ``size`` (default: ``None``)

            Size to use (positive) of units of data to use for the order.

            If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
            be used to determine the size.

          - ``price`` (default: ``None``)

            Price to use (live brokers may place restrictions on the actual
            format if it does not comply to minimum tick size requirements)

            ``None`` is valid for ``Market`` and ``Close`` orders (the market
            determines the price)

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
            determines the trigger point (in the case of ``Limit`` the trigger
            is obviously at which price the order should be matched)

          - ``plimit`` (default: ``None``)

            Only applicable to ``StopLimit`` orders. This is the price at which
            to set the implicit *Limit* order, once the *Stop* has been
            triggered (for which ``price`` has been used)

          - ``trailamount`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is an
            absolute amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop

          - ``trailpercent`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is a
            percentage amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop (if ``trailamount`` is also specified it will be used)

          - ``exectype`` (default: ``None``)

            Possible values:

            - ``Order.Market`` or ``None``. A market order will be executed
              with the next available price. In backtesting it will be the
              opening price of the next bar

            - ``Order.Limit``. An order which can only be executed at the given
              ``price`` or better

            - ``Order.Stop``. An order which is triggered at ``price`` and
              executed like an ``Order.Market`` order

            - ``Order.StopLimit``. An order which is triggered at ``price`` and
              executed as an implicit *Limit* order with price given by
              ``pricelimit``

            - ``Order.Close``. An order which can only be executed with the
              closing price of the session (usually during a closing auction)

            - ``Order.StopTrail``. An order which is triggered at ``price``
              minus ``trailamount`` (or ``trailpercent``) and which is updated
              if the price moves away from the stop

            - ``Order.StopTrailLimit``. An order which is triggered at
              ``price`` minus ``trailamount`` (or ``trailpercent``) and which
              is updated if the price moves away from the stop

          - ``valid`` (default: ``None``)

            Possible values:

              - ``None``: this generates an order that will not expire (aka
                *Good till cancel*) and remain in the market until matched or
                canceled. In reality brokers tend to impose a temporal limit,
                but this is usually so far away in time to consider it as not
                expiring

              - ``datetime.datetime`` or ``datetime.date`` instance: the date
                will be used to generate an order valid until the given
                datetime (aka *good till date*)

              - ``Order.DAY`` or ``0`` or ``timedelta()``: a day valid until
                the *End of the Session* (aka *day* order) will be generated

              - ``numeric value``: This is assumed to be a value corresponding
                to a datetime in ``matplotlib`` coding (the one used by
                ``backtrader``) and will used to generate an order valid until
                that time (*good till date*)

          - ``tradeid`` (default: ``0``)

            This is an internal value applied by ``backtrader`` to keep track
            of overlapping trades on the same asset. This ``tradeid`` is sent
            back to the *strategy* when notifying changes to the status of the
            orders.

          - ``oco`` (default: ``None``)

            Another ``order`` instance. This order will become part of an OCO
            (Order Cancel Others) group. The execution of one of the orders,
            immediately cancels all others in the same group

          - ``parent`` (default: ``None``)

            Controls the relationship of a group of orders, for example a buy
            which is bracketed by a high-side limit sell and a low side stop
            sell. The high/low side orders remain inactive until the parent
            order has been either executed (they become active) or is
            canceled/expires (the children are also canceled) bracket orders
            have the same size

          - ``transmit`` (default: ``True``)

            Indicates if the order has to be **transmitted**, ie: not only
            placed in the broker but also issued. This is meant for example to
            control bracket orders, in which one disables the transmission for
            the parent and 1st set of children and activates it for the last
            children, which triggers the full placement of all bracket orders.

          - ``**kwargs``: additional broker implementations may support extra
            parameters. ``backtrader`` will pass the *kwargs* down to the
            created order objects

            Example: if the 4 order execution types directly supported by
            ``backtrader`` are not enough, in the case of for example
            *Interactive Brokers* the following could be passed as *kwargs*::

              orderType=&#39;LIT&#39;, lmtPrice=10.0, auxPrice=9.8

            This would override the settings created by ``backtrader`` and
            generate a ``LIMIT IF TOUCHED`` order with a *touched* price of 9.8
            and a *limit* price of 10.0.

        Returns:
          - the submitted order

        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)

        data = data if data is not None else self.datas[0]
        size = size if size is not None else self.getsizing(data, isbuy=True)

        if size:
            return self.broker.buy(
                self, data,
                size=abs(size), price=price, plimit=plimit,
                exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
                trailamount=trailamount, trailpercent=trailpercent,
                parent=parent, transmit=transmit,
                **kwargs)

        return None

    def sell(self, data=None,
             size=None, price=None, plimit=None,
             exectype=None, valid=None, tradeid=0, oco=None,
             trailamount=None, trailpercent=None,
             parent=None, transmit=True,
             **kwargs):
        &#39;&#39;&#39;
        To create a selll (short) order and send it to the broker

        See the documentation for ``buy`` for an explanation of the parameters

        Returns: the submitted order
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)

        data = data if data is not None else self.datas[0]
        size = size if size is not None else self.getsizing(data, isbuy=False)

        if size:
            return self.broker.sell(
                self, data,
                size=abs(size), price=price, plimit=plimit,
                exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
                trailamount=trailamount, trailpercent=trailpercent,
                parent=parent, transmit=transmit,
                **kwargs)

        return None

    def close(self, data=None, size=None, **kwargs):
        &#39;&#39;&#39;
        Counters a long/short position closing it

        See the documentation for ``buy`` for an explanation of the parameters

        Note:

          - ``size``: automatically calculated from the existing position if
            not provided (default: ``None``) by the caller

        Returns: the submitted order
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        size = abs(size if size is not None else possize)

        if possize &gt; 0:
            return self.sell(data=data, size=size, **kwargs)
        elif possize &lt; 0:
            return self.buy(data=data, size=size, **kwargs)

        return None

    def buy_bracket(self, data=None, size=None, price=None, plimit=None,
                    exectype=bt.Order.Limit, valid=None, tradeid=0,
                    trailamount=None, trailpercent=None, oargs={},
                    stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                    limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                    **kwargs):
        &#39;&#39;&#39;
        Create a bracket order group (low side - buy order - high side). The
        default behavior is as follows:

          - Issue a **buy** order with execution ``Limit``

          - Issue a *low side* bracket **sell** order with execution ``Stop``

          - Issue a *high side* bracket **sell** order with execution
            ``Limit``.

        See below for the different parameters

          - ``data`` (default: ``None``)

            For which data the order has to be created. If ``None`` then the
            first data in the system, ``self.datas[0] or self.data0`` (aka
            ``self.data``) will be used

          - ``size`` (default: ``None``)

            Size to use (positive) of units of data to use for the order.

            If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
            be used to determine the size.

            **Note**: The same size is applied to all 3 orders of the bracket

          - ``price`` (default: ``None``)

            Price to use (live brokers may place restrictions on the actual
            format if it does not comply to minimum tick size requirements)

            ``None`` is valid for ``Market`` and ``Close`` orders (the market
            determines the price)

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
            determines the trigger point (in the case of ``Limit`` the trigger
            is obviously at which price the order should be matched)

          - ``plimit`` (default: ``None``)

            Only applicable to ``StopLimit`` orders. This is the price at which
            to set the implicit *Limit* order, once the *Stop* has been
            triggered (for which ``price`` has been used)

          - ``trailamount`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is an
            absolute amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop

          - ``trailpercent`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is a
            percentage amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop (if ``trailamount`` is also specified it will be used)

          - ``exectype`` (default: ``bt.Order.Limit``)

            Possible values: (see the documentation for the method ``buy``

          - ``valid`` (default: ``None``)

            Possible values: (see the documentation for the method ``buy``

          - ``tradeid`` (default: ``0``)

            Possible values: (see the documentation for the method ``buy``

          - ``oargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the main side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

          - ``**kwargs``: additional broker implementations may support extra
            parameters. ``backtrader`` will pass the *kwargs* down to the
            created order objects

            Possible values: (see the documentation for the method ``buy``

            **Note**: this ``kwargs`` will be applied to the 3 orders of a
            bracket. See below for specific keyword arguments for the low and
            high side orders

          - ``stopprice`` (default: ``None``)

            Specific price for the *low side* stop order

          - ``stopexec`` (default: ``bt.Order.Stop``)

            Specific execution type for the *low side* order

          - ``stopargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the low side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

          - ``limitprice`` (default: ``None``)

            Specific price for the *high side* stop order

          - ``stopexec`` (default: ``bt.Order.Limit``)

            Specific execution type for the *high side* order

          - ``limitargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the high side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

        High/Low Side orders can be suppressed by using:

          - ``limitexec=None`` to suppress the *high side*

          - ``stopexec=None`` to suppress the *low side*

        Returns:

          - A list containing the 3 orders [order, stop side, limit side]

          - If high/low orders have been suppressed the return value will still
            contain 3 orders, but those suppressed will have a value of
            ``None``
        &#39;&#39;&#39;

        kargs = dict(size=size,
                     data=data, price=price, plimit=plimit, exectype=exectype,
                     valid=valid, tradeid=tradeid,
                     trailamount=trailamount, trailpercent=trailpercent)
        kargs.update(oargs)
        kargs.update(kwargs)
        kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
        o = self.buy(**kargs)

        if stopexec is not None:
            # low side / stop
            kargs = dict(data=data, price=stopprice, exectype=stopexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(stopargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = limitexec is None
            kargs[&#39;size&#39;] = o.size
            ostop = self.sell(**kargs)
        else:
            ostop = None

        if limitexec is not None:
            # high side / limit
            kargs = dict(data=data, price=limitprice, exectype=limitexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(limitargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = True
            kargs[&#39;size&#39;] = o.size
            olimit = self.sell(**kargs)
        else:
            olimit = None

        return [o, ostop, olimit]

    def sell_bracket(self, data=None,
                     size=None, price=None, plimit=None,
                     exectype=bt.Order.Limit, valid=None, tradeid=0,
                     trailamount=None, trailpercent=None,
                     oargs={},
                     stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                     limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                     **kwargs):
        &#39;&#39;&#39;
        Create a bracket order group (low side - buy order - high side). The
        default behavior is as follows:

          - Issue a **sell** order with execution ``Limit``

          - Issue a *high side* bracket **buy** order with execution ``Stop``

          - Issue a *low side* bracket **buy** order with execution ``Limit``.

        See ``bracket_buy`` for the meaning of the parameters

        High/Low Side orders can be suppressed by using:

          - ``stopexec=None`` to suppress the *high side*

          - ``limitexec=None`` to suppress the *low side*

        Returns:

          - A list containing the 3 orders [order, stop side, limit side]

          - If high/low orders have been suppressed the return value will still
            contain 3 orders, but those suppressed will have a value of
            ``None``
        &#39;&#39;&#39;

        kargs = dict(size=size,
                     data=data, price=price, plimit=plimit, exectype=exectype,
                     valid=valid, tradeid=tradeid,
                     trailamount=trailamount, trailpercent=trailpercent)
        kargs.update(oargs)
        kargs.update(kwargs)
        kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
        o = self.sell(**kargs)

        if stopexec is not None:
            # high side / stop
            kargs = dict(data=data, price=stopprice, exectype=stopexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(stopargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = limitexec is None  # transmit if last
            kargs[&#39;size&#39;] = o.size
            ostop = self.buy(**kargs)
        else:
            ostop = None

        if limitexec is not None:
            # low side / limit
            kargs = dict(data=data, price=limitprice, exectype=limitexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(limitargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = True
            kargs[&#39;size&#39;] = o.size
            olimit = self.buy(**kargs)
        else:
            olimit = None

        return [o, ostop, olimit]

    def order_target_size(self, data=None, target=0, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final size of ``target``

        The current ``position`` size is taken into account as the start point
        to achieve ``target``

          - If ``target`` &gt; ``pos.size`` -&gt; buy ``target - pos.size``

          - If ``target`` &lt; ``pos.size`` -&gt; sell ``pos.size - target``

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued (``target == position.size``)
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        if not target and possize:
            return self.close(data=data, size=possize, **kwargs)

        elif target &gt; possize:
            return self.buy(data=data, size=target - possize, **kwargs)

        elif target &lt; possize:
            return self.sell(data=data, size=possize - target, **kwargs)

        return None  # no execution target == possize

    def order_target_value(self, data=None, target=0.0, price=None, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final value of
        ``target``

        The current ``value`` is taken into account as the start point to
        achieve ``target``

          - If no ``target`` then close postion on data
          - If ``target`` &gt; ``value`` then buy on data
          - If ``target`` &lt; ``value`` then sell on data

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued
        &#39;&#39;&#39;

        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        if not target and possize:  # closing a position
            return self.close(data=data, size=possize, price=price, **kwargs)

        else:
            value = self.broker.getvalue(datas=[data])
            comminfo = self.broker.getcommissioninfo(data)

            # Make sure a price is there
            price = price if price is not None else data.close[0]

            if target &gt; value:
                size = comminfo.getsize(price, target - value)
                return self.buy(data=data, size=size, price=price, **kwargs)

            elif target &lt; value:
                size = comminfo.getsize(price, value - target)
                return self.sell(data=data, size=size, price=price, **kwargs)

        return None  # no execution size == possize

    def order_target_percent(self, data=None, target=0.0, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final value of
        ``target`` percentage of current portfolio ``value``

        ``target`` is expressed in decimal: ``0.05`` -&gt; ``5%``

        It uses ``order_target_value`` to execute the order.

        Example:
          - ``target=0.05`` and portfolio value is ``100``

          - The ``value`` to be reached is ``0.05 * 100 = 5``

          - ``5`` is passed as the ``target`` value to ``order_target_value``

        The current ``value`` is taken into account as the start point to
        achieve ``target``

        The ``position.size`` is used to determine if a position is ``long`` /
        ``short``

          - If ``target`` &gt; ``value``
            - buy if ``pos.size &gt;= 0`` (Increase a long position)
            - sell if ``pos.size &lt; 0`` (Increase a short position)

          - If ``target`` &lt; ``value``
            - sell if ``pos.size &gt;= 0`` (Decrease a long position)
            - buy if ``pos.size &lt; 0`` (Decrease a short position)

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued (``target == position.size``)
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        target *= self.broker.getvalue()

        return self.order_target_value(data=data, target=target, **kwargs)

    def getposition(self, data=None, broker=None):
        &#39;&#39;&#39;
        Returns the current position for a given data in a given broker.

        If both are None, the main data and the default broker will be used

        A property ``position`` is also available
        &#39;&#39;&#39;
        data = data if data is not None else self.datas[0]
        broker = broker or self.broker
        return broker.getposition(data)

    position = property(getposition)

    def getpositionbyname(self, name=None, broker=None):
        &#39;&#39;&#39;
        Returns the current position for a given name in a given broker.

        If both are None, the main data and the default broker will be used

        A property ``positionbyname`` is also available
        &#39;&#39;&#39;
        data = self.datas[0] if not name else self.getdatabyname(name)
        broker = broker or self.broker
        return broker.getposition(data)

    positionbyname = property(getpositionbyname)

    def getpositions(self, broker=None):
        &#39;&#39;&#39;
        Returns the current by data positions directly from the broker

        If the given ``broker`` is None, the default broker will be used

        A property ``positions`` is also available
        &#39;&#39;&#39;
        broker = broker or self.broker
        return broker.positions

    positions = property(getpositions)

    def getpositionsbyname(self, broker=None):
        &#39;&#39;&#39;
        Returns the current by name positions directly from the broker

        If the given ``broker`` is None, the default broker will be used

        A property ``positionsbyname`` is also available
        &#39;&#39;&#39;
        broker = broker or self.broker
        positions = broker.positions

        posbyname = collections.OrderedDict()
        for name, data in iteritems(self.env.datasbyname):
            posbyname[name] = positions[data]

        return posbyname

    positionsbyname = property(getpositionsbyname)

    def _addsizer(self, sizer, *args, **kwargs):
        if sizer is None:
            self.setsizer(bt.sizers.FixedSize())
        else:
            self.setsizer(sizer(*args, **kwargs))

    def setsizer(self, sizer):
        &#39;&#39;&#39;
        Replace the default (fixed stake) sizer
        &#39;&#39;&#39;
        self._sizer = sizer
        sizer.set(self, self.broker)
        return sizer

    def getsizer(self):
        &#39;&#39;&#39;
        Returns the sizer which is in used if automatic statke calculation is
        used

        Also available as ``sizer``
        &#39;&#39;&#39;
        return self._sizer

    sizer = property(getsizer, setsizer)

    def getsizing(self, data=None, isbuy=True):
        &#39;&#39;&#39;
        Return the stake calculated by the sizer instance for the current
        situation
        &#39;&#39;&#39;
        data = data if data is not None else self.datas[0]
        return self._sizer.getsizing(data, isbuy=isbuy)


class MetaSigStrategy(Strategy.__class__):

    def __new__(meta, name, bases, dct):
        # map user defined next to custom to be able to call own method before
        if &#39;next&#39; in dct:
            dct[&#39;_next_custom&#39;] = dct.pop(&#39;next&#39;)

        cls = super(MetaSigStrategy, meta).__new__(meta, name, bases, dct)

        # after class creation remap _next_catch to be next
        cls.next = cls._next_catch
        return cls

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaSigStrategy, cls).dopreinit(_obj, *args, **kwargs)

        _obj._signals = collections.defaultdict(list)

        _data = _obj.p._data
        if _data is None:
            _obj._dtarget = _obj.data0
        elif isinstance(_data, integer_types):
            _obj._dtarget = _obj.datas[_data]
        elif isinstance(_data, string_types):
            _obj._dtarget = _obj.getdatabyname(_data)
        elif isinstance(_data, bt.LineRoot):
            _obj._dtarget = _data
        else:
            _obj._dtarget = _obj.data0

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaSigStrategy, cls).dopostinit(_obj, *args, **kwargs)

        for sigtype, sigcls, sigargs, sigkwargs in _obj.p.signals:
            _obj._signals[sigtype].append(sigcls(*sigargs, **sigkwargs))

        # Record types of signals
        _obj._longshort = bool(_obj._signals[bt.SIGNAL_LONGSHORT])

        _obj._long = bool(_obj._signals[bt.SIGNAL_LONG])
        _obj._short = bool(_obj._signals[bt.SIGNAL_SHORT])

        _obj._longexit = bool(_obj._signals[bt.SIGNAL_LONGEXIT])
        _obj._shortexit = bool(_obj._signals[bt.SIGNAL_SHORTEXIT])

        return _obj, args, kwargs


class SignalStrategy(with_metaclass(MetaSigStrategy, Strategy)):
    &#39;&#39;&#39;This subclass of ``Strategy`` is meant to to auto-operate using
    **signals**.

    *Signals* are usually indicators and the expected output values:

      - ``&gt; 0`` is a ``long`` indication

      - ``&lt; 0`` is a ``short`` indication

    There are 5 types of *Signals*, broken in 2 groups.

    **Main Group**:

      - ``LONGSHORT``: both ``long`` and ``short`` indications from this signal
        are taken

      - ``LONG``:
        - ``long`` indications are taken to go long
        - ``short`` indications are taken to *close* the long position. But:

          - If a ``LONGEXIT`` (see below) signal is in the system it will be
            used to exit the long

          - If a ``SHORT`` signal is available and no ``LONGEXIT`` is available
            , it will be used to close a ``long`` before opening a ``short``

      - ``SHORT``:
        - ``short`` indications are taken to go short
        - ``long`` indications are taken to *close* the short position. But:

          - If a ``SHORTEXIT`` (see below) signal is in the system it will be
            used to exit the short

          - If a ``LONG`` signal is available and no ``SHORTEXIT`` is available
            , it will be used to close a ``short`` before opening a ``long``

    **Exit Group**:

      This 2 signals are meant to override others and provide criteria for
      exitins a ``long``/``short`` position

      - ``LONGEXIT``: ``short`` indications are taken to exit ``long``
        positions

      - ``SHORTEXIT``: ``long`` indications are taken to exit ``short``
        positions

    **Order Issuing**

      Orders execution type is ``Market`` and validity is ``None`` (*Good until
      Canceled*)

    Params:

      - ``signals`` (default: ``[]``): a list/tuple of lists/tuples that allows
        the instantiation of the signals and allocation to the right type

        This parameter is expected to be managed through ``cerebro.add_signal``

      - ``_accumulate`` (default: ``False``): allow to enter the market
        (long/short) even if already in the market

      - ``_concurrent`` (default: ``False``): allow orders to be issued even if
        orders are already pending execution

      - ``_data`` (default: ``None``): if multiple datas are present in the
        system which is the target for orders. This can be

        - ``None``: The first data in the system will be used

        - An ``int``: indicating the data that was inserted at that position

        - An ``str``: name given to the data when creating it (parameter
          ``name``) or when adding it cerebro with ``cerebro.adddata(...,
          name=)``

        - A ``data`` instance

    &#39;&#39;&#39;

    params = (
        (&#39;signals&#39;, []),
        (&#39;_accumulate&#39;, False),
        (&#39;_concurrent&#39;, False),
        (&#39;_data&#39;, None),
    )

    def _start(self):
        self._sentinel = None  # sentinel for order concurrency
        super(SignalStrategy, self)._start()

    def signal_add(self, sigtype, signal):
        self._signals[sigtype].append(signal)

    def _notify(self, qorders=[], qtrades=[]):
        # Nullify the sentinel if done
        procorders = qorders or self._orderspending
        if self._sentinel is not None:
            for order in procorders:
                if order == self._sentinel and not order.alive():
                    self._sentinel = None
                    break

        super(SignalStrategy, self)._notify(qorders=qorders, qtrades=qtrades)

    def _next_catch(self):
        self._next_signal()
        if hasattr(self, &#39;_next_custom&#39;):
            self._next_custom()

    def _next_signal(self):
        if self._sentinel is not None and not self.p._concurrent:
            return  # order active and more than 1 not allowed

        sigs = self._signals
        nosig = [[0.0]]

        # Calculate current status of the signals
        ls_long = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONGSHORT] or nosig)
        ls_short = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONGSHORT] or nosig)

        l_enter0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONG] or nosig)
        l_enter1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or nosig)
        l_enter2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or nosig)
        l_enter = l_enter0 or l_enter1 or l_enter2

        s_enter0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORT] or nosig)
        s_enter1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORT_INV] or nosig)
        s_enter2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or nosig)
        s_enter = s_enter0 or s_enter1 or s_enter2

        l_ex0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONGEXIT] or nosig)
        l_ex1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONGEXIT_INV] or nosig)
        l_ex2 = all(x[0] for x in sigs[bt.SIGNAL_LONGEXIT_ANY] or nosig)
        l_exit = l_ex0 or l_ex1 or l_ex2

        s_ex0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT] or nosig)
        s_ex1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT_INV] or nosig)
        s_ex2 = all(x[0] for x in sigs[bt.SIGNAL_SHORTEXIT_ANY] or nosig)
        s_exit = s_ex0 or s_ex1 or s_ex2

        # Use oppossite signales to start reversal (by closing)
        # but only if no &#34;xxxExit&#34; exists
        l_rev = not self._longexit and s_enter
        s_rev = not self._shortexit and l_enter

        # Opposite of individual long and short
        l_leav0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONG] or nosig)
        l_leav1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or nosig)
        l_leav2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or nosig)
        l_leave = l_leav0 or l_leav1 or l_leav2

        s_leav0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORT] or nosig)
        s_leav1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORT_INV] or nosig)
        s_leav2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or nosig)
        s_leave = s_leav0 or s_leav1 or s_leav2

        # Invalidate long leave if longexit signals are available
        l_leave = not self._longexit and l_leave
        # Invalidate short leave if shortexit signals are available
        s_leave = not self._shortexit and s_leave

        # Take size and start logic
        size = self.getposition(self._dtarget).size
        if not size:
            if ls_long or l_enter:
                self._sentinel = self.buy(self._dtarget)

            elif ls_short or s_enter:
                self._sentinel = self.sell(self._dtarget)

        elif size &gt; 0:  # current long position
            if ls_short or l_exit or l_rev or l_leave:
                # closing position - not relevant for concurrency
                self.close(self._dtarget)

            if ls_short or l_rev:
                self._sentinel = self.sell(self._dtarget)

            if ls_long or l_enter:
                if self.p._accumulate:
                    self._sentinel = self.buy(self._dtarget)

        elif size &lt; 0:  # current short position
            if ls_long or s_exit or s_rev or s_leave:
                # closing position - not relevant for concurrency
                self.close(self._dtarget)

            if ls_long or s_rev:
                self._sentinel = self.buy(self._dtarget)

            if ls_short or s_enter:
                if self.p._accumulate:
                    self._sentinel = self.sell(self._dtarget)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="backtrader.strategy.MetaSigStrategy"><code class="flex name class">
<span>class <span class="ident">MetaSigStrategy</span></span>
<span>(</span><span>name, bases, dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Dirty job manager for a LineSeries</p>
<ul>
<li>
<p>During <strong>new</strong> (class creation), it reads "lines", "plotinfo",
"plotlines" class variable definitions and turns them into
Classes of type Lines or AutoClassInfo (plotinfo/plotlines)</p>
</li>
<li>
<p>During "new" (instance creation) the lines/plotinfo/plotlines
classes are substituted in the instance with instances of the
aforementioned classes and aliases are added for the "lines" held
in the "lines" instance</p>
<p>Additionally and for remaining kwargs, these are matched against
args in plotinfo and if existent are set there and removed from kwargs</p>
<p>Remember that this Metaclass has a MetaParams (from metabase)
as root class and therefore "params" defined for the class have been
removed from kwargs at an earlier state</p>
</li>
</ul>
<p>Class has already been created &hellip; register subclasses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaSigStrategy(Strategy.__class__):

    def __new__(meta, name, bases, dct):
        # map user defined next to custom to be able to call own method before
        if &#39;next&#39; in dct:
            dct[&#39;_next_custom&#39;] = dct.pop(&#39;next&#39;)

        cls = super(MetaSigStrategy, meta).__new__(meta, name, bases, dct)

        # after class creation remap _next_catch to be next
        cls.next = cls._next_catch
        return cls

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaSigStrategy, cls).dopreinit(_obj, *args, **kwargs)

        _obj._signals = collections.defaultdict(list)

        _data = _obj.p._data
        if _data is None:
            _obj._dtarget = _obj.data0
        elif isinstance(_data, integer_types):
            _obj._dtarget = _obj.datas[_data]
        elif isinstance(_data, string_types):
            _obj._dtarget = _obj.getdatabyname(_data)
        elif isinstance(_data, bt.LineRoot):
            _obj._dtarget = _data
        else:
            _obj._dtarget = _obj.data0

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaSigStrategy, cls).dopostinit(_obj, *args, **kwargs)

        for sigtype, sigcls, sigargs, sigkwargs in _obj.p.signals:
            _obj._signals[sigtype].append(sigcls(*sigargs, **sigkwargs))

        # Record types of signals
        _obj._longshort = bool(_obj._signals[bt.SIGNAL_LONGSHORT])

        _obj._long = bool(_obj._signals[bt.SIGNAL_LONG])
        _obj._short = bool(_obj._signals[bt.SIGNAL_SHORT])

        _obj._longexit = bool(_obj._signals[bt.SIGNAL_LONGEXIT])
        _obj._shortexit = bool(_obj._signals[bt.SIGNAL_SHORTEXIT])

        return _obj, args, kwargs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.strategy.MetaStrategy" href="#backtrader.strategy.MetaStrategy">MetaStrategy</a></li>
<li><a title="backtrader.lineiterator.MetaLineIterator" href="lineiterator.html#backtrader.lineiterator.MetaLineIterator">MetaLineIterator</a></li>
<li><a title="backtrader.lineseries.MetaLineSeries" href="lineseries.html#backtrader.lineseries.MetaLineSeries">MetaLineSeries</a></li>
<li><a title="backtrader.lineroot.MetaLineRoot" href="lineroot.html#backtrader.lineroot.MetaLineRoot">MetaLineRoot</a></li>
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backtrader.strategy.MetaSigStrategy.dopostinit"><code class="name flex">
<span>def <span class="ident">dopostinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopostinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaSigStrategy, cls).dopostinit(_obj, *args, **kwargs)

    for sigtype, sigcls, sigargs, sigkwargs in _obj.p.signals:
        _obj._signals[sigtype].append(sigcls(*sigargs, **sigkwargs))

    # Record types of signals
    _obj._longshort = bool(_obj._signals[bt.SIGNAL_LONGSHORT])

    _obj._long = bool(_obj._signals[bt.SIGNAL_LONG])
    _obj._short = bool(_obj._signals[bt.SIGNAL_SHORT])

    _obj._longexit = bool(_obj._signals[bt.SIGNAL_LONGEXIT])
    _obj._shortexit = bool(_obj._signals[bt.SIGNAL_SHORTEXIT])

    return _obj, args, kwargs</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.MetaSigStrategy.dopreinit"><code class="name flex">
<span>def <span class="ident">dopreinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopreinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaSigStrategy, cls).dopreinit(_obj, *args, **kwargs)

    _obj._signals = collections.defaultdict(list)

    _data = _obj.p._data
    if _data is None:
        _obj._dtarget = _obj.data0
    elif isinstance(_data, integer_types):
        _obj._dtarget = _obj.datas[_data]
    elif isinstance(_data, string_types):
        _obj._dtarget = _obj.getdatabyname(_data)
    elif isinstance(_data, bt.LineRoot):
        _obj._dtarget = _data
    else:
        _obj._dtarget = _obj.data0

    return _obj, args, kwargs</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.strategy.MetaStrategy" href="#backtrader.strategy.MetaStrategy">MetaStrategy</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.strategy.MetaStrategy.donew" href="lineseries.html#backtrader.lineseries.MetaLineSeries.donew">donew</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.strategy.MetaStrategy"><code class="flex name class">
<span>class <span class="ident">MetaStrategy</span></span>
<span>(</span><span>name, bases, dct)</span>
</code></dt>
<dd>
<div class="desc"><p>Dirty job manager for a LineSeries</p>
<ul>
<li>
<p>During <strong>new</strong> (class creation), it reads "lines", "plotinfo",
"plotlines" class variable definitions and turns them into
Classes of type Lines or AutoClassInfo (plotinfo/plotlines)</p>
</li>
<li>
<p>During "new" (instance creation) the lines/plotinfo/plotlines
classes are substituted in the instance with instances of the
aforementioned classes and aliases are added for the "lines" held
in the "lines" instance</p>
<p>Additionally and for remaining kwargs, these are matched against
args in plotinfo and if existent are set there and removed from kwargs</p>
<p>Remember that this Metaclass has a MetaParams (from metabase)
as root class and therefore "params" defined for the class have been
removed from kwargs at an earlier state</p>
</li>
</ul>
<p>Class has already been created &hellip; register subclasses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaStrategy(StrategyBase.__class__):
    _indcol = dict()

    def __new__(meta, name, bases, dct):
        # Hack to support original method name for notify_order
        if &#39;notify&#39; in dct:
            # rename &#39;notify&#39; to &#39;notify_order&#39;
            dct[&#39;notify_order&#39;] = dct.pop(&#39;notify&#39;)
        if &#39;notify_operation&#39; in dct:
            # rename &#39;notify&#39; to &#39;notify_order&#39;
            dct[&#39;notify_trade&#39;] = dct.pop(&#39;notify_operation&#39;)

        return super(MetaStrategy, meta).__new__(meta, name, bases, dct)

    def __init__(cls, name, bases, dct):
        &#39;&#39;&#39;
        Class has already been created ... register subclasses
        &#39;&#39;&#39;
        # Initialize the class
        super(MetaStrategy, cls).__init__(name, bases, dct)

        if not cls.aliased and \
           name != &#39;Strategy&#39; and not name.startswith(&#39;_&#39;):
            cls._indcol[name] = cls

    def donew(cls, *args, **kwargs):
        _obj, args, kwargs = super(MetaStrategy, cls).donew(*args, **kwargs)

        # Find the owner and store it
        _obj.env = _obj.cerebro = cerebro = findowner(_obj, bt.Cerebro)
        _obj._id = cerebro._next_stid()

        return _obj, args, kwargs

    def dopreinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaStrategy, cls).dopreinit(_obj, *args, **kwargs)
        _obj.broker = _obj.env.broker
        _obj._sizer = bt.sizers.FixedSize()
        _obj._orders = list()
        _obj._orderspending = list()
        _obj._trades = collections.defaultdict(AutoDictList)
        _obj._tradespending = list()

        _obj.stats = _obj.observers = ItemCollection()
        _obj.analyzers = ItemCollection()
        _obj._alnames = collections.defaultdict(itertools.count)
        _obj.writers = list()

        _obj._slave_analyzers = list()

        _obj._tradehistoryon = False

        return _obj, args, kwargs

    def dopostinit(cls, _obj, *args, **kwargs):
        _obj, args, kwargs = \
            super(MetaStrategy, cls).dopostinit(_obj, *args, **kwargs)

        _obj._sizer.set(_obj, _obj.broker)

        return _obj, args, kwargs</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.MetaLineIterator" href="lineiterator.html#backtrader.lineiterator.MetaLineIterator">MetaLineIterator</a></li>
<li><a title="backtrader.lineseries.MetaLineSeries" href="lineseries.html#backtrader.lineseries.MetaLineSeries">MetaLineSeries</a></li>
<li><a title="backtrader.lineroot.MetaLineRoot" href="lineroot.html#backtrader.lineroot.MetaLineRoot">MetaLineRoot</a></li>
<li><a title="backtrader.metabase.MetaParams" href="metabase.html#backtrader.metabase.MetaParams">MetaParams</a></li>
<li><a title="backtrader.metabase.MetaBase" href="metabase.html#backtrader.metabase.MetaBase">MetaBase</a></li>
<li>builtins.type</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.strategy.MetaSigStrategy" href="#backtrader.strategy.MetaSigStrategy">MetaSigStrategy</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="backtrader.strategy.MetaStrategy.dopostinit"><code class="name flex">
<span>def <span class="ident">dopostinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopostinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaStrategy, cls).dopostinit(_obj, *args, **kwargs)

    _obj._sizer.set(_obj, _obj.broker)

    return _obj, args, kwargs</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.MetaStrategy.dopreinit"><code class="name flex">
<span>def <span class="ident">dopreinit</span></span>(<span>cls, _obj, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dopreinit(cls, _obj, *args, **kwargs):
    _obj, args, kwargs = \
        super(MetaStrategy, cls).dopreinit(_obj, *args, **kwargs)
    _obj.broker = _obj.env.broker
    _obj._sizer = bt.sizers.FixedSize()
    _obj._orders = list()
    _obj._orderspending = list()
    _obj._trades = collections.defaultdict(AutoDictList)
    _obj._tradespending = list()

    _obj.stats = _obj.observers = ItemCollection()
    _obj.analyzers = ItemCollection()
    _obj._alnames = collections.defaultdict(itertools.count)
    _obj.writers = list()

    _obj._slave_analyzers = list()

    _obj._tradehistoryon = False

    return _obj, args, kwargs</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.MetaLineIterator" href="lineiterator.html#backtrader.lineiterator.MetaLineIterator">MetaLineIterator</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.MetaLineIterator.donew" href="lineseries.html#backtrader.lineseries.MetaLineSeries.donew">donew</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.strategy.SignalStrategy"><code class="flex name class">
<span>class <span class="ident">SignalStrategy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This subclass of <code><a title="backtrader.strategy.Strategy" href="#backtrader.strategy.Strategy">Strategy</a></code> is meant to to auto-operate using
<strong>signals</strong>.</p>
<p><em>Signals</em> are usually indicators and the expected output values:</p>
<ul>
<li>
<p><code>&gt; 0</code> is a <code>long</code> indication</p>
</li>
<li>
<p><code>&lt; 0</code> is a <code>short</code> indication</p>
</li>
</ul>
<p>There are 5 types of <em>Signals</em>, broken in 2 groups.</p>
<p><strong>Main Group</strong>:</p>
<ul>
<li>
<p><code>LONGSHORT</code>: both <code>long</code> and <code>short</code> indications from this signal
are taken</p>
</li>
<li>
<p><code>LONG</code>:</p>
<ul>
<li><code>long</code> indications are taken to go long</li>
<li>
<p><code>short</code> indications are taken to <em>close</em> the long position. But:</p>
</li>
<li>
<p>If a <code>LONGEXIT</code> (see below) signal is in the system it will be
used to exit the long</p>
</li>
<li>
<p>If a <code>SHORT</code> signal is available and no <code>LONGEXIT</code> is available
, it will be used to close a <code>long</code> before opening a <code>short</code></p>
</li>
</ul>
</li>
<li>
<p><code>SHORT</code>:</p>
<ul>
<li><code>short</code> indications are taken to go short</li>
<li>
<p><code>long</code> indications are taken to <em>close</em> the short position. But:</p>
</li>
<li>
<p>If a <code>SHORTEXIT</code> (see below) signal is in the system it will be
used to exit the short</p>
</li>
<li>
<p>If a <code>LONG</code> signal is available and no <code>SHORTEXIT</code> is available
, it will be used to close a <code>short</code> before opening a <code>long</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>Exit Group</strong>:</p>
<p>This 2 signals are meant to override others and provide criteria for
exitins a <code>long</code>/<code>short</code> position</p>
<ul>
<li>
<p><code>LONGEXIT</code>: <code>short</code> indications are taken to exit <code>long</code>
positions</p>
</li>
<li>
<p><code>SHORTEXIT</code>: <code>long</code> indications are taken to exit <code>short</code>
positions</p>
</li>
</ul>
<p><strong>Order Issuing</strong></p>
<p>Orders execution type is <code>Market</code> and validity is <code>None</code> (<em>Good until
Canceled</em>)</p>
<h2 id="params">Params</h2>
<ul>
<li><code>signals</code> (default: <code>[]</code>): a list/tuple of lists/tuples that allows
the instantiation of the signals and allocation to the right type</li>
</ul>
<p>This parameter is expected to be managed through <code>cerebro.add_signal</code></p>
<ul>
<li>
<p><code>_accumulate</code> (default: <code>False</code>): allow to enter the market
(long/short) even if already in the market</p>
</li>
<li>
<p><code>_concurrent</code> (default: <code>False</code>): allow orders to be issued even if
orders are already pending execution</p>
</li>
<li>
<p><code>_data</code> (default: <code>None</code>): if multiple datas are present in the
system which is the target for orders. This can be</p>
</li>
<li>
<p><code>None</code>: The first data in the system will be used</p>
</li>
<li>
<p>An <code>int</code>: indicating the data that was inserted at that position</p>
</li>
<li>
<p>An <code>str</code>: name given to the data when creating it (parameter
<code>name</code>) or when adding it cerebro with <code>cerebro.adddata(...,
name=)</code></p>
</li>
<li>
<p>A <code>data</code> instance</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalStrategy(with_metaclass(MetaSigStrategy, Strategy)):
    &#39;&#39;&#39;This subclass of ``Strategy`` is meant to to auto-operate using
    **signals**.

    *Signals* are usually indicators and the expected output values:

      - ``&gt; 0`` is a ``long`` indication

      - ``&lt; 0`` is a ``short`` indication

    There are 5 types of *Signals*, broken in 2 groups.

    **Main Group**:

      - ``LONGSHORT``: both ``long`` and ``short`` indications from this signal
        are taken

      - ``LONG``:
        - ``long`` indications are taken to go long
        - ``short`` indications are taken to *close* the long position. But:

          - If a ``LONGEXIT`` (see below) signal is in the system it will be
            used to exit the long

          - If a ``SHORT`` signal is available and no ``LONGEXIT`` is available
            , it will be used to close a ``long`` before opening a ``short``

      - ``SHORT``:
        - ``short`` indications are taken to go short
        - ``long`` indications are taken to *close* the short position. But:

          - If a ``SHORTEXIT`` (see below) signal is in the system it will be
            used to exit the short

          - If a ``LONG`` signal is available and no ``SHORTEXIT`` is available
            , it will be used to close a ``short`` before opening a ``long``

    **Exit Group**:

      This 2 signals are meant to override others and provide criteria for
      exitins a ``long``/``short`` position

      - ``LONGEXIT``: ``short`` indications are taken to exit ``long``
        positions

      - ``SHORTEXIT``: ``long`` indications are taken to exit ``short``
        positions

    **Order Issuing**

      Orders execution type is ``Market`` and validity is ``None`` (*Good until
      Canceled*)

    Params:

      - ``signals`` (default: ``[]``): a list/tuple of lists/tuples that allows
        the instantiation of the signals and allocation to the right type

        This parameter is expected to be managed through ``cerebro.add_signal``

      - ``_accumulate`` (default: ``False``): allow to enter the market
        (long/short) even if already in the market

      - ``_concurrent`` (default: ``False``): allow orders to be issued even if
        orders are already pending execution

      - ``_data`` (default: ``None``): if multiple datas are present in the
        system which is the target for orders. This can be

        - ``None``: The first data in the system will be used

        - An ``int``: indicating the data that was inserted at that position

        - An ``str``: name given to the data when creating it (parameter
          ``name``) or when adding it cerebro with ``cerebro.adddata(...,
          name=)``

        - A ``data`` instance

    &#39;&#39;&#39;

    params = (
        (&#39;signals&#39;, []),
        (&#39;_accumulate&#39;, False),
        (&#39;_concurrent&#39;, False),
        (&#39;_data&#39;, None),
    )

    def _start(self):
        self._sentinel = None  # sentinel for order concurrency
        super(SignalStrategy, self)._start()

    def signal_add(self, sigtype, signal):
        self._signals[sigtype].append(signal)

    def _notify(self, qorders=[], qtrades=[]):
        # Nullify the sentinel if done
        procorders = qorders or self._orderspending
        if self._sentinel is not None:
            for order in procorders:
                if order == self._sentinel and not order.alive():
                    self._sentinel = None
                    break

        super(SignalStrategy, self)._notify(qorders=qorders, qtrades=qtrades)

    def _next_catch(self):
        self._next_signal()
        if hasattr(self, &#39;_next_custom&#39;):
            self._next_custom()

    def _next_signal(self):
        if self._sentinel is not None and not self.p._concurrent:
            return  # order active and more than 1 not allowed

        sigs = self._signals
        nosig = [[0.0]]

        # Calculate current status of the signals
        ls_long = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONGSHORT] or nosig)
        ls_short = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONGSHORT] or nosig)

        l_enter0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONG] or nosig)
        l_enter1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or nosig)
        l_enter2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or nosig)
        l_enter = l_enter0 or l_enter1 or l_enter2

        s_enter0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORT] or nosig)
        s_enter1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORT_INV] or nosig)
        s_enter2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or nosig)
        s_enter = s_enter0 or s_enter1 or s_enter2

        l_ex0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONGEXIT] or nosig)
        l_ex1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONGEXIT_INV] or nosig)
        l_ex2 = all(x[0] for x in sigs[bt.SIGNAL_LONGEXIT_ANY] or nosig)
        l_exit = l_ex0 or l_ex1 or l_ex2

        s_ex0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT] or nosig)
        s_ex1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT_INV] or nosig)
        s_ex2 = all(x[0] for x in sigs[bt.SIGNAL_SHORTEXIT_ANY] or nosig)
        s_exit = s_ex0 or s_ex1 or s_ex2

        # Use oppossite signales to start reversal (by closing)
        # but only if no &#34;xxxExit&#34; exists
        l_rev = not self._longexit and s_enter
        s_rev = not self._shortexit and l_enter

        # Opposite of individual long and short
        l_leav0 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_LONG] or nosig)
        l_leav1 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or nosig)
        l_leav2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or nosig)
        l_leave = l_leav0 or l_leav1 or l_leav2

        s_leav0 = all(x[0] &gt; 0.0 for x in sigs[bt.SIGNAL_SHORT] or nosig)
        s_leav1 = all(x[0] &lt; 0.0 for x in sigs[bt.SIGNAL_SHORT_INV] or nosig)
        s_leav2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or nosig)
        s_leave = s_leav0 or s_leav1 or s_leav2

        # Invalidate long leave if longexit signals are available
        l_leave = not self._longexit and l_leave
        # Invalidate short leave if shortexit signals are available
        s_leave = not self._shortexit and s_leave

        # Take size and start logic
        size = self.getposition(self._dtarget).size
        if not size:
            if ls_long or l_enter:
                self._sentinel = self.buy(self._dtarget)

            elif ls_short or s_enter:
                self._sentinel = self.sell(self._dtarget)

        elif size &gt; 0:  # current long position
            if ls_short or l_exit or l_rev or l_leave:
                # closing position - not relevant for concurrency
                self.close(self._dtarget)

            if ls_short or l_rev:
                self._sentinel = self.sell(self._dtarget)

            if ls_long or l_enter:
                if self.p._accumulate:
                    self._sentinel = self.buy(self._dtarget)

        elif size &lt; 0:  # current short position
            if ls_long or s_exit or s_rev or s_leave:
                # closing position - not relevant for concurrency
                self.close(self._dtarget)

            if ls_long or s_rev:
                self._sentinel = self.buy(self._dtarget)

            if ls_short or s_enter:
                if self.p._accumulate:
                    self._sentinel = self.sell(self._dtarget)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.strategy.Strategy" href="#backtrader.strategy.Strategy">Strategy</a></li>
<li><a title="backtrader.lineiterator.StrategyBase" href="lineiterator.html#backtrader.lineiterator.StrategyBase">StrategyBase</a></li>
<li><a title="backtrader.lineiterator.DataAccessor" href="lineiterator.html#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.LineIterator" href="lineiterator.html#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.strategy.SignalStrategy.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.SignalStrategy.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.strategy.SignalStrategy.signal_add"><code class="name flex">
<span>def <span class="ident">signal_add</span></span>(<span>self, sigtype, signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_add(self, sigtype, signal):
    self._signals[sigtype].append(signal)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.strategy.Strategy" href="#backtrader.strategy.Strategy">Strategy</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.strategy.Strategy.add_timer" href="#backtrader.strategy.Strategy.add_timer">add_timer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.buy" href="#backtrader.strategy.Strategy.buy">buy</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.buy_bracket" href="#backtrader.strategy.Strategy.buy_bracket">buy_bracket</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.cancel" href="#backtrader.strategy.Strategy.cancel">cancel</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.close" href="#backtrader.strategy.Strategy.close">close</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getdatabyname" href="#backtrader.strategy.Strategy.getdatabyname">getdatabyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getdatanames" href="#backtrader.strategy.Strategy.getdatanames">getdatanames</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getposition" href="#backtrader.strategy.Strategy.getposition">getposition</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositionbyname" href="#backtrader.strategy.Strategy.getpositionbyname">getpositionbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositions" href="#backtrader.strategy.Strategy.getpositions">getpositions</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositionsbyname" href="#backtrader.strategy.Strategy.getpositionsbyname">getpositionsbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getsizer" href="#backtrader.strategy.Strategy.getsizer">getsizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getsizing" href="#backtrader.strategy.Strategy.getsizing">getsizing</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.next" href="lineiterator.html#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.nextstart" href="lineiterator.html#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_cashvalue" href="#backtrader.strategy.Strategy.notify_cashvalue">notify_cashvalue</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_data" href="#backtrader.strategy.Strategy.notify_data">notify_data</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_fund" href="#backtrader.strategy.Strategy.notify_fund">notify_fund</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_order" href="#backtrader.strategy.Strategy.notify_order">notify_order</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_store" href="#backtrader.strategy.Strategy.notify_store">notify_store</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_timer" href="#backtrader.strategy.Strategy.notify_timer">notify_timer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_trade" href="#backtrader.strategy.Strategy.notify_trade">notify_trade</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_percent" href="#backtrader.strategy.Strategy.order_target_percent">order_target_percent</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_size" href="#backtrader.strategy.Strategy.order_target_size">order_target_size</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_value" href="#backtrader.strategy.Strategy.order_target_value">order_target_value</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.position" href="#backtrader.strategy.Strategy.position">position</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positionbyname" href="#backtrader.strategy.Strategy.positionbyname">positionbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positions" href="#backtrader.strategy.Strategy.positions">positions</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positionsbyname" href="#backtrader.strategy.Strategy.positionsbyname">positionsbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.prenext" href="lineiterator.html#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.qbuffer" href="#backtrader.strategy.Strategy.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sell" href="#backtrader.strategy.Strategy.sell">sell</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sell_bracket" href="#backtrader.strategy.Strategy.sell_bracket">sell_bracket</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.setsizer" href="#backtrader.strategy.Strategy.setsizer">setsizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sizer" href="#backtrader.strategy.Strategy.sizer">sizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.start" href="#backtrader.strategy.Strategy.start">start</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.stop" href="#backtrader.strategy.Strategy.stop">stop</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="backtrader.strategy.Strategy"><code class="flex name class">
<span>class <span class="ident">Strategy</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class to be subclassed for user defined strategies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Strategy(with_metaclass(MetaStrategy, StrategyBase)):
    &#39;&#39;&#39;
    Base class to be subclassed for user defined strategies.
    &#39;&#39;&#39;

    _ltype = LineIterator.StratType

    csv = True
    _oldsync = False  # update clock using old methodology : data 0

    # keep the latest delivered data date in the line
    lines = (&#39;datetime&#39;,)

    def qbuffer(self, savemem=0, replaying=False):
        &#39;&#39;&#39;Enable the memory saving schemes. Possible values for ``savemem``:

          0: No savings. Each lines object keeps in memory all values

          1: All lines objects save memory, using the strictly minimum needed

        Negative values are meant to be used when plotting is required:

          -1: Indicators at Strategy Level and Observers do not enable memory
              savings (but anything declared below it does)

          -2: Same as -1 plus activation of memory saving for any indicators
              which has declared *plotinfo.plot* as False (will not be plotted)
        &#39;&#39;&#39;
        if savemem &lt; 0:
            # Get any attribute which labels itself as Indicator
            for ind in self._lineiterators[self.IndType]:
                subsave = isinstance(ind, (LineSingle,))
                if not subsave and savemem &lt; -1:
                    subsave = not ind.plotinfo.plot
                ind.qbuffer(savemem=subsave)

        elif savemem &gt; 0:
            for data in self.datas:
                data.qbuffer(replaying=replaying)

            for line in self.lines:
                line.qbuffer(savemem=1)

            # Save in all object types depending on the strategy
            for itcls in self._lineiterators:
                for it in self._lineiterators[itcls]:
                    it.qbuffer(savemem=1)

    def _periodset(self):
        dataids = [id(data) for data in self.datas]

        _dminperiods = collections.defaultdict(list)
        for lineiter in self._lineiterators[LineIterator.IndType]:
            # if multiple datas are used and multiple timeframes the larger
            # timeframe may place larger time constraints in calling next.
            clk = getattr(lineiter, &#39;_clock&#39;, None)
            if clk is None:
                clk = getattr(lineiter._owner, &#39;_clock&#39;, None)
                if clk is None:
                    continue

            while True:
                if id(clk) in dataids:
                    break  # already top-level clock (data feed)

                # See if the current clock has higher level clocks
                clk2 = getattr(clk, &#39;_clock&#39;, None)
                if clk2 is None:
                    clk2 = getattr(clk._owner, &#39;_clock&#39;, None)

                if clk2 is None:
                    break  # if no clock found, bail out

                clk = clk2  # keep the ref and try to go up the hierarchy

            if clk is None:
                continue  # no clock found, go to next

            # LineSeriesStup wraps a line and the clock is the wrapped line and
            # no the wrapper itself.
            if isinstance(clk, LineSeriesStub):
                clk = clk.lines[0]

            _dminperiods[clk].append(lineiter._minperiod)

        self._minperiods = list()
        for data in self.datas:

            # Do not only consider the data as clock but also its lines which
            # may have been individually passed as clock references and
            # discovered as clocks above

            # Initialize with data min period if any
            dlminperiods = _dminperiods[data]

            for l in data.lines:  # search each line for min periods
                if l in _dminperiods:
                    dlminperiods += _dminperiods[l]  # found, add it

            # keep the reference to the line if any was found
            _dminperiods[data] = [max(dlminperiods)] if dlminperiods else []

            dminperiod = max(_dminperiods[data] or [data._minperiod])
            self._minperiods.append(dminperiod)

        # Set the minperiod
        minperiods = \
            [x._minperiod for x in self._lineiterators[LineIterator.IndType]]
        self._minperiod = max(minperiods or [self._minperiod])

    def _addwriter(self, writer):
        &#39;&#39;&#39;
        Unlike the other _addxxx functions this one receives an instance
        because the writer works at cerebro level and is only passed to the
        strategy to simplify the logic
        &#39;&#39;&#39;
        self.writers.append(writer)

    def _addindicator(self, indcls, *indargs, **indkwargs):
        indcls(*indargs, **indkwargs)

    def _addanalyzer_slave(self, ancls, *anargs, **ankwargs):
        &#39;&#39;&#39;Like _addanalyzer but meant for observers (or other entities) which
        rely on the output of an analyzer for the data. These analyzers have
        not been added by the user and are kept separate from the main
        analyzers

        Returns the created analyzer
        &#39;&#39;&#39;
        analyzer = ancls(*anargs, **ankwargs)
        self._slave_analyzers.append(analyzer)
        return analyzer

    def _getanalyzer_slave(self, idx):
        return self._slave_analyzers.append[idx]

    def _addanalyzer(self, ancls, *anargs, **ankwargs):
        anname = ankwargs.pop(&#39;_name&#39;, &#39;&#39;) or ancls.__name__.lower()
        nsuffix = next(self._alnames[anname])
        anname += str(nsuffix or &#39;&#39;)  # 0 (first instance) gets no suffix
        analyzer = ancls(*anargs, **ankwargs)
        self.analyzers.append(analyzer, anname)

    def _addobserver(self, multi, obscls, *obsargs, **obskwargs):
        obsname = obskwargs.pop(&#39;obsname&#39;, &#39;&#39;)
        if not obsname:
            obsname = obscls.__name__.lower()

        if not multi:
            newargs = list(itertools.chain(self.datas, obsargs))
            obs = obscls(*newargs, **obskwargs)
            self.stats.append(obs, obsname)
            return

        setattr(self.stats, obsname, list())
        l = getattr(self.stats, obsname)

        for data in self.datas:
            obs = obscls(data, *obsargs, **obskwargs)
            l.append(obs)

    def _getminperstatus(self):
        # check the min period status connected to datas
        dlens = map(operator.sub, self._minperiods, map(len, self.datas))
        self._minperstatus = minperstatus = max(dlens)
        return minperstatus

    def prenext_open(self):
        pass

    def nextstart_open(self):
        self.next_open()

    def next_open(self):
        pass

    def _oncepost_open(self):
        minperstatus = self._minperstatus
        if minperstatus &lt; 0:
            self.next_open()
        elif minperstatus == 0:
            self.nextstart_open()  # only called for the 1st value
        else:
            self.prenext_open()

    def _oncepost(self, dt):
        for indicator in self._lineiterators[LineIterator.IndType]:
            if len(indicator._clock) &gt; len(indicator):
                indicator.advance()

        if self._oldsync:
            # Strategy has not been reset, the line is there
            self.advance()
        else:
            # strategy has been reset to beginning. advance step by step
            self.forward()

        self.lines.datetime[0] = dt
        self._notify()

        minperstatus = self._getminperstatus()
        if minperstatus &lt; 0:
            self.next()
        elif minperstatus == 0:
            self.nextstart()  # only called for the 1st value
        else:
            self.prenext()

        self._next_analyzers(minperstatus, once=True)
        self._next_observers(minperstatus, once=True)

        self.clear()

    def _clk_update(self):
        if self._oldsync:
            clk_len = super(Strategy, self)._clk_update()
            self.lines.datetime[0] = max(d.datetime[0]
                                         for d in self.datas if len(d))
            return clk_len

        newdlens = [len(d) for d in self.datas]
        if any(nl &gt; l for l, nl in zip(self._dlens, newdlens)):
            self.forward()

        self.lines.datetime[0] = max(d.datetime[0]
                                     for d in self.datas if len(d))
        self._dlens = newdlens

        return len(self)

    def _next_open(self):
        minperstatus = self._minperstatus
        if minperstatus &lt; 0:
            self.next_open()
        elif minperstatus == 0:
            self.nextstart_open()  # only called for the 1st value
        else:
            self.prenext_open()

    def _next(self):
        super(Strategy, self)._next()

        minperstatus = self._getminperstatus()
        self._next_analyzers(minperstatus)
        self._next_observers(minperstatus)

        self.clear()

    def _next_observers(self, minperstatus, once=False):
        for observer in self._lineiterators[LineIterator.ObsType]:
            for analyzer in observer._analyzers:
                if minperstatus &lt; 0:
                    analyzer._next()
                elif minperstatus == 0:
                    analyzer._nextstart()  # only called for the 1st value
                else:
                    analyzer._prenext()

            if once:
                if len(self) &gt; len(observer):
                    if self._oldsync:
                        observer.advance()
                    else:
                        observer.forward()

                if minperstatus &lt; 0:
                    observer.next()
                elif minperstatus == 0:
                    observer.nextstart()  # only called for the 1st value
                elif len(observer):
                    observer.prenext()
            else:
                observer._next()

    def _next_analyzers(self, minperstatus, once=False):
        for analyzer in self.analyzers:
            if minperstatus &lt; 0:
                analyzer._next()
            elif minperstatus == 0:
                analyzer._nextstart()  # only called for the 1st value
            else:
                analyzer._prenext()

    def _settz(self, tz):
        self.lines.datetime._settz(tz)

    def _start(self):
        self._periodset()

        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._start()

        for obs in self.observers:
            if not isinstance(obs, list):
                obs = [obs]  # support of multi-data observers

            for o in obs:
                o._start()

        # change operators to stage 2
        self._stage2()

        self._dlens = [len(data) for data in self.datas]

        self._minperstatus = MAXINT  # start in prenext

        self.start()

    def start(self):
        &#39;&#39;&#39;Called right before the backtesting is about to be started.&#39;&#39;&#39;
        pass

    def getwriterheaders(self):
        self.indobscsv = [self]

        indobs = itertools.chain(
            self.getindicators_lines(), self.getobservers())
        self.indobscsv.extend(filter(lambda x: x.csv, indobs))

        headers = list()

        # prepare the indicators/observers data headers
        for iocsv in self.indobscsv:
            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
            headers.append(name)
            headers.append(&#39;len&#39;)
            headers.extend(iocsv.getlinealiases())

        return headers

    def getwritervalues(self):
        values = list()

        for iocsv in self.indobscsv:
            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
            values.append(name)
            lio = len(iocsv)
            values.append(lio)
            if lio:
                values.extend(map(lambda l: l[0], iocsv.lines.itersize()))
            else:
                values.extend([&#39;&#39;] * iocsv.lines.size())

        return values

    def getwriterinfo(self):
        wrinfo = AutoOrderedDict()

        wrinfo[&#39;Params&#39;] = self.p._getkwargs()

        sections = [
            [&#39;Indicators&#39;, self.getindicators_lines()],
            [&#39;Observers&#39;, self.getobservers()]
        ]

        for sectname, sectitems in sections:
            sinfo = wrinfo[sectname]
            for item in sectitems:
                itname = item.__class__.__name__
                sinfo[itname].Lines = item.lines.getlinealiases() or None
                sinfo[itname].Params = item.p._getkwargs() or None

        ainfo = wrinfo.Analyzers

        # Internal Value Analyzer
        ainfo.Value.Begin = self.broker.startingcash
        ainfo.Value.End = self.broker.getvalue()

        # no slave analyzers for writer
        for aname, analyzer in self.analyzers.getitems():
            ainfo[aname].Params = analyzer.p._getkwargs() or None
            ainfo[aname].Analysis = analyzer.get_analysis()

        return wrinfo

    def _stop(self):
        self.stop()

        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._stop()

        # change operators back to stage 1 - allows reuse of datas
        self._stage1()

    def stop(self):
        &#39;&#39;&#39;Called right before the backtesting is about to be stopped&#39;&#39;&#39;
        pass

    def set_tradehistory(self, onoff=True):
        self._tradehistoryon = onoff

    def clear(self):
        self._orders.extend(self._orderspending)
        self._orderspending = list()
        self._tradespending = list()

    def _addnotification(self, order, quicknotify=False):
        if not order.p.simulated:
            self._orderspending.append(order)

        if quicknotify:
            qorders = [order]
            qtrades = []

        if not order.executed.size:
            if quicknotify:
                self._notify(qorders=qorders, qtrades=qtrades)
            return

        tradedata = order.data._compensate
        if tradedata is None:
            tradedata = order.data

        datatrades = self._trades[tradedata][order.tradeid]
        if not datatrades:
            trade = Trade(data=tradedata, tradeid=order.tradeid,
                          historyon=self._tradehistoryon)
            datatrades.append(trade)
        else:
            trade = datatrades[-1]

        for exbit in order.executed.iterpending():
            if exbit is None:
                break

            if exbit.closed:
                trade.update(order,
                             exbit.closed,
                             exbit.price,
                             exbit.closedvalue,
                             exbit.closedcomm,
                             exbit.pnl,
                             comminfo=order.comminfo)

                if trade.isclosed:
                    self._tradespending.append(copy.copy(trade))
                    if quicknotify:
                        qtrades.append(copy.copy(trade))

            # Update it if needed
            if exbit.opened:
                if trade.isclosed:
                    trade = Trade(data=tradedata, tradeid=order.tradeid,
                                  historyon=self._tradehistoryon)
                    datatrades.append(trade)

                trade.update(order,
                             exbit.opened,
                             exbit.price,
                             exbit.openedvalue,
                             exbit.openedcomm,
                             exbit.pnl,
                             comminfo=order.comminfo)

                # This extra check covers the case in which different tradeid
                # orders have put the position down to 0 and the next order
                # &#34;opens&#34; a position but &#34;closes&#34; the trade
                if trade.isclosed:
                    self._tradespending.append(copy.copy(trade))
                    if quicknotify:
                        qtrades.append(copy.copy(trade))

            if trade.justopened:
                self._tradespending.append(copy.copy(trade))
                if quicknotify:
                    qtrades.append(copy.copy(trade))

        if quicknotify:
            self._notify(qorders=qorders, qtrades=qtrades)

    def _notify(self, qorders=[], qtrades=[]):
        if self.cerebro.p.quicknotify:
            # need to know if quicknotify is on, to not reprocess pendingorders
            # and pendingtrades, which have to exist for things like observers
            # which look into it
            procorders = qorders
            proctrades = qtrades
        else:
            procorders = self._orderspending
            proctrades = self._tradespending

        for order in procorders:
            if order.exectype != order.Historical or order.histnotify:
                self.notify_order(order)
            for analyzer in itertools.chain(self.analyzers,
                                            self._slave_analyzers):
                analyzer._notify_order(order)

        for trade in proctrades:
            self.notify_trade(trade)
            for analyzer in itertools.chain(self.analyzers,
                                            self._slave_analyzers):
                analyzer._notify_trade(trade)

        if qorders:
            return  # cash is notified on a regular basis

        cash = self.broker.getcash()
        value = self.broker.getvalue()
        fundvalue = self.broker.fundvalue
        fundshares = self.broker.fundshares

        self.notify_cashvalue(cash, value)
        self.notify_fund(cash, value, fundvalue, fundshares)
        for analyzer in itertools.chain(self.analyzers, self._slave_analyzers):
            analyzer._notify_cashvalue(cash, value)
            analyzer._notify_fund(cash, value, fundvalue, fundshares)

    def add_timer(self, when,
                  offset=datetime.timedelta(), repeat=datetime.timedelta(),
                  weekdays=[], weekcarry=False,
                  monthdays=[], monthcarry=True,
                  allow=None,
                  tzdata=None, cheat=False,
                  *args, **kwargs):
        &#39;&#39;&#39;
        **Note**: can be called during ``__init__`` or ``start``

        Schedules a timer to invoke either a specified callback or the
        ``notify_timer`` of one or more strategies.

        Arguments:

          - ``when``: can be

            - ``datetime.time`` instance (see below ``tzdata``)
            - ``bt.timer.SESSION_START`` to reference a session start
            - ``bt.timer.SESSION_END`` to reference a session end

         - ``offset`` which must be a ``datetime.timedelta`` instance

           Used to offset the value ``when``. It has a meaningful use in
           combination with ``SESSION_START`` and ``SESSION_END``, to indicated
           things like a timer being called ``15 minutes`` after the session
           start.

          - ``repeat`` which must be a ``datetime.timedelta`` instance

            Indicates if after a 1st call, further calls will be scheduled
            within the same session at the scheduled ``repeat`` delta

            Once the timer goes over the end of the session it is reset to the
            original value for ``when``

          - ``weekdays``: a **sorted** iterable with integers indicating on
            which days (iso codes, Monday is 1, Sunday is 7) the timers can
            be actually invoked

            If not specified, the timer will be active on all days

          - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
            not seen (ex: trading holiday), the timer will be executed on the
            next day (even if in a new week)

          - ``monthdays``: a **sorted** iterable with integers indicating on
            which days of the month a timer has to be executed. For example
            always on day *15* of the month

            If not specified, the timer will be active on all days

          - ``monthcarry`` (default: ``True``). If the day was not seen
            (weekend, trading holiday), the timer will be executed on the next
            available day.

          - ``allow`` (default: ``None``). A callback which receives a
            `datetime.date`` instance and returns ``True`` if the date is
            allowed for timers or else returns ``False``

          - ``tzdata`` which can be either ``None`` (default), a ``pytz``
            instance or a ``data feed`` instance.

            ``None``: ``when`` is interpreted at face value (which translates
            to handling it as if it where UTC even if it&#39;s not)

            ``pytz`` instance: ``when`` will be interpreted as being specified
            in the local time specified by the timezone instance.

            ``data feed`` instance: ``when`` will be interpreted as being
            specified in the local time specified by the ``tz`` parameter of
            the data feed instance.

            **Note**: If ``when`` is either ``SESSION_START`` or
              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
              in the system (aka ``self.data0``) will be used as the reference
              to find out the session times.

          - ``cheat`` (default ``False``) if ``True`` the timer will be called
            before the broker has a chance to evaluate the orders. This opens
            the chance to issue orders based on opening price for example right
            before the session starts

          - ``*args``: any extra args will be passed to ``notify_timer``

          - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

        Return Value:

          - The created timer

        &#39;&#39;&#39;
        return self.cerebro._add_timer(
            owner=self, when=when, offset=offset, repeat=repeat,
            weekdays=weekdays, weekcarry=weekcarry,
            monthdays=monthdays, monthcarry=monthcarry,
            allow=allow,
            tzdata=tzdata, strats=False, cheat=cheat,
            *args, **kwargs)

    def notify_timer(self, timer, when, *args, **kwargs):
        &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
        returned by ``add_timer``, and ``when`` is the calling time. ``args``
        and ``kwargs`` are any additional arguments passed to ``add_timer``

        The actual ``when`` time can be later, but the system may have not be
        able to call the timer before. This value is the timer value and no the
        system time.
        &#39;&#39;&#39;
        pass

    def notify_cashvalue(self, cash, value):
        &#39;&#39;&#39;
        Receives the current fund value, value status of the strategy&#39;s broker
        &#39;&#39;&#39;
        pass

    def notify_fund(self, cash, value, fundvalue, shares):
        &#39;&#39;&#39;
        Receives the current cash, value, fundvalue and fund shares
        &#39;&#39;&#39;
        pass

    def notify_order(self, order):
        &#39;&#39;&#39;
        Receives an order whenever there has been a change in one
        &#39;&#39;&#39;
        pass

    def notify_trade(self, trade):
        &#39;&#39;&#39;
        Receives a trade whenever there has been a change in one
        &#39;&#39;&#39;
        pass

    def notify_store(self, msg, *args, **kwargs):
        &#39;&#39;&#39;Receives a notification from a store provider&#39;&#39;&#39;
        pass

    def notify_data(self, data, status, *args, **kwargs):
        &#39;&#39;&#39;Receives a notification from data&#39;&#39;&#39;
        pass

    def getdatanames(self):
        &#39;&#39;&#39;
        Returns a list of the existing data names
        &#39;&#39;&#39;
        return keys(self.env.datasbyname)

    def getdatabyname(self, name):
        &#39;&#39;&#39;
        Returns a given data by name using the environment (cerebro)
        &#39;&#39;&#39;
        return self.env.datasbyname[name]

    def cancel(self, order):
        &#39;&#39;&#39;Cancels the order in the broker&#39;&#39;&#39;
        self.broker.cancel(order)

    def buy(self, data=None,
            size=None, price=None, plimit=None,
            exectype=None, valid=None, tradeid=0, oco=None,
            trailamount=None, trailpercent=None,
            parent=None, transmit=True,
            **kwargs):
        &#39;&#39;&#39;Create a buy (long) order and send it to the broker

          - ``data`` (default: ``None``)

            For which data the order has to be created. If ``None`` then the
            first data in the system, ``self.datas[0] or self.data0`` (aka
            ``self.data``) will be used

          - ``size`` (default: ``None``)

            Size to use (positive) of units of data to use for the order.

            If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
            be used to determine the size.

          - ``price`` (default: ``None``)

            Price to use (live brokers may place restrictions on the actual
            format if it does not comply to minimum tick size requirements)

            ``None`` is valid for ``Market`` and ``Close`` orders (the market
            determines the price)

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
            determines the trigger point (in the case of ``Limit`` the trigger
            is obviously at which price the order should be matched)

          - ``plimit`` (default: ``None``)

            Only applicable to ``StopLimit`` orders. This is the price at which
            to set the implicit *Limit* order, once the *Stop* has been
            triggered (for which ``price`` has been used)

          - ``trailamount`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is an
            absolute amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop

          - ``trailpercent`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is a
            percentage amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop (if ``trailamount`` is also specified it will be used)

          - ``exectype`` (default: ``None``)

            Possible values:

            - ``Order.Market`` or ``None``. A market order will be executed
              with the next available price. In backtesting it will be the
              opening price of the next bar

            - ``Order.Limit``. An order which can only be executed at the given
              ``price`` or better

            - ``Order.Stop``. An order which is triggered at ``price`` and
              executed like an ``Order.Market`` order

            - ``Order.StopLimit``. An order which is triggered at ``price`` and
              executed as an implicit *Limit* order with price given by
              ``pricelimit``

            - ``Order.Close``. An order which can only be executed with the
              closing price of the session (usually during a closing auction)

            - ``Order.StopTrail``. An order which is triggered at ``price``
              minus ``trailamount`` (or ``trailpercent``) and which is updated
              if the price moves away from the stop

            - ``Order.StopTrailLimit``. An order which is triggered at
              ``price`` minus ``trailamount`` (or ``trailpercent``) and which
              is updated if the price moves away from the stop

          - ``valid`` (default: ``None``)

            Possible values:

              - ``None``: this generates an order that will not expire (aka
                *Good till cancel*) and remain in the market until matched or
                canceled. In reality brokers tend to impose a temporal limit,
                but this is usually so far away in time to consider it as not
                expiring

              - ``datetime.datetime`` or ``datetime.date`` instance: the date
                will be used to generate an order valid until the given
                datetime (aka *good till date*)

              - ``Order.DAY`` or ``0`` or ``timedelta()``: a day valid until
                the *End of the Session* (aka *day* order) will be generated

              - ``numeric value``: This is assumed to be a value corresponding
                to a datetime in ``matplotlib`` coding (the one used by
                ``backtrader``) and will used to generate an order valid until
                that time (*good till date*)

          - ``tradeid`` (default: ``0``)

            This is an internal value applied by ``backtrader`` to keep track
            of overlapping trades on the same asset. This ``tradeid`` is sent
            back to the *strategy* when notifying changes to the status of the
            orders.

          - ``oco`` (default: ``None``)

            Another ``order`` instance. This order will become part of an OCO
            (Order Cancel Others) group. The execution of one of the orders,
            immediately cancels all others in the same group

          - ``parent`` (default: ``None``)

            Controls the relationship of a group of orders, for example a buy
            which is bracketed by a high-side limit sell and a low side stop
            sell. The high/low side orders remain inactive until the parent
            order has been either executed (they become active) or is
            canceled/expires (the children are also canceled) bracket orders
            have the same size

          - ``transmit`` (default: ``True``)

            Indicates if the order has to be **transmitted**, ie: not only
            placed in the broker but also issued. This is meant for example to
            control bracket orders, in which one disables the transmission for
            the parent and 1st set of children and activates it for the last
            children, which triggers the full placement of all bracket orders.

          - ``**kwargs``: additional broker implementations may support extra
            parameters. ``backtrader`` will pass the *kwargs* down to the
            created order objects

            Example: if the 4 order execution types directly supported by
            ``backtrader`` are not enough, in the case of for example
            *Interactive Brokers* the following could be passed as *kwargs*::

              orderType=&#39;LIT&#39;, lmtPrice=10.0, auxPrice=9.8

            This would override the settings created by ``backtrader`` and
            generate a ``LIMIT IF TOUCHED`` order with a *touched* price of 9.8
            and a *limit* price of 10.0.

        Returns:
          - the submitted order

        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)

        data = data if data is not None else self.datas[0]
        size = size if size is not None else self.getsizing(data, isbuy=True)

        if size:
            return self.broker.buy(
                self, data,
                size=abs(size), price=price, plimit=plimit,
                exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
                trailamount=trailamount, trailpercent=trailpercent,
                parent=parent, transmit=transmit,
                **kwargs)

        return None

    def sell(self, data=None,
             size=None, price=None, plimit=None,
             exectype=None, valid=None, tradeid=0, oco=None,
             trailamount=None, trailpercent=None,
             parent=None, transmit=True,
             **kwargs):
        &#39;&#39;&#39;
        To create a selll (short) order and send it to the broker

        See the documentation for ``buy`` for an explanation of the parameters

        Returns: the submitted order
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)

        data = data if data is not None else self.datas[0]
        size = size if size is not None else self.getsizing(data, isbuy=False)

        if size:
            return self.broker.sell(
                self, data,
                size=abs(size), price=price, plimit=plimit,
                exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
                trailamount=trailamount, trailpercent=trailpercent,
                parent=parent, transmit=transmit,
                **kwargs)

        return None

    def close(self, data=None, size=None, **kwargs):
        &#39;&#39;&#39;
        Counters a long/short position closing it

        See the documentation for ``buy`` for an explanation of the parameters

        Note:

          - ``size``: automatically calculated from the existing position if
            not provided (default: ``None``) by the caller

        Returns: the submitted order
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        size = abs(size if size is not None else possize)

        if possize &gt; 0:
            return self.sell(data=data, size=size, **kwargs)
        elif possize &lt; 0:
            return self.buy(data=data, size=size, **kwargs)

        return None

    def buy_bracket(self, data=None, size=None, price=None, plimit=None,
                    exectype=bt.Order.Limit, valid=None, tradeid=0,
                    trailamount=None, trailpercent=None, oargs={},
                    stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                    limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                    **kwargs):
        &#39;&#39;&#39;
        Create a bracket order group (low side - buy order - high side). The
        default behavior is as follows:

          - Issue a **buy** order with execution ``Limit``

          - Issue a *low side* bracket **sell** order with execution ``Stop``

          - Issue a *high side* bracket **sell** order with execution
            ``Limit``.

        See below for the different parameters

          - ``data`` (default: ``None``)

            For which data the order has to be created. If ``None`` then the
            first data in the system, ``self.datas[0] or self.data0`` (aka
            ``self.data``) will be used

          - ``size`` (default: ``None``)

            Size to use (positive) of units of data to use for the order.

            If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
            be used to determine the size.

            **Note**: The same size is applied to all 3 orders of the bracket

          - ``price`` (default: ``None``)

            Price to use (live brokers may place restrictions on the actual
            format if it does not comply to minimum tick size requirements)

            ``None`` is valid for ``Market`` and ``Close`` orders (the market
            determines the price)

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
            determines the trigger point (in the case of ``Limit`` the trigger
            is obviously at which price the order should be matched)

          - ``plimit`` (default: ``None``)

            Only applicable to ``StopLimit`` orders. This is the price at which
            to set the implicit *Limit* order, once the *Stop* has been
            triggered (for which ``price`` has been used)

          - ``trailamount`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is an
            absolute amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop

          - ``trailpercent`` (default: ``None``)

            If the order type is StopTrail or StopTrailLimit, this is a
            percentage amount which determines the distance to the price (below
            for a Sell order and above for a buy order) to keep the trailing
            stop (if ``trailamount`` is also specified it will be used)

          - ``exectype`` (default: ``bt.Order.Limit``)

            Possible values: (see the documentation for the method ``buy``

          - ``valid`` (default: ``None``)

            Possible values: (see the documentation for the method ``buy``

          - ``tradeid`` (default: ``0``)

            Possible values: (see the documentation for the method ``buy``

          - ``oargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the main side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

          - ``**kwargs``: additional broker implementations may support extra
            parameters. ``backtrader`` will pass the *kwargs* down to the
            created order objects

            Possible values: (see the documentation for the method ``buy``

            **Note**: this ``kwargs`` will be applied to the 3 orders of a
            bracket. See below for specific keyword arguments for the low and
            high side orders

          - ``stopprice`` (default: ``None``)

            Specific price for the *low side* stop order

          - ``stopexec`` (default: ``bt.Order.Stop``)

            Specific execution type for the *low side* order

          - ``stopargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the low side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

          - ``limitprice`` (default: ``None``)

            Specific price for the *high side* stop order

          - ``stopexec`` (default: ``bt.Order.Limit``)

            Specific execution type for the *high side* order

          - ``limitargs`` (default: ``{}``)

            Specific keyword arguments (in a ``dict``) to pass to the high side
            order. Arguments from the default ``**kwargs`` will be applied on
            top of this.

        High/Low Side orders can be suppressed by using:

          - ``limitexec=None`` to suppress the *high side*

          - ``stopexec=None`` to suppress the *low side*

        Returns:

          - A list containing the 3 orders [order, stop side, limit side]

          - If high/low orders have been suppressed the return value will still
            contain 3 orders, but those suppressed will have a value of
            ``None``
        &#39;&#39;&#39;

        kargs = dict(size=size,
                     data=data, price=price, plimit=plimit, exectype=exectype,
                     valid=valid, tradeid=tradeid,
                     trailamount=trailamount, trailpercent=trailpercent)
        kargs.update(oargs)
        kargs.update(kwargs)
        kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
        o = self.buy(**kargs)

        if stopexec is not None:
            # low side / stop
            kargs = dict(data=data, price=stopprice, exectype=stopexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(stopargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = limitexec is None
            kargs[&#39;size&#39;] = o.size
            ostop = self.sell(**kargs)
        else:
            ostop = None

        if limitexec is not None:
            # high side / limit
            kargs = dict(data=data, price=limitprice, exectype=limitexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(limitargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = True
            kargs[&#39;size&#39;] = o.size
            olimit = self.sell(**kargs)
        else:
            olimit = None

        return [o, ostop, olimit]

    def sell_bracket(self, data=None,
                     size=None, price=None, plimit=None,
                     exectype=bt.Order.Limit, valid=None, tradeid=0,
                     trailamount=None, trailpercent=None,
                     oargs={},
                     stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                     limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                     **kwargs):
        &#39;&#39;&#39;
        Create a bracket order group (low side - buy order - high side). The
        default behavior is as follows:

          - Issue a **sell** order with execution ``Limit``

          - Issue a *high side* bracket **buy** order with execution ``Stop``

          - Issue a *low side* bracket **buy** order with execution ``Limit``.

        See ``bracket_buy`` for the meaning of the parameters

        High/Low Side orders can be suppressed by using:

          - ``stopexec=None`` to suppress the *high side*

          - ``limitexec=None`` to suppress the *low side*

        Returns:

          - A list containing the 3 orders [order, stop side, limit side]

          - If high/low orders have been suppressed the return value will still
            contain 3 orders, but those suppressed will have a value of
            ``None``
        &#39;&#39;&#39;

        kargs = dict(size=size,
                     data=data, price=price, plimit=plimit, exectype=exectype,
                     valid=valid, tradeid=tradeid,
                     trailamount=trailamount, trailpercent=trailpercent)
        kargs.update(oargs)
        kargs.update(kwargs)
        kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
        o = self.sell(**kargs)

        if stopexec is not None:
            # high side / stop
            kargs = dict(data=data, price=stopprice, exectype=stopexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(stopargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = limitexec is None  # transmit if last
            kargs[&#39;size&#39;] = o.size
            ostop = self.buy(**kargs)
        else:
            ostop = None

        if limitexec is not None:
            # low side / limit
            kargs = dict(data=data, price=limitprice, exectype=limitexec,
                         valid=valid, tradeid=tradeid)
            kargs.update(limitargs)
            kargs.update(kwargs)
            kargs[&#39;parent&#39;] = o
            kargs[&#39;transmit&#39;] = True
            kargs[&#39;size&#39;] = o.size
            olimit = self.buy(**kargs)
        else:
            olimit = None

        return [o, ostop, olimit]

    def order_target_size(self, data=None, target=0, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final size of ``target``

        The current ``position`` size is taken into account as the start point
        to achieve ``target``

          - If ``target`` &gt; ``pos.size`` -&gt; buy ``target - pos.size``

          - If ``target`` &lt; ``pos.size`` -&gt; sell ``pos.size - target``

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued (``target == position.size``)
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        if not target and possize:
            return self.close(data=data, size=possize, **kwargs)

        elif target &gt; possize:
            return self.buy(data=data, size=target - possize, **kwargs)

        elif target &lt; possize:
            return self.sell(data=data, size=possize - target, **kwargs)

        return None  # no execution target == possize

    def order_target_value(self, data=None, target=0.0, price=None, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final value of
        ``target``

        The current ``value`` is taken into account as the start point to
        achieve ``target``

          - If no ``target`` then close postion on data
          - If ``target`` &gt; ``value`` then buy on data
          - If ``target`` &lt; ``value`` then sell on data

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued
        &#39;&#39;&#39;

        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        if not target and possize:  # closing a position
            return self.close(data=data, size=possize, price=price, **kwargs)

        else:
            value = self.broker.getvalue(datas=[data])
            comminfo = self.broker.getcommissioninfo(data)

            # Make sure a price is there
            price = price if price is not None else data.close[0]

            if target &gt; value:
                size = comminfo.getsize(price, target - value)
                return self.buy(data=data, size=size, price=price, **kwargs)

            elif target &lt; value:
                size = comminfo.getsize(price, value - target)
                return self.sell(data=data, size=size, price=price, **kwargs)

        return None  # no execution size == possize

    def order_target_percent(self, data=None, target=0.0, **kwargs):
        &#39;&#39;&#39;
        Place an order to rebalance a position to have final value of
        ``target`` percentage of current portfolio ``value``

        ``target`` is expressed in decimal: ``0.05`` -&gt; ``5%``

        It uses ``order_target_value`` to execute the order.

        Example:
          - ``target=0.05`` and portfolio value is ``100``

          - The ``value`` to be reached is ``0.05 * 100 = 5``

          - ``5`` is passed as the ``target`` value to ``order_target_value``

        The current ``value`` is taken into account as the start point to
        achieve ``target``

        The ``position.size`` is used to determine if a position is ``long`` /
        ``short``

          - If ``target`` &gt; ``value``
            - buy if ``pos.size &gt;= 0`` (Increase a long position)
            - sell if ``pos.size &lt; 0`` (Increase a short position)

          - If ``target`` &lt; ``value``
            - sell if ``pos.size &gt;= 0`` (Decrease a long position)
            - buy if ``pos.size &lt; 0`` (Decrease a short position)

        It returns either:

          - The generated order

          or

          - ``None`` if no order has been issued (``target == position.size``)
        &#39;&#39;&#39;
        if isinstance(data, string_types):
            data = self.getdatabyname(data)
        elif data is None:
            data = self.data

        possize = self.getposition(data, self.broker).size
        target *= self.broker.getvalue()

        return self.order_target_value(data=data, target=target, **kwargs)

    def getposition(self, data=None, broker=None):
        &#39;&#39;&#39;
        Returns the current position for a given data in a given broker.

        If both are None, the main data and the default broker will be used

        A property ``position`` is also available
        &#39;&#39;&#39;
        data = data if data is not None else self.datas[0]
        broker = broker or self.broker
        return broker.getposition(data)

    position = property(getposition)

    def getpositionbyname(self, name=None, broker=None):
        &#39;&#39;&#39;
        Returns the current position for a given name in a given broker.

        If both are None, the main data and the default broker will be used

        A property ``positionbyname`` is also available
        &#39;&#39;&#39;
        data = self.datas[0] if not name else self.getdatabyname(name)
        broker = broker or self.broker
        return broker.getposition(data)

    positionbyname = property(getpositionbyname)

    def getpositions(self, broker=None):
        &#39;&#39;&#39;
        Returns the current by data positions directly from the broker

        If the given ``broker`` is None, the default broker will be used

        A property ``positions`` is also available
        &#39;&#39;&#39;
        broker = broker or self.broker
        return broker.positions

    positions = property(getpositions)

    def getpositionsbyname(self, broker=None):
        &#39;&#39;&#39;
        Returns the current by name positions directly from the broker

        If the given ``broker`` is None, the default broker will be used

        A property ``positionsbyname`` is also available
        &#39;&#39;&#39;
        broker = broker or self.broker
        positions = broker.positions

        posbyname = collections.OrderedDict()
        for name, data in iteritems(self.env.datasbyname):
            posbyname[name] = positions[data]

        return posbyname

    positionsbyname = property(getpositionsbyname)

    def _addsizer(self, sizer, *args, **kwargs):
        if sizer is None:
            self.setsizer(bt.sizers.FixedSize())
        else:
            self.setsizer(sizer(*args, **kwargs))

    def setsizer(self, sizer):
        &#39;&#39;&#39;
        Replace the default (fixed stake) sizer
        &#39;&#39;&#39;
        self._sizer = sizer
        sizer.set(self, self.broker)
        return sizer

    def getsizer(self):
        &#39;&#39;&#39;
        Returns the sizer which is in used if automatic statke calculation is
        used

        Also available as ``sizer``
        &#39;&#39;&#39;
        return self._sizer

    sizer = property(getsizer, setsizer)

    def getsizing(self, data=None, isbuy=True):
        &#39;&#39;&#39;
        Return the stake calculated by the sizer instance for the current
        situation
        &#39;&#39;&#39;
        data = data if data is not None else self.datas[0]
        return self._sizer.getsizing(data, isbuy=isbuy)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="backtrader.lineiterator.StrategyBase" href="lineiterator.html#backtrader.lineiterator.StrategyBase">StrategyBase</a></li>
<li><a title="backtrader.lineiterator.DataAccessor" href="lineiterator.html#backtrader.lineiterator.DataAccessor">DataAccessor</a></li>
<li><a title="backtrader.lineiterator.LineIterator" href="lineiterator.html#backtrader.lineiterator.LineIterator">LineIterator</a></li>
<li><a title="backtrader.lineseries.LineSeries" href="lineseries.html#backtrader.lineseries.LineSeries">LineSeries</a></li>
<li><a title="backtrader.lineroot.LineMultiple" href="lineroot.html#backtrader.lineroot.LineMultiple">LineMultiple</a></li>
<li><a title="backtrader.lineroot.LineRoot" href="lineroot.html#backtrader.lineroot.LineRoot">LineRoot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="backtrader.strategies.sma_crossover.MA_CrossOver" href="strategies/sma_crossover.html#backtrader.strategies.sma_crossover.MA_CrossOver">MA_CrossOver</a></li>
<li><a title="backtrader.strategy.SignalStrategy" href="#backtrader.strategy.SignalStrategy">SignalStrategy</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="backtrader.strategy.Strategy.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.aliased"><code class="name">var <span class="ident">aliased</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.csv"><code class="name">var <span class="ident">csv</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.frompackages"><code class="name">var <span class="ident">frompackages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.linealias"><code class="name">var <span class="ident">linealias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.packages"><code class="name">var <span class="ident">packages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.plotinfo"><code class="name">var <span class="ident">plotinfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="backtrader.strategy.Strategy.plotlines"><code class="name">var <span class="ident">plotlines</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="backtrader.strategy.Strategy.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"><p>Returns the current position for a given data in a given broker.</p>
<p>If both are None, the main data and the default broker will be used</p>
<p>A property <code>position</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getposition(self, data=None, broker=None):
    &#39;&#39;&#39;
    Returns the current position for a given data in a given broker.

    If both are None, the main data and the default broker will be used

    A property ``position`` is also available
    &#39;&#39;&#39;
    data = data if data is not None else self.datas[0]
    broker = broker or self.broker
    return broker.getposition(data)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.positionbyname"><code class="name">var <span class="ident">positionbyname</span></code></dt>
<dd>
<div class="desc"><p>Returns the current position for a given name in a given broker.</p>
<p>If both are None, the main data and the default broker will be used</p>
<p>A property <code>positionbyname</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositionbyname(self, name=None, broker=None):
    &#39;&#39;&#39;
    Returns the current position for a given name in a given broker.

    If both are None, the main data and the default broker will be used

    A property ``positionbyname`` is also available
    &#39;&#39;&#39;
    data = self.datas[0] if not name else self.getdatabyname(name)
    broker = broker or self.broker
    return broker.getposition(data)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.positions"><code class="name">var <span class="ident">positions</span></code></dt>
<dd>
<div class="desc"><p>Returns the current by data positions directly from the broker</p>
<p>If the given <code>broker</code> is None, the default broker will be used</p>
<p>A property <code>positions</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositions(self, broker=None):
    &#39;&#39;&#39;
    Returns the current by data positions directly from the broker

    If the given ``broker`` is None, the default broker will be used

    A property ``positions`` is also available
    &#39;&#39;&#39;
    broker = broker or self.broker
    return broker.positions</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.positionsbyname"><code class="name">var <span class="ident">positionsbyname</span></code></dt>
<dd>
<div class="desc"><p>Returns the current by name positions directly from the broker</p>
<p>If the given <code>broker</code> is None, the default broker will be used</p>
<p>A property <code>positionsbyname</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositionsbyname(self, broker=None):
    &#39;&#39;&#39;
    Returns the current by name positions directly from the broker

    If the given ``broker`` is None, the default broker will be used

    A property ``positionsbyname`` is also available
    &#39;&#39;&#39;
    broker = broker or self.broker
    positions = broker.positions

    posbyname = collections.OrderedDict()
    for name, data in iteritems(self.env.datasbyname):
        posbyname[name] = positions[data]

    return posbyname</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.sizer"><code class="name">var <span class="ident">sizer</span></code></dt>
<dd>
<div class="desc"><p>Returns the sizer which is in used if automatic statke calculation is
used</p>
<p>Also available as <code>sizer</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getsizer(self):
    &#39;&#39;&#39;
    Returns the sizer which is in used if automatic statke calculation is
    used

    Also available as ``sizer``
    &#39;&#39;&#39;
    return self._sizer</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="backtrader.strategy.Strategy.add_timer"><code class="name flex">
<span>def <span class="ident">add_timer</span></span>(<span>self, when, offset=datetime.timedelta(0), repeat=datetime.timedelta(0), weekdays=[], weekcarry=False, monthdays=[], monthcarry=True, allow=None, tzdata=None, cheat=False, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Note</strong>: can be called during <code>__init__</code> or <code>start</code></p>
<p>Schedules a timer to invoke either a specified callback or the
<code>notify_timer</code> of one or more strategies.</p>
<h2 id="arguments">Arguments</h2>
<ul>
<li>
<p><code>when</code>: can be</p>
</li>
<li>
<p><code>datetime.time</code> instance (see below <code>tzdata</code>)</p>
</li>
<li><code>bt.timer.SESSION_START</code> to reference a session start</li>
<li>
<p><code>bt.timer.SESSION_END</code> to reference a session end</p>
</li>
<li>
<p><code>offset</code> which must be a <code>datetime.timedelta</code> instance</p>
</li>
</ul>
<p>Used to offset the value <code>when</code>. It has a meaningful use in
combination with <code>SESSION_START</code> and <code>SESSION_END</code>, to indicated
things like a timer being called <code>15 minutes</code> after the session
start.</p>
<ul>
<li>
<p><code>repeat</code> which must be a <code>datetime.timedelta</code> instance</p>
<p>Indicates if after a 1st call, further calls will be scheduled
within the same session at the scheduled <code>repeat</code> delta</p>
<p>Once the timer goes over the end of the session it is reset to the
original value for <code>when</code></p>
</li>
<li>
<p><code>weekdays</code>: a <strong>sorted</strong> iterable with integers indicating on
which days (iso codes, Monday is 1, Sunday is 7) the timers can
be actually invoked</p>
<p>If not specified, the timer will be active on all days</p>
</li>
<li>
<p><code>weekcarry</code> (default: <code>False</code>). If <code>True</code> and the weekday was
not seen (ex: trading holiday), the timer will be executed on the
next day (even if in a new week)</p>
</li>
<li>
<p><code>monthdays</code>: a <strong>sorted</strong> iterable with integers indicating on
which days of the month a timer has to be executed. For example
always on day <em>15</em> of the month</p>
<p>If not specified, the timer will be active on all days</p>
</li>
<li>
<p><code>monthcarry</code> (default: <code>True</code>). If the day was not seen
(weekend, trading holiday), the timer will be executed on the next
available day.</p>
</li>
<li>
<p><code>allow</code> (default: <code>None</code>). A callback which receives a
`datetime.date<code> instance and returns </code>True`` if the date is
allowed for timers or else returns <code>False</code></p>
</li>
<li>
<p><code>tzdata</code> which can be either <code>None</code> (default), a <code>pytz</code>
instance or a <code>data feed</code> instance.</p>
<p><code>None</code>: <code>when</code> is interpreted at face value (which translates
to handling it as if it where UTC even if it's not)</p>
<p><code>pytz</code> instance: <code>when</code> will be interpreted as being specified
in the local time specified by the timezone instance.</p>
<p><code>data feed</code> instance: <code>when</code> will be interpreted as being
specified in the local time specified by the <code>tz</code> parameter of
the data feed instance.</p>
<p><strong>Note</strong>: If <code>when</code> is either <code>SESSION_START</code> or
<code>SESSION_END</code> and <code>tzdata</code> is <code>None</code>, the 1st <em>data feed</em>
in the system (aka <code>self.data0</code>) will be used as the reference
to find out the session times.</p>
</li>
<li>
<p><code>cheat</code> (default <code>False</code>) if <code>True</code> the timer will be called
before the broker has a chance to evaluate the orders. This opens
the chance to issue orders based on opening price for example right
before the session starts</p>
</li>
<li>
<p><code>*args</code>: any extra args will be passed to <code>notify_timer</code></p>
</li>
<li>
<p><code>**kwargs</code>: any extra kwargs will be passed to <code>notify_timer</code></p>
</li>
</ul>
<p>Return Value:</p>
<ul>
<li>The created timer</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_timer(self, when,
              offset=datetime.timedelta(), repeat=datetime.timedelta(),
              weekdays=[], weekcarry=False,
              monthdays=[], monthcarry=True,
              allow=None,
              tzdata=None, cheat=False,
              *args, **kwargs):
    &#39;&#39;&#39;
    **Note**: can be called during ``__init__`` or ``start``

    Schedules a timer to invoke either a specified callback or the
    ``notify_timer`` of one or more strategies.

    Arguments:

      - ``when``: can be

        - ``datetime.time`` instance (see below ``tzdata``)
        - ``bt.timer.SESSION_START`` to reference a session start
        - ``bt.timer.SESSION_END`` to reference a session end

     - ``offset`` which must be a ``datetime.timedelta`` instance

       Used to offset the value ``when``. It has a meaningful use in
       combination with ``SESSION_START`` and ``SESSION_END``, to indicated
       things like a timer being called ``15 minutes`` after the session
       start.

      - ``repeat`` which must be a ``datetime.timedelta`` instance

        Indicates if after a 1st call, further calls will be scheduled
        within the same session at the scheduled ``repeat`` delta

        Once the timer goes over the end of the session it is reset to the
        original value for ``when``

      - ``weekdays``: a **sorted** iterable with integers indicating on
        which days (iso codes, Monday is 1, Sunday is 7) the timers can
        be actually invoked

        If not specified, the timer will be active on all days

      - ``weekcarry`` (default: ``False``). If ``True`` and the weekday was
        not seen (ex: trading holiday), the timer will be executed on the
        next day (even if in a new week)

      - ``monthdays``: a **sorted** iterable with integers indicating on
        which days of the month a timer has to be executed. For example
        always on day *15* of the month

        If not specified, the timer will be active on all days

      - ``monthcarry`` (default: ``True``). If the day was not seen
        (weekend, trading holiday), the timer will be executed on the next
        available day.

      - ``allow`` (default: ``None``). A callback which receives a
        `datetime.date`` instance and returns ``True`` if the date is
        allowed for timers or else returns ``False``

      - ``tzdata`` which can be either ``None`` (default), a ``pytz``
        instance or a ``data feed`` instance.

        ``None``: ``when`` is interpreted at face value (which translates
        to handling it as if it where UTC even if it&#39;s not)

        ``pytz`` instance: ``when`` will be interpreted as being specified
        in the local time specified by the timezone instance.

        ``data feed`` instance: ``when`` will be interpreted as being
        specified in the local time specified by the ``tz`` parameter of
        the data feed instance.

        **Note**: If ``when`` is either ``SESSION_START`` or
          ``SESSION_END`` and ``tzdata`` is ``None``, the 1st *data feed*
          in the system (aka ``self.data0``) will be used as the reference
          to find out the session times.

      - ``cheat`` (default ``False``) if ``True`` the timer will be called
        before the broker has a chance to evaluate the orders. This opens
        the chance to issue orders based on opening price for example right
        before the session starts

      - ``*args``: any extra args will be passed to ``notify_timer``

      - ``**kwargs``: any extra kwargs will be passed to ``notify_timer``

    Return Value:

      - The created timer

    &#39;&#39;&#39;
    return self.cerebro._add_timer(
        owner=self, when=when, offset=offset, repeat=repeat,
        weekdays=weekdays, weekcarry=weekcarry,
        monthdays=monthdays, monthcarry=monthcarry,
        allow=allow,
        tzdata=tzdata, strats=False, cheat=cheat,
        *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.buy"><code class="name flex">
<span>def <span class="ident">buy</span></span>(<span>self, data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, oco=None, trailamount=None, trailpercent=None, parent=None, transmit=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a buy (long) order and send it to the broker</p>
<ul>
<li>
<p><code>data</code> (default: <code>None</code>)</p>
<p>For which data the order has to be created. If <code>None</code> then the
first data in the system, <code>self.datas[0] or self.data0</code> (aka
<code>self.data</code>) will be used</p>
</li>
<li>
<p><code>size</code> (default: <code>None</code>)</p>
<p>Size to use (positive) of units of data to use for the order.</p>
<p>If <code>None</code> the <code>sizer</code> instance retrieved via <code>getsizer</code> will
be used to determine the size.</p>
</li>
<li>
<p><code>price</code> (default: <code>None</code>)</p>
<p>Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)</p>
<p><code>None</code> is valid for <code>Market</code> and <code>Close</code> orders (the market
determines the price)</p>
<p>For <code>Limit</code>, <code>Stop</code> and <code>StopLimit</code> orders this value
determines the trigger point (in the case of <code>Limit</code> the trigger
is obviously at which price the order should be matched)</p>
</li>
<li>
<p><code>plimit</code> (default: <code>None</code>)</p>
<p>Only applicable to <code>StopLimit</code> orders. This is the price at which
to set the implicit <em>Limit</em> order, once the <em>Stop</em> has been
triggered (for which <code>price</code> has been used)</p>
</li>
<li>
<p><code>trailamount</code> (default: <code>None</code>)</p>
<p>If the order type is StopTrail or StopTrailLimit, this is an
absolute amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop</p>
</li>
<li>
<p><code>trailpercent</code> (default: <code>None</code>)</p>
<p>If the order type is StopTrail or StopTrailLimit, this is a
percentage amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop (if <code>trailamount</code> is also specified it will be used)</p>
</li>
<li>
<p><code>exectype</code> (default: <code>None</code>)</p>
<p>Possible values:</p>
<ul>
<li>
<p><code>Order.Market</code> or <code>None</code>. A market order will be executed
with the next available price. In backtesting it will be the
opening price of the next bar</p>
</li>
<li>
<p><code>Order.Limit</code>. An order which can only be executed at the given
<code>price</code> or better</p>
</li>
<li>
<p><code>Order.Stop</code>. An order which is triggered at <code>price</code> and
executed like an <code>Order.Market</code> order</p>
</li>
<li>
<p><code>Order.StopLimit</code>. An order which is triggered at <code>price</code> and
executed as an implicit <em>Limit</em> order with price given by
<code>pricelimit</code></p>
</li>
<li>
<p><code>Order.Close</code>. An order which can only be executed with the
closing price of the session (usually during a closing auction)</p>
</li>
<li>
<p><code>Order.StopTrail</code>. An order which is triggered at <code>price</code>
minus <code>trailamount</code> (or <code>trailpercent</code>) and which is updated
if the price moves away from the stop</p>
</li>
<li>
<p><code>Order.StopTrailLimit</code>. An order which is triggered at
<code>price</code> minus <code>trailamount</code> (or <code>trailpercent</code>) and which
is updated if the price moves away from the stop</p>
</li>
</ul>
</li>
<li>
<p><code>valid</code> (default: <code>None</code>)</p>
<p>Possible values:</p>
<ul>
<li>
<p><code>None</code>: this generates an order that will not expire (aka
<em>Good till cancel</em>) and remain in the market until matched or
canceled. In reality brokers tend to impose a temporal limit,
but this is usually so far away in time to consider it as not
expiring</p>
</li>
<li>
<p><code>datetime.datetime</code> or <code>datetime.date</code> instance: the date
will be used to generate an order valid until the given
datetime (aka <em>good till date</em>)</p>
</li>
<li>
<p><code>Order.DAY</code> or <code>0</code> or <code>timedelta()</code>: a day valid until
the <em>End of the Session</em> (aka <em>day</em> order) will be generated</p>
</li>
<li>
<p><code>numeric value</code>: This is assumed to be a value corresponding
to a datetime in <code>matplotlib</code> coding (the one used by
<code><a title="backtrader" href="index.html">backtrader</a></code>) and will used to generate an order valid until
that time (<em>good till date</em>)</p>
</li>
</ul>
</li>
<li>
<p><code>tradeid</code> (default: <code>0</code>)</p>
<p>This is an internal value applied by <code><a title="backtrader" href="index.html">backtrader</a></code> to keep track
of overlapping trades on the same asset. This <code>tradeid</code> is sent
back to the <em>strategy</em> when notifying changes to the status of the
orders.</p>
</li>
<li>
<p><code>oco</code> (default: <code>None</code>)</p>
<p>Another <code>order</code> instance. This order will become part of an OCO
(Order Cancel Others) group. The execution of one of the orders,
immediately cancels all others in the same group</p>
</li>
<li>
<p><code>parent</code> (default: <code>None</code>)</p>
<p>Controls the relationship of a group of orders, for example a buy
which is bracketed by a high-side limit sell and a low side stop
sell. The high/low side orders remain inactive until the parent
order has been either executed (they become active) or is
canceled/expires (the children are also canceled) bracket orders
have the same size</p>
</li>
<li>
<p><code>transmit</code> (default: <code>True</code>)</p>
<p>Indicates if the order has to be <strong>transmitted</strong>, ie: not only
placed in the broker but also issued. This is meant for example to
control bracket orders, in which one disables the transmission for
the parent and 1st set of children and activates it for the last
children, which triggers the full placement of all bracket orders.</p>
</li>
<li>
<p><code>**kwargs</code>: additional broker implementations may support extra
parameters. <code><a title="backtrader" href="index.html">backtrader</a></code> will pass the <em>kwargs</em> down to the
created order objects</p>
<p>Example: if the 4 order execution types directly supported by
<code><a title="backtrader" href="index.html">backtrader</a></code> are not enough, in the case of for example
<em>Interactive Brokers</em> the following could be passed as <em>kwargs</em>::</p>
<p>orderType='LIT', lmtPrice=10.0, auxPrice=9.8</p>
<p>This would override the settings created by <code><a title="backtrader" href="index.html">backtrader</a></code> and
generate a <code>LIMIT IF TOUCHED</code> order with a <em>touched</em> price of 9.8
and a <em>limit</em> price of 10.0.</p>
</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>the submitted order</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buy(self, data=None,
        size=None, price=None, plimit=None,
        exectype=None, valid=None, tradeid=0, oco=None,
        trailamount=None, trailpercent=None,
        parent=None, transmit=True,
        **kwargs):
    &#39;&#39;&#39;Create a buy (long) order and send it to the broker

      - ``data`` (default: ``None``)

        For which data the order has to be created. If ``None`` then the
        first data in the system, ``self.datas[0] or self.data0`` (aka
        ``self.data``) will be used

      - ``size`` (default: ``None``)

        Size to use (positive) of units of data to use for the order.

        If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
        be used to determine the size.

      - ``price`` (default: ``None``)

        Price to use (live brokers may place restrictions on the actual
        format if it does not comply to minimum tick size requirements)

        ``None`` is valid for ``Market`` and ``Close`` orders (the market
        determines the price)

        For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
        determines the trigger point (in the case of ``Limit`` the trigger
        is obviously at which price the order should be matched)

      - ``plimit`` (default: ``None``)

        Only applicable to ``StopLimit`` orders. This is the price at which
        to set the implicit *Limit* order, once the *Stop* has been
        triggered (for which ``price`` has been used)

      - ``trailamount`` (default: ``None``)

        If the order type is StopTrail or StopTrailLimit, this is an
        absolute amount which determines the distance to the price (below
        for a Sell order and above for a buy order) to keep the trailing
        stop

      - ``trailpercent`` (default: ``None``)

        If the order type is StopTrail or StopTrailLimit, this is a
        percentage amount which determines the distance to the price (below
        for a Sell order and above for a buy order) to keep the trailing
        stop (if ``trailamount`` is also specified it will be used)

      - ``exectype`` (default: ``None``)

        Possible values:

        - ``Order.Market`` or ``None``. A market order will be executed
          with the next available price. In backtesting it will be the
          opening price of the next bar

        - ``Order.Limit``. An order which can only be executed at the given
          ``price`` or better

        - ``Order.Stop``. An order which is triggered at ``price`` and
          executed like an ``Order.Market`` order

        - ``Order.StopLimit``. An order which is triggered at ``price`` and
          executed as an implicit *Limit* order with price given by
          ``pricelimit``

        - ``Order.Close``. An order which can only be executed with the
          closing price of the session (usually during a closing auction)

        - ``Order.StopTrail``. An order which is triggered at ``price``
          minus ``trailamount`` (or ``trailpercent``) and which is updated
          if the price moves away from the stop

        - ``Order.StopTrailLimit``. An order which is triggered at
          ``price`` minus ``trailamount`` (or ``trailpercent``) and which
          is updated if the price moves away from the stop

      - ``valid`` (default: ``None``)

        Possible values:

          - ``None``: this generates an order that will not expire (aka
            *Good till cancel*) and remain in the market until matched or
            canceled. In reality brokers tend to impose a temporal limit,
            but this is usually so far away in time to consider it as not
            expiring

          - ``datetime.datetime`` or ``datetime.date`` instance: the date
            will be used to generate an order valid until the given
            datetime (aka *good till date*)

          - ``Order.DAY`` or ``0`` or ``timedelta()``: a day valid until
            the *End of the Session* (aka *day* order) will be generated

          - ``numeric value``: This is assumed to be a value corresponding
            to a datetime in ``matplotlib`` coding (the one used by
            ``backtrader``) and will used to generate an order valid until
            that time (*good till date*)

      - ``tradeid`` (default: ``0``)

        This is an internal value applied by ``backtrader`` to keep track
        of overlapping trades on the same asset. This ``tradeid`` is sent
        back to the *strategy* when notifying changes to the status of the
        orders.

      - ``oco`` (default: ``None``)

        Another ``order`` instance. This order will become part of an OCO
        (Order Cancel Others) group. The execution of one of the orders,
        immediately cancels all others in the same group

      - ``parent`` (default: ``None``)

        Controls the relationship of a group of orders, for example a buy
        which is bracketed by a high-side limit sell and a low side stop
        sell. The high/low side orders remain inactive until the parent
        order has been either executed (they become active) or is
        canceled/expires (the children are also canceled) bracket orders
        have the same size

      - ``transmit`` (default: ``True``)

        Indicates if the order has to be **transmitted**, ie: not only
        placed in the broker but also issued. This is meant for example to
        control bracket orders, in which one disables the transmission for
        the parent and 1st set of children and activates it for the last
        children, which triggers the full placement of all bracket orders.

      - ``**kwargs``: additional broker implementations may support extra
        parameters. ``backtrader`` will pass the *kwargs* down to the
        created order objects

        Example: if the 4 order execution types directly supported by
        ``backtrader`` are not enough, in the case of for example
        *Interactive Brokers* the following could be passed as *kwargs*::

          orderType=&#39;LIT&#39;, lmtPrice=10.0, auxPrice=9.8

        This would override the settings created by ``backtrader`` and
        generate a ``LIMIT IF TOUCHED`` order with a *touched* price of 9.8
        and a *limit* price of 10.0.

    Returns:
      - the submitted order

    &#39;&#39;&#39;
    if isinstance(data, string_types):
        data = self.getdatabyname(data)

    data = data if data is not None else self.datas[0]
    size = size if size is not None else self.getsizing(data, isbuy=True)

    if size:
        return self.broker.buy(
            self, data,
            size=abs(size), price=price, plimit=plimit,
            exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
            trailamount=trailamount, trailpercent=trailpercent,
            parent=parent, transmit=transmit,
            **kwargs)

    return None</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.buy_bracket"><code class="name flex">
<span>def <span class="ident">buy_bracket</span></span>(<span>self, data=None, size=None, price=None, plimit=None, exectype=2, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=3, stopargs={}, limitprice=None, limitexec=2, limitargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a bracket order group (low side - buy order - high side). The
default behavior is as follows:</p>
<ul>
<li>
<p>Issue a <strong>buy</strong> order with execution <code>Limit</code></p>
</li>
<li>
<p>Issue a <em>low side</em> bracket <strong>sell</strong> order with execution <code>Stop</code></p>
</li>
<li>
<p>Issue a <em>high side</em> bracket <strong>sell</strong> order with execution
<code>Limit</code>.</p>
</li>
</ul>
<p>See below for the different parameters</p>
<ul>
<li>
<p><code>data</code> (default: <code>None</code>)</p>
<p>For which data the order has to be created. If <code>None</code> then the
first data in the system, <code>self.datas[0] or self.data0</code> (aka
<code>self.data</code>) will be used</p>
</li>
<li>
<p><code>size</code> (default: <code>None</code>)</p>
<p>Size to use (positive) of units of data to use for the order.</p>
<p>If <code>None</code> the <code>sizer</code> instance retrieved via <code>getsizer</code> will
be used to determine the size.</p>
<p><strong>Note</strong>: The same size is applied to all 3 orders of the bracket</p>
</li>
<li>
<p><code>price</code> (default: <code>None</code>)</p>
<p>Price to use (live brokers may place restrictions on the actual
format if it does not comply to minimum tick size requirements)</p>
<p><code>None</code> is valid for <code>Market</code> and <code>Close</code> orders (the market
determines the price)</p>
<p>For <code>Limit</code>, <code>Stop</code> and <code>StopLimit</code> orders this value
determines the trigger point (in the case of <code>Limit</code> the trigger
is obviously at which price the order should be matched)</p>
</li>
<li>
<p><code>plimit</code> (default: <code>None</code>)</p>
<p>Only applicable to <code>StopLimit</code> orders. This is the price at which
to set the implicit <em>Limit</em> order, once the <em>Stop</em> has been
triggered (for which <code>price</code> has been used)</p>
</li>
<li>
<p><code>trailamount</code> (default: <code>None</code>)</p>
<p>If the order type is StopTrail or StopTrailLimit, this is an
absolute amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop</p>
</li>
<li>
<p><code>trailpercent</code> (default: <code>None</code>)</p>
<p>If the order type is StopTrail or StopTrailLimit, this is a
percentage amount which determines the distance to the price (below
for a Sell order and above for a buy order) to keep the trailing
stop (if <code>trailamount</code> is also specified it will be used)</p>
</li>
<li>
<p><code>exectype</code> (default: <code>bt.Order.Limit</code>)</p>
<p>Possible values: (see the documentation for the method <code>buy</code></p>
</li>
<li>
<p><code>valid</code> (default: <code>None</code>)</p>
<p>Possible values: (see the documentation for the method <code>buy</code></p>
</li>
<li>
<p><code>tradeid</code> (default: <code>0</code>)</p>
<p>Possible values: (see the documentation for the method <code>buy</code></p>
</li>
<li>
<p><code>oargs</code> (default: <code>{}</code>)</p>
<p>Specific keyword arguments (in a <code>dict</code>) to pass to the main side
order. Arguments from the default <code>**kwargs</code> will be applied on
top of this.</p>
</li>
<li>
<p><code>**kwargs</code>: additional broker implementations may support extra
parameters. <code><a title="backtrader" href="index.html">backtrader</a></code> will pass the <em>kwargs</em> down to the
created order objects</p>
<p>Possible values: (see the documentation for the method <code>buy</code></p>
<p><strong>Note</strong>: this <code>kwargs</code> will be applied to the 3 orders of a
bracket. See below for specific keyword arguments for the low and
high side orders</p>
</li>
<li>
<p><code>stopprice</code> (default: <code>None</code>)</p>
<p>Specific price for the <em>low side</em> stop order</p>
</li>
<li>
<p><code>stopexec</code> (default: <code>bt.Order.Stop</code>)</p>
<p>Specific execution type for the <em>low side</em> order</p>
</li>
<li>
<p><code>stopargs</code> (default: <code>{}</code>)</p>
<p>Specific keyword arguments (in a <code>dict</code>) to pass to the low side
order. Arguments from the default <code>**kwargs</code> will be applied on
top of this.</p>
</li>
<li>
<p><code>limitprice</code> (default: <code>None</code>)</p>
<p>Specific price for the <em>high side</em> stop order</p>
</li>
<li>
<p><code>stopexec</code> (default: <code>bt.Order.Limit</code>)</p>
<p>Specific execution type for the <em>high side</em> order</p>
</li>
<li>
<p><code>limitargs</code> (default: <code>{}</code>)</p>
<p>Specific keyword arguments (in a <code>dict</code>) to pass to the high side
order. Arguments from the default <code>**kwargs</code> will be applied on
top of this.</p>
</li>
</ul>
<p>High/Low Side orders can be suppressed by using:</p>
<ul>
<li>
<p><code>limitexec=None</code> to suppress the <em>high side</em></p>
</li>
<li>
<p><code>stopexec=None</code> to suppress the <em>low side</em></p>
</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>
<p>A list containing the 3 orders [order, stop side, limit side]</p>
</li>
<li>
<p>If high/low orders have been suppressed the return value will still
contain 3 orders, but those suppressed will have a value of
<code>None</code></p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buy_bracket(self, data=None, size=None, price=None, plimit=None,
                exectype=bt.Order.Limit, valid=None, tradeid=0,
                trailamount=None, trailpercent=None, oargs={},
                stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                **kwargs):
    &#39;&#39;&#39;
    Create a bracket order group (low side - buy order - high side). The
    default behavior is as follows:

      - Issue a **buy** order with execution ``Limit``

      - Issue a *low side* bracket **sell** order with execution ``Stop``

      - Issue a *high side* bracket **sell** order with execution
        ``Limit``.

    See below for the different parameters

      - ``data`` (default: ``None``)

        For which data the order has to be created. If ``None`` then the
        first data in the system, ``self.datas[0] or self.data0`` (aka
        ``self.data``) will be used

      - ``size`` (default: ``None``)

        Size to use (positive) of units of data to use for the order.

        If ``None`` the ``sizer`` instance retrieved via ``getsizer`` will
        be used to determine the size.

        **Note**: The same size is applied to all 3 orders of the bracket

      - ``price`` (default: ``None``)

        Price to use (live brokers may place restrictions on the actual
        format if it does not comply to minimum tick size requirements)

        ``None`` is valid for ``Market`` and ``Close`` orders (the market
        determines the price)

        For ``Limit``, ``Stop`` and ``StopLimit`` orders this value
        determines the trigger point (in the case of ``Limit`` the trigger
        is obviously at which price the order should be matched)

      - ``plimit`` (default: ``None``)

        Only applicable to ``StopLimit`` orders. This is the price at which
        to set the implicit *Limit* order, once the *Stop* has been
        triggered (for which ``price`` has been used)

      - ``trailamount`` (default: ``None``)

        If the order type is StopTrail or StopTrailLimit, this is an
        absolute amount which determines the distance to the price (below
        for a Sell order and above for a buy order) to keep the trailing
        stop

      - ``trailpercent`` (default: ``None``)

        If the order type is StopTrail or StopTrailLimit, this is a
        percentage amount which determines the distance to the price (below
        for a Sell order and above for a buy order) to keep the trailing
        stop (if ``trailamount`` is also specified it will be used)

      - ``exectype`` (default: ``bt.Order.Limit``)

        Possible values: (see the documentation for the method ``buy``

      - ``valid`` (default: ``None``)

        Possible values: (see the documentation for the method ``buy``

      - ``tradeid`` (default: ``0``)

        Possible values: (see the documentation for the method ``buy``

      - ``oargs`` (default: ``{}``)

        Specific keyword arguments (in a ``dict``) to pass to the main side
        order. Arguments from the default ``**kwargs`` will be applied on
        top of this.

      - ``**kwargs``: additional broker implementations may support extra
        parameters. ``backtrader`` will pass the *kwargs* down to the
        created order objects

        Possible values: (see the documentation for the method ``buy``

        **Note**: this ``kwargs`` will be applied to the 3 orders of a
        bracket. See below for specific keyword arguments for the low and
        high side orders

      - ``stopprice`` (default: ``None``)

        Specific price for the *low side* stop order

      - ``stopexec`` (default: ``bt.Order.Stop``)

        Specific execution type for the *low side* order

      - ``stopargs`` (default: ``{}``)

        Specific keyword arguments (in a ``dict``) to pass to the low side
        order. Arguments from the default ``**kwargs`` will be applied on
        top of this.

      - ``limitprice`` (default: ``None``)

        Specific price for the *high side* stop order

      - ``stopexec`` (default: ``bt.Order.Limit``)

        Specific execution type for the *high side* order

      - ``limitargs`` (default: ``{}``)

        Specific keyword arguments (in a ``dict``) to pass to the high side
        order. Arguments from the default ``**kwargs`` will be applied on
        top of this.

    High/Low Side orders can be suppressed by using:

      - ``limitexec=None`` to suppress the *high side*

      - ``stopexec=None`` to suppress the *low side*

    Returns:

      - A list containing the 3 orders [order, stop side, limit side]

      - If high/low orders have been suppressed the return value will still
        contain 3 orders, but those suppressed will have a value of
        ``None``
    &#39;&#39;&#39;

    kargs = dict(size=size,
                 data=data, price=price, plimit=plimit, exectype=exectype,
                 valid=valid, tradeid=tradeid,
                 trailamount=trailamount, trailpercent=trailpercent)
    kargs.update(oargs)
    kargs.update(kwargs)
    kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
    o = self.buy(**kargs)

    if stopexec is not None:
        # low side / stop
        kargs = dict(data=data, price=stopprice, exectype=stopexec,
                     valid=valid, tradeid=tradeid)
        kargs.update(stopargs)
        kargs.update(kwargs)
        kargs[&#39;parent&#39;] = o
        kargs[&#39;transmit&#39;] = limitexec is None
        kargs[&#39;size&#39;] = o.size
        ostop = self.sell(**kargs)
    else:
        ostop = None

    if limitexec is not None:
        # high side / limit
        kargs = dict(data=data, price=limitprice, exectype=limitexec,
                     valid=valid, tradeid=tradeid)
        kargs.update(limitargs)
        kargs.update(kwargs)
        kargs[&#39;parent&#39;] = o
        kargs[&#39;transmit&#39;] = True
        kargs[&#39;size&#39;] = o.size
        olimit = self.sell(**kargs)
    else:
        olimit = None

    return [o, ostop, olimit]</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancels the order in the broker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, order):
    &#39;&#39;&#39;Cancels the order in the broker&#39;&#39;&#39;
    self.broker.cancel(order)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    self._orders.extend(self._orderspending)
    self._orderspending = list()
    self._tradespending = list()</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self, data=None, size=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Counters a long/short position closing it</p>
<p>See the documentation for <code>buy</code> for an explanation of the parameters</p>
<h2 id="note">Note</h2>
<ul>
<li><code>size</code>: automatically calculated from the existing position if
not provided (default: <code>None</code>) by the caller</li>
</ul>
<p>Returns: the submitted order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self, data=None, size=None, **kwargs):
    &#39;&#39;&#39;
    Counters a long/short position closing it

    See the documentation for ``buy`` for an explanation of the parameters

    Note:

      - ``size``: automatically calculated from the existing position if
        not provided (default: ``None``) by the caller

    Returns: the submitted order
    &#39;&#39;&#39;
    if isinstance(data, string_types):
        data = self.getdatabyname(data)
    elif data is None:
        data = self.data

    possize = self.getposition(data, self.broker).size
    size = abs(size if size is not None else possize)

    if possize &gt; 0:
        return self.sell(data=data, size=size, **kwargs)
    elif possize &lt; 0:
        return self.buy(data=data, size=size, **kwargs)

    return None</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getdatabyname"><code class="name flex">
<span>def <span class="ident">getdatabyname</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a given data by name using the environment (cerebro)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getdatabyname(self, name):
    &#39;&#39;&#39;
    Returns a given data by name using the environment (cerebro)
    &#39;&#39;&#39;
    return self.env.datasbyname[name]</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getdatanames"><code class="name flex">
<span>def <span class="ident">getdatanames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the existing data names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getdatanames(self):
    &#39;&#39;&#39;
    Returns a list of the existing data names
    &#39;&#39;&#39;
    return keys(self.env.datasbyname)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getposition"><code class="name flex">
<span>def <span class="ident">getposition</span></span>(<span>self, data=None, broker=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current position for a given data in a given broker.</p>
<p>If both are None, the main data and the default broker will be used</p>
<p>A property <code>position</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getposition(self, data=None, broker=None):
    &#39;&#39;&#39;
    Returns the current position for a given data in a given broker.

    If both are None, the main data and the default broker will be used

    A property ``position`` is also available
    &#39;&#39;&#39;
    data = data if data is not None else self.datas[0]
    broker = broker or self.broker
    return broker.getposition(data)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getpositionbyname"><code class="name flex">
<span>def <span class="ident">getpositionbyname</span></span>(<span>self, name=None, broker=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current position for a given name in a given broker.</p>
<p>If both are None, the main data and the default broker will be used</p>
<p>A property <code>positionbyname</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositionbyname(self, name=None, broker=None):
    &#39;&#39;&#39;
    Returns the current position for a given name in a given broker.

    If both are None, the main data and the default broker will be used

    A property ``positionbyname`` is also available
    &#39;&#39;&#39;
    data = self.datas[0] if not name else self.getdatabyname(name)
    broker = broker or self.broker
    return broker.getposition(data)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getpositions"><code class="name flex">
<span>def <span class="ident">getpositions</span></span>(<span>self, broker=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current by data positions directly from the broker</p>
<p>If the given <code>broker</code> is None, the default broker will be used</p>
<p>A property <code>positions</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositions(self, broker=None):
    &#39;&#39;&#39;
    Returns the current by data positions directly from the broker

    If the given ``broker`` is None, the default broker will be used

    A property ``positions`` is also available
    &#39;&#39;&#39;
    broker = broker or self.broker
    return broker.positions</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getpositionsbyname"><code class="name flex">
<span>def <span class="ident">getpositionsbyname</span></span>(<span>self, broker=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current by name positions directly from the broker</p>
<p>If the given <code>broker</code> is None, the default broker will be used</p>
<p>A property <code>positionsbyname</code> is also available</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getpositionsbyname(self, broker=None):
    &#39;&#39;&#39;
    Returns the current by name positions directly from the broker

    If the given ``broker`` is None, the default broker will be used

    A property ``positionsbyname`` is also available
    &#39;&#39;&#39;
    broker = broker or self.broker
    positions = broker.positions

    posbyname = collections.OrderedDict()
    for name, data in iteritems(self.env.datasbyname):
        posbyname[name] = positions[data]

    return posbyname</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getsizer"><code class="name flex">
<span>def <span class="ident">getsizer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sizer which is in used if automatic statke calculation is
used</p>
<p>Also available as <code>sizer</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getsizer(self):
    &#39;&#39;&#39;
    Returns the sizer which is in used if automatic statke calculation is
    used

    Also available as ``sizer``
    &#39;&#39;&#39;
    return self._sizer</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getsizing"><code class="name flex">
<span>def <span class="ident">getsizing</span></span>(<span>self, data=None, isbuy=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the stake calculated by the sizer instance for the current
situation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getsizing(self, data=None, isbuy=True):
    &#39;&#39;&#39;
    Return the stake calculated by the sizer instance for the current
    situation
    &#39;&#39;&#39;
    data = data if data is not None else self.datas[0]
    return self._sizer.getsizing(data, isbuy=isbuy)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getwriterheaders"><code class="name flex">
<span>def <span class="ident">getwriterheaders</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getwriterheaders(self):
    self.indobscsv = [self]

    indobs = itertools.chain(
        self.getindicators_lines(), self.getobservers())
    self.indobscsv.extend(filter(lambda x: x.csv, indobs))

    headers = list()

    # prepare the indicators/observers data headers
    for iocsv in self.indobscsv:
        name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
        headers.append(name)
        headers.append(&#39;len&#39;)
        headers.extend(iocsv.getlinealiases())

    return headers</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getwriterinfo"><code class="name flex">
<span>def <span class="ident">getwriterinfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getwriterinfo(self):
    wrinfo = AutoOrderedDict()

    wrinfo[&#39;Params&#39;] = self.p._getkwargs()

    sections = [
        [&#39;Indicators&#39;, self.getindicators_lines()],
        [&#39;Observers&#39;, self.getobservers()]
    ]

    for sectname, sectitems in sections:
        sinfo = wrinfo[sectname]
        for item in sectitems:
            itname = item.__class__.__name__
            sinfo[itname].Lines = item.lines.getlinealiases() or None
            sinfo[itname].Params = item.p._getkwargs() or None

    ainfo = wrinfo.Analyzers

    # Internal Value Analyzer
    ainfo.Value.Begin = self.broker.startingcash
    ainfo.Value.End = self.broker.getvalue()

    # no slave analyzers for writer
    for aname, analyzer in self.analyzers.getitems():
        ainfo[aname].Params = analyzer.p._getkwargs() or None
        ainfo[aname].Analysis = analyzer.get_analysis()

    return wrinfo</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.getwritervalues"><code class="name flex">
<span>def <span class="ident">getwritervalues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getwritervalues(self):
    values = list()

    for iocsv in self.indobscsv:
        name = iocsv.plotinfo.plotname or iocsv.__class__.__name__
        values.append(name)
        lio = len(iocsv)
        values.append(lio)
        if lio:
            values.extend(map(lambda l: l[0], iocsv.lines.itersize()))
        else:
            values.extend([&#39;&#39;] * iocsv.lines.size())

    return values</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.next_open"><code class="name flex">
<span>def <span class="ident">next_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_open(self):
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.nextstart_open"><code class="name flex">
<span>def <span class="ident">nextstart_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextstart_open(self):
    self.next_open()</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_cashvalue"><code class="name flex">
<span>def <span class="ident">notify_cashvalue</span></span>(<span>self, cash, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives the current fund value, value status of the strategy's broker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_cashvalue(self, cash, value):
    &#39;&#39;&#39;
    Receives the current fund value, value status of the strategy&#39;s broker
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_data"><code class="name flex">
<span>def <span class="ident">notify_data</span></span>(<span>self, data, status, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a notification from data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_data(self, data, status, *args, **kwargs):
    &#39;&#39;&#39;Receives a notification from data&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_fund"><code class="name flex">
<span>def <span class="ident">notify_fund</span></span>(<span>self, cash, value, fundvalue, shares)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives the current cash, value, fundvalue and fund shares</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_fund(self, cash, value, fundvalue, shares):
    &#39;&#39;&#39;
    Receives the current cash, value, fundvalue and fund shares
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_order"><code class="name flex">
<span>def <span class="ident">notify_order</span></span>(<span>self, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives an order whenever there has been a change in one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_order(self, order):
    &#39;&#39;&#39;
    Receives an order whenever there has been a change in one
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_store"><code class="name flex">
<span>def <span class="ident">notify_store</span></span>(<span>self, msg, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a notification from a store provider</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_store(self, msg, *args, **kwargs):
    &#39;&#39;&#39;Receives a notification from a store provider&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_timer"><code class="name flex">
<span>def <span class="ident">notify_timer</span></span>(<span>self, timer, when, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a timer notification where <code>timer</code> is the timer which was
returned by <code>add_timer</code>, and <code>when</code> is the calling time. <code>args</code>
and <code>kwargs</code> are any additional arguments passed to <code>add_timer</code></p>
<p>The actual <code>when</code> time can be later, but the system may have not be
able to call the timer before. This value is the timer value and no the
system time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_timer(self, timer, when, *args, **kwargs):
    &#39;&#39;&#39;Receives a timer notification where ``timer`` is the timer which was
    returned by ``add_timer``, and ``when`` is the calling time. ``args``
    and ``kwargs`` are any additional arguments passed to ``add_timer``

    The actual ``when`` time can be later, but the system may have not be
    able to call the timer before. This value is the timer value and no the
    system time.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.notify_trade"><code class="name flex">
<span>def <span class="ident">notify_trade</span></span>(<span>self, trade)</span>
</code></dt>
<dd>
<div class="desc"><p>Receives a trade whenever there has been a change in one</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_trade(self, trade):
    &#39;&#39;&#39;
    Receives a trade whenever there has been a change in one
    &#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.order_target_percent"><code class="name flex">
<span>def <span class="ident">order_target_percent</span></span>(<span>self, data=None, target=0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Place an order to rebalance a position to have final value of
<code>target</code> percentage of current portfolio <code>value</code></p>
<p><code>target</code> is expressed in decimal: <code>0.05</code> -&gt; <code>5%</code></p>
<p>It uses <code>order_target_value</code> to execute the order.</p>
<h2 id="example">Example</h2>
<ul>
<li>
<p><code>target=0.05</code> and portfolio value is <code>100</code></p>
</li>
<li>
<p>The <code>value</code> to be reached is <code>0.05 * 100 = 5</code></p>
</li>
<li>
<p><code>5</code> is passed as the <code>target</code> value to <code>order_target_value</code></p>
</li>
</ul>
<p>The current <code>value</code> is taken into account as the start point to
achieve <code>target</code></p>
<p>The <code>position.size</code> is used to determine if a position is <code>long</code> /
<code>short</code></p>
<ul>
<li>
<p>If <code>target</code> &gt; <code>value</code></p>
<ul>
<li>buy if <code>pos.size &gt;= 0</code> (Increase a long position)</li>
<li>sell if <code>pos.size &lt; 0</code> (Increase a short position)</li>
</ul>
</li>
<li>
<p>If <code>target</code> &lt; <code>value</code></p>
<ul>
<li>sell if <code>pos.size &gt;= 0</code> (Decrease a long position)</li>
<li>buy if <code>pos.size &lt; 0</code> (Decrease a short position)</li>
</ul>
</li>
</ul>
<p>It returns either:</p>
<ul>
<li>The generated order</li>
</ul>
<p>or</p>
<ul>
<li><code>None</code> if no order has been issued (<code>target == position.size</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_target_percent(self, data=None, target=0.0, **kwargs):
    &#39;&#39;&#39;
    Place an order to rebalance a position to have final value of
    ``target`` percentage of current portfolio ``value``

    ``target`` is expressed in decimal: ``0.05`` -&gt; ``5%``

    It uses ``order_target_value`` to execute the order.

    Example:
      - ``target=0.05`` and portfolio value is ``100``

      - The ``value`` to be reached is ``0.05 * 100 = 5``

      - ``5`` is passed as the ``target`` value to ``order_target_value``

    The current ``value`` is taken into account as the start point to
    achieve ``target``

    The ``position.size`` is used to determine if a position is ``long`` /
    ``short``

      - If ``target`` &gt; ``value``
        - buy if ``pos.size &gt;= 0`` (Increase a long position)
        - sell if ``pos.size &lt; 0`` (Increase a short position)

      - If ``target`` &lt; ``value``
        - sell if ``pos.size &gt;= 0`` (Decrease a long position)
        - buy if ``pos.size &lt; 0`` (Decrease a short position)

    It returns either:

      - The generated order

      or

      - ``None`` if no order has been issued (``target == position.size``)
    &#39;&#39;&#39;
    if isinstance(data, string_types):
        data = self.getdatabyname(data)
    elif data is None:
        data = self.data

    possize = self.getposition(data, self.broker).size
    target *= self.broker.getvalue()

    return self.order_target_value(data=data, target=target, **kwargs)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.order_target_size"><code class="name flex">
<span>def <span class="ident">order_target_size</span></span>(<span>self, data=None, target=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Place an order to rebalance a position to have final size of <code>target</code></p>
<p>The current <code>position</code> size is taken into account as the start point
to achieve <code>target</code></p>
<ul>
<li>
<p>If <code>target</code> &gt; <code>pos.size</code> -&gt; buy <code>target - pos.size</code></p>
</li>
<li>
<p>If <code>target</code> &lt; <code>pos.size</code> -&gt; sell <code>pos.size - target</code></p>
</li>
</ul>
<p>It returns either:</p>
<ul>
<li>The generated order</li>
</ul>
<p>or</p>
<ul>
<li><code>None</code> if no order has been issued (<code>target == position.size</code>)</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_target_size(self, data=None, target=0, **kwargs):
    &#39;&#39;&#39;
    Place an order to rebalance a position to have final size of ``target``

    The current ``position`` size is taken into account as the start point
    to achieve ``target``

      - If ``target`` &gt; ``pos.size`` -&gt; buy ``target - pos.size``

      - If ``target`` &lt; ``pos.size`` -&gt; sell ``pos.size - target``

    It returns either:

      - The generated order

      or

      - ``None`` if no order has been issued (``target == position.size``)
    &#39;&#39;&#39;
    if isinstance(data, string_types):
        data = self.getdatabyname(data)
    elif data is None:
        data = self.data

    possize = self.getposition(data, self.broker).size
    if not target and possize:
        return self.close(data=data, size=possize, **kwargs)

    elif target &gt; possize:
        return self.buy(data=data, size=target - possize, **kwargs)

    elif target &lt; possize:
        return self.sell(data=data, size=possize - target, **kwargs)

    return None  # no execution target == possize</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.order_target_value"><code class="name flex">
<span>def <span class="ident">order_target_value</span></span>(<span>self, data=None, target=0.0, price=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Place an order to rebalance a position to have final value of
<code>target</code></p>
<p>The current <code>value</code> is taken into account as the start point to
achieve <code>target</code></p>
<ul>
<li>If no <code>target</code> then close postion on data</li>
<li>If <code>target</code> &gt; <code>value</code> then buy on data</li>
<li>If <code>target</code> &lt; <code>value</code> then sell on data</li>
</ul>
<p>It returns either:</p>
<ul>
<li>The generated order</li>
</ul>
<p>or</p>
<ul>
<li><code>None</code> if no order has been issued</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_target_value(self, data=None, target=0.0, price=None, **kwargs):
    &#39;&#39;&#39;
    Place an order to rebalance a position to have final value of
    ``target``

    The current ``value`` is taken into account as the start point to
    achieve ``target``

      - If no ``target`` then close postion on data
      - If ``target`` &gt; ``value`` then buy on data
      - If ``target`` &lt; ``value`` then sell on data

    It returns either:

      - The generated order

      or

      - ``None`` if no order has been issued
    &#39;&#39;&#39;

    if isinstance(data, string_types):
        data = self.getdatabyname(data)
    elif data is None:
        data = self.data

    possize = self.getposition(data, self.broker).size
    if not target and possize:  # closing a position
        return self.close(data=data, size=possize, price=price, **kwargs)

    else:
        value = self.broker.getvalue(datas=[data])
        comminfo = self.broker.getcommissioninfo(data)

        # Make sure a price is there
        price = price if price is not None else data.close[0]

        if target &gt; value:
            size = comminfo.getsize(price, target - value)
            return self.buy(data=data, size=size, price=price, **kwargs)

        elif target &lt; value:
            size = comminfo.getsize(price, value - target)
            return self.sell(data=data, size=size, price=price, **kwargs)

    return None  # no execution size == possize</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.prenext_open"><code class="name flex">
<span>def <span class="ident">prenext_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prenext_open(self):
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.qbuffer"><code class="name flex">
<span>def <span class="ident">qbuffer</span></span>(<span>self, savemem=0, replaying=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the memory saving schemes. Possible values for <code>savemem</code>:</p>
<p>0: No savings. Each lines object keeps in memory all values</p>
<p>1: All lines objects save memory, using the strictly minimum needed</p>
<p>Negative values are meant to be used when plotting is required:</p>
<p>-1: Indicators at Strategy Level and Observers do not enable memory
savings (but anything declared below it does)</p>
<p>-2: Same as -1 plus activation of memory saving for any indicators
which has declared <em>plotinfo.plot</em> as False (will not be plotted)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qbuffer(self, savemem=0, replaying=False):
    &#39;&#39;&#39;Enable the memory saving schemes. Possible values for ``savemem``:

      0: No savings. Each lines object keeps in memory all values

      1: All lines objects save memory, using the strictly minimum needed

    Negative values are meant to be used when plotting is required:

      -1: Indicators at Strategy Level and Observers do not enable memory
          savings (but anything declared below it does)

      -2: Same as -1 plus activation of memory saving for any indicators
          which has declared *plotinfo.plot* as False (will not be plotted)
    &#39;&#39;&#39;
    if savemem &lt; 0:
        # Get any attribute which labels itself as Indicator
        for ind in self._lineiterators[self.IndType]:
            subsave = isinstance(ind, (LineSingle,))
            if not subsave and savemem &lt; -1:
                subsave = not ind.plotinfo.plot
            ind.qbuffer(savemem=subsave)

    elif savemem &gt; 0:
        for data in self.datas:
            data.qbuffer(replaying=replaying)

        for line in self.lines:
            line.qbuffer(savemem=1)

        # Save in all object types depending on the strategy
        for itcls in self._lineiterators:
            for it in self._lineiterators[itcls]:
                it.qbuffer(savemem=1)</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.sell"><code class="name flex">
<span>def <span class="ident">sell</span></span>(<span>self, data=None, size=None, price=None, plimit=None, exectype=None, valid=None, tradeid=0, oco=None, trailamount=None, trailpercent=None, parent=None, transmit=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>To create a selll (short) order and send it to the broker</p>
<p>See the documentation for <code>buy</code> for an explanation of the parameters</p>
<p>Returns: the submitted order</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sell(self, data=None,
         size=None, price=None, plimit=None,
         exectype=None, valid=None, tradeid=0, oco=None,
         trailamount=None, trailpercent=None,
         parent=None, transmit=True,
         **kwargs):
    &#39;&#39;&#39;
    To create a selll (short) order and send it to the broker

    See the documentation for ``buy`` for an explanation of the parameters

    Returns: the submitted order
    &#39;&#39;&#39;
    if isinstance(data, string_types):
        data = self.getdatabyname(data)

    data = data if data is not None else self.datas[0]
    size = size if size is not None else self.getsizing(data, isbuy=False)

    if size:
        return self.broker.sell(
            self, data,
            size=abs(size), price=price, plimit=plimit,
            exectype=exectype, valid=valid, tradeid=tradeid, oco=oco,
            trailamount=trailamount, trailpercent=trailpercent,
            parent=parent, transmit=transmit,
            **kwargs)

    return None</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.sell_bracket"><code class="name flex">
<span>def <span class="ident">sell_bracket</span></span>(<span>self, data=None, size=None, price=None, plimit=None, exectype=2, valid=None, tradeid=0, trailamount=None, trailpercent=None, oargs={}, stopprice=None, stopexec=3, stopargs={}, limitprice=None, limitexec=2, limitargs={}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a bracket order group (low side - buy order - high side). The
default behavior is as follows:</p>
<ul>
<li>
<p>Issue a <strong>sell</strong> order with execution <code>Limit</code></p>
</li>
<li>
<p>Issue a <em>high side</em> bracket <strong>buy</strong> order with execution <code>Stop</code></p>
</li>
<li>
<p>Issue a <em>low side</em> bracket <strong>buy</strong> order with execution <code>Limit</code>.</p>
</li>
</ul>
<p>See <code>bracket_buy</code> for the meaning of the parameters</p>
<p>High/Low Side orders can be suppressed by using:</p>
<ul>
<li>
<p><code>stopexec=None</code> to suppress the <em>high side</em></p>
</li>
<li>
<p><code>limitexec=None</code> to suppress the <em>low side</em></p>
</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li>
<p>A list containing the 3 orders [order, stop side, limit side]</p>
</li>
<li>
<p>If high/low orders have been suppressed the return value will still
contain 3 orders, but those suppressed will have a value of
<code>None</code></p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sell_bracket(self, data=None,
                 size=None, price=None, plimit=None,
                 exectype=bt.Order.Limit, valid=None, tradeid=0,
                 trailamount=None, trailpercent=None,
                 oargs={},
                 stopprice=None, stopexec=bt.Order.Stop, stopargs={},
                 limitprice=None, limitexec=bt.Order.Limit, limitargs={},
                 **kwargs):
    &#39;&#39;&#39;
    Create a bracket order group (low side - buy order - high side). The
    default behavior is as follows:

      - Issue a **sell** order with execution ``Limit``

      - Issue a *high side* bracket **buy** order with execution ``Stop``

      - Issue a *low side* bracket **buy** order with execution ``Limit``.

    See ``bracket_buy`` for the meaning of the parameters

    High/Low Side orders can be suppressed by using:

      - ``stopexec=None`` to suppress the *high side*

      - ``limitexec=None`` to suppress the *low side*

    Returns:

      - A list containing the 3 orders [order, stop side, limit side]

      - If high/low orders have been suppressed the return value will still
        contain 3 orders, but those suppressed will have a value of
        ``None``
    &#39;&#39;&#39;

    kargs = dict(size=size,
                 data=data, price=price, plimit=plimit, exectype=exectype,
                 valid=valid, tradeid=tradeid,
                 trailamount=trailamount, trailpercent=trailpercent)
    kargs.update(oargs)
    kargs.update(kwargs)
    kargs[&#39;transmit&#39;] = limitexec is None and stopexec is None
    o = self.sell(**kargs)

    if stopexec is not None:
        # high side / stop
        kargs = dict(data=data, price=stopprice, exectype=stopexec,
                     valid=valid, tradeid=tradeid)
        kargs.update(stopargs)
        kargs.update(kwargs)
        kargs[&#39;parent&#39;] = o
        kargs[&#39;transmit&#39;] = limitexec is None  # transmit if last
        kargs[&#39;size&#39;] = o.size
        ostop = self.buy(**kargs)
    else:
        ostop = None

    if limitexec is not None:
        # low side / limit
        kargs = dict(data=data, price=limitprice, exectype=limitexec,
                     valid=valid, tradeid=tradeid)
        kargs.update(limitargs)
        kargs.update(kwargs)
        kargs[&#39;parent&#39;] = o
        kargs[&#39;transmit&#39;] = True
        kargs[&#39;size&#39;] = o.size
        olimit = self.buy(**kargs)
    else:
        olimit = None

    return [o, ostop, olimit]</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.set_tradehistory"><code class="name flex">
<span>def <span class="ident">set_tradehistory</span></span>(<span>self, onoff=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tradehistory(self, onoff=True):
    self._tradehistoryon = onoff</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.setsizer"><code class="name flex">
<span>def <span class="ident">setsizer</span></span>(<span>self, sizer)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the default (fixed stake) sizer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setsizer(self, sizer):
    &#39;&#39;&#39;
    Replace the default (fixed stake) sizer
    &#39;&#39;&#39;
    self._sizer = sizer
    sizer.set(self, self.broker)
    return sizer</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right before the backtesting is about to be started.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#39;&#39;&#39;Called right before the backtesting is about to be started.&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="backtrader.strategy.Strategy.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called right before the backtesting is about to be stopped</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#39;&#39;&#39;Called right before the backtesting is about to be stopped&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="backtrader.lineiterator.StrategyBase" href="lineiterator.html#backtrader.lineiterator.StrategyBase">StrategyBase</a></b></code>:
<ul class="hlist">
<li><code><a title="backtrader.lineiterator.StrategyBase.addminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.addminperiod">addminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.incminperiod" href="lineroot.html#backtrader.lineroot.LineMultiple.incminperiod">incminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.lines" href="lineseries.html#backtrader.lineseries.LineSeries.lines">lines</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.minbuffer" href="lineroot.html#backtrader.lineroot.LineRoot.minbuffer">minbuffer</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.next" href="lineiterator.html#backtrader.lineiterator.LineIterator.next">next</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.nextstart" href="lineiterator.html#backtrader.lineiterator.LineIterator.nextstart">nextstart</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.once" href="lineroot.html#backtrader.lineroot.LineRoot.once">once</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.oncestart" href="lineroot.html#backtrader.lineroot.LineRoot.oncestart">oncestart</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.prenext" href="lineiterator.html#backtrader.lineiterator.LineIterator.prenext">prenext</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.preonce" href="lineroot.html#backtrader.lineroot.LineRoot.preonce">preonce</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.setminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.setminperiod">setminperiod</a></code></li>
<li><code><a title="backtrader.lineiterator.StrategyBase.updateminperiod" href="lineroot.html#backtrader.lineroot.LineRoot.updateminperiod">updateminperiod</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="backtrader" href="index.html">backtrader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="backtrader.strategy.MetaSigStrategy" href="#backtrader.strategy.MetaSigStrategy">MetaSigStrategy</a></code></h4>
<ul class="">
<li><code><a title="backtrader.strategy.MetaSigStrategy.dopostinit" href="#backtrader.strategy.MetaSigStrategy.dopostinit">dopostinit</a></code></li>
<li><code><a title="backtrader.strategy.MetaSigStrategy.dopreinit" href="#backtrader.strategy.MetaSigStrategy.dopreinit">dopreinit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.strategy.MetaStrategy" href="#backtrader.strategy.MetaStrategy">MetaStrategy</a></code></h4>
<ul class="">
<li><code><a title="backtrader.strategy.MetaStrategy.dopostinit" href="#backtrader.strategy.MetaStrategy.dopostinit">dopostinit</a></code></li>
<li><code><a title="backtrader.strategy.MetaStrategy.dopreinit" href="#backtrader.strategy.MetaStrategy.dopreinit">dopreinit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.strategy.SignalStrategy" href="#backtrader.strategy.SignalStrategy">SignalStrategy</a></code></h4>
<ul class="two-column">
<li><code><a title="backtrader.strategy.SignalStrategy.alias" href="#backtrader.strategy.SignalStrategy.alias">alias</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.aliased" href="#backtrader.strategy.SignalStrategy.aliased">aliased</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.frompackages" href="#backtrader.strategy.SignalStrategy.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.linealias" href="#backtrader.strategy.SignalStrategy.linealias">linealias</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.packages" href="#backtrader.strategy.SignalStrategy.packages">packages</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.params" href="#backtrader.strategy.SignalStrategy.params">params</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.plotinfo" href="#backtrader.strategy.SignalStrategy.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.plotlines" href="#backtrader.strategy.SignalStrategy.plotlines">plotlines</a></code></li>
<li><code><a title="backtrader.strategy.SignalStrategy.signal_add" href="#backtrader.strategy.SignalStrategy.signal_add">signal_add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="backtrader.strategy.Strategy" href="#backtrader.strategy.Strategy">Strategy</a></code></h4>
<ul class="">
<li><code><a title="backtrader.strategy.Strategy.add_timer" href="#backtrader.strategy.Strategy.add_timer">add_timer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.alias" href="#backtrader.strategy.Strategy.alias">alias</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.aliased" href="#backtrader.strategy.Strategy.aliased">aliased</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.buy" href="#backtrader.strategy.Strategy.buy">buy</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.buy_bracket" href="#backtrader.strategy.Strategy.buy_bracket">buy_bracket</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.cancel" href="#backtrader.strategy.Strategy.cancel">cancel</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.clear" href="#backtrader.strategy.Strategy.clear">clear</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.close" href="#backtrader.strategy.Strategy.close">close</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.csv" href="#backtrader.strategy.Strategy.csv">csv</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.frompackages" href="#backtrader.strategy.Strategy.frompackages">frompackages</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getdatabyname" href="#backtrader.strategy.Strategy.getdatabyname">getdatabyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getdatanames" href="#backtrader.strategy.Strategy.getdatanames">getdatanames</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getposition" href="#backtrader.strategy.Strategy.getposition">getposition</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositionbyname" href="#backtrader.strategy.Strategy.getpositionbyname">getpositionbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositions" href="#backtrader.strategy.Strategy.getpositions">getpositions</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getpositionsbyname" href="#backtrader.strategy.Strategy.getpositionsbyname">getpositionsbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getsizer" href="#backtrader.strategy.Strategy.getsizer">getsizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getsizing" href="#backtrader.strategy.Strategy.getsizing">getsizing</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getwriterheaders" href="#backtrader.strategy.Strategy.getwriterheaders">getwriterheaders</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getwriterinfo" href="#backtrader.strategy.Strategy.getwriterinfo">getwriterinfo</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.getwritervalues" href="#backtrader.strategy.Strategy.getwritervalues">getwritervalues</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.linealias" href="#backtrader.strategy.Strategy.linealias">linealias</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.next_open" href="#backtrader.strategy.Strategy.next_open">next_open</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.nextstart_open" href="#backtrader.strategy.Strategy.nextstart_open">nextstart_open</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_cashvalue" href="#backtrader.strategy.Strategy.notify_cashvalue">notify_cashvalue</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_data" href="#backtrader.strategy.Strategy.notify_data">notify_data</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_fund" href="#backtrader.strategy.Strategy.notify_fund">notify_fund</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_order" href="#backtrader.strategy.Strategy.notify_order">notify_order</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_store" href="#backtrader.strategy.Strategy.notify_store">notify_store</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_timer" href="#backtrader.strategy.Strategy.notify_timer">notify_timer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.notify_trade" href="#backtrader.strategy.Strategy.notify_trade">notify_trade</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_percent" href="#backtrader.strategy.Strategy.order_target_percent">order_target_percent</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_size" href="#backtrader.strategy.Strategy.order_target_size">order_target_size</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.order_target_value" href="#backtrader.strategy.Strategy.order_target_value">order_target_value</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.packages" href="#backtrader.strategy.Strategy.packages">packages</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.params" href="#backtrader.strategy.Strategy.params">params</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.plotinfo" href="#backtrader.strategy.Strategy.plotinfo">plotinfo</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.plotlines" href="#backtrader.strategy.Strategy.plotlines">plotlines</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.position" href="#backtrader.strategy.Strategy.position">position</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positionbyname" href="#backtrader.strategy.Strategy.positionbyname">positionbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positions" href="#backtrader.strategy.Strategy.positions">positions</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.positionsbyname" href="#backtrader.strategy.Strategy.positionsbyname">positionsbyname</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.prenext_open" href="#backtrader.strategy.Strategy.prenext_open">prenext_open</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.qbuffer" href="#backtrader.strategy.Strategy.qbuffer">qbuffer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sell" href="#backtrader.strategy.Strategy.sell">sell</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sell_bracket" href="#backtrader.strategy.Strategy.sell_bracket">sell_bracket</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.set_tradehistory" href="#backtrader.strategy.Strategy.set_tradehistory">set_tradehistory</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.setsizer" href="#backtrader.strategy.Strategy.setsizer">setsizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.sizer" href="#backtrader.strategy.Strategy.sizer">sizer</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.start" href="#backtrader.strategy.Strategy.start">start</a></code></li>
<li><code><a title="backtrader.strategy.Strategy.stop" href="#backtrader.strategy.Strategy.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>